Only in extension/dcre: DIFF
Only in .: E_PACKAGE
Only in .: MANIFEST
Only in .: MANIFEST.early
Only in .: README.txt
Only in ./arch: arm_gcc
Only in ./arch/gcc: ldscript.trb
Only in ./arch/gcc: tool_stddef.h
diff -r ./arch/gcc/tool_svc.h extension/dcre/arch/gcc/tool_svc.h
711a712,975
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER_ID
> acre_tsk(const T_CTSK *pk_ctsk)
> {
> 	CAL_SVC_1M(ER_ID, TFN_ACRE_TSK, const T_CTSK *, pk_ctsk);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER_ID
> acre_sem(const T_CSEM *pk_csem)
> {
> 	CAL_SVC_1M(ER_ID, TFN_ACRE_SEM, const T_CSEM *, pk_csem);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER_ID
> acre_flg(const T_CFLG *pk_cflg)
> {
> 	CAL_SVC_1M(ER_ID, TFN_ACRE_FLG, const T_CFLG *, pk_cflg);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER_ID
> acre_dtq(const T_CDTQ *pk_cdtq)
> {
> 	CAL_SVC_1M(ER_ID, TFN_ACRE_DTQ, const T_CDTQ *, pk_cdtq);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER_ID
> acre_pdq(const T_CPDQ *pk_cpdq)
> {
> 	CAL_SVC_1M(ER_ID, TFN_ACRE_PDQ, const T_CPDQ *, pk_cpdq);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER_ID
> acre_mtx(const T_CMTX *pk_cmtx)
> {
> 	CAL_SVC_1M(ER_ID, TFN_ACRE_MTX, const T_CMTX *, pk_cmtx);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER_ID
> acre_mbf(const T_CMBF *pk_cmbf)
> {
> 	CAL_SVC_1M(ER_ID, TFN_ACRE_MBF, const T_CMBF *, pk_cmbf);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER_ID
> acre_mpf(const T_CMPF *pk_cmpf)
> {
> 	CAL_SVC_1M(ER_ID, TFN_ACRE_MPF, const T_CMPF *, pk_cmpf);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER_ID
> acre_cyc(const T_CCYC *pk_ccyc)
> {
> 	CAL_SVC_1M(ER_ID, TFN_ACRE_CYC, const T_CCYC *, pk_ccyc);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER_ID
> acre_alm(const T_CALM *pk_calm)
> {
> 	CAL_SVC_1M(ER_ID, TFN_ACRE_ALM, const T_CALM *, pk_calm);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER_ID
> acre_isr(const T_CISR *pk_cisr)
> {
> 	CAL_SVC_1M(ER_ID, TFN_ACRE_ISR, const T_CISR *, pk_cisr);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER
> del_tsk(ID tskid)
> {
> 	CAL_SVC_1M(ER, TFN_DEL_TSK, ID, tskid);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER
> del_sem(ID semid)
> {
> 	CAL_SVC_1M(ER, TFN_DEL_SEM, ID, semid);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER
> del_flg(ID flgid)
> {
> 	CAL_SVC_1M(ER, TFN_DEL_FLG, ID, flgid);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER
> del_dtq(ID dtqid)
> {
> 	CAL_SVC_1M(ER, TFN_DEL_DTQ, ID, dtqid);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER
> del_pdq(ID pdqid)
> {
> 	CAL_SVC_1M(ER, TFN_DEL_PDQ, ID, pdqid);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER
> del_mtx(ID mtxid)
> {
> 	CAL_SVC_1M(ER, TFN_DEL_MTX, ID, mtxid);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER
> del_mbf(ID mbfid)
> {
> 	CAL_SVC_1M(ER, TFN_DEL_MBF, ID, mbfid);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER
> del_mpf(ID mpfid)
> {
> 	CAL_SVC_1M(ER, TFN_DEL_MPF, ID, mpfid);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER
> del_cyc(ID cycid)
> {
> 	CAL_SVC_1M(ER, TFN_DEL_CYC, ID, cycid);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER
> del_alm(ID almid)
> {
> 	CAL_SVC_1M(ER, TFN_DEL_ALM, ID, almid);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER
> del_isr(ID isrid)
> {
> 	CAL_SVC_1M(ER, TFN_DEL_ISR, ID, isrid);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER
> sac_tsk(ID tskid, const ACVCT *p_acvct)
> {
> 	CAL_SVC_2M(ER, TFN_SAC_TSK, ID, tskid, const ACVCT *, p_acvct);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER
> sac_sem(ID semid, const ACVCT *p_acvct)
> {
> 	CAL_SVC_2M(ER, TFN_SAC_SEM, ID, semid, const ACVCT *, p_acvct);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER
> sac_flg(ID flgid, const ACVCT *p_acvct)
> {
> 	CAL_SVC_2M(ER, TFN_SAC_FLG, ID, flgid, const ACVCT *, p_acvct);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER
> sac_dtq(ID dtqid, const ACVCT *p_acvct)
> {
> 	CAL_SVC_2M(ER, TFN_SAC_DTQ, ID, dtqid, const ACVCT *, p_acvct);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER
> sac_pdq(ID pdqid, const ACVCT *p_acvct)
> {
> 	CAL_SVC_2M(ER, TFN_SAC_PDQ, ID, pdqid, const ACVCT *, p_acvct);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER
> sac_mtx(ID mtxid, const ACVCT *p_acvct)
> {
> 	CAL_SVC_2M(ER, TFN_SAC_MTX, ID, mtxid, const ACVCT *, p_acvct);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER
> sac_mbf(ID mbfid, const ACVCT *p_acvct)
> {
> 	CAL_SVC_2M(ER, TFN_SAC_MBF, ID, mbfid, const ACVCT *, p_acvct);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER
> sac_mpf(ID mpfid, const ACVCT *p_acvct)
> {
> 	CAL_SVC_2M(ER, TFN_SAC_MPF, ID, mpfid, const ACVCT *, p_acvct);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER
> sac_cyc(ID cycid, const ACVCT *p_acvct)
> {
> 	CAL_SVC_2M(ER, TFN_SAC_CYC, ID, cycid, const ACVCT *, p_acvct);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER
> sac_alm(ID almid, const ACVCT *p_acvct)
> {
> 	CAL_SVC_2M(ER, TFN_SAC_ALM, ID, almid, const ACVCT *, p_acvct);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> Inline ER
> sac_isr(ID isrid, const ACVCT *p_acvct)
> {
> 	CAL_SVC_2M(ER, TFN_SAC_ISR, ID, isrid, const ACVCT *, p_acvct);
> }
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
Only in ./arch: simtimer
Only in ./arch: tracelog
Only in .: cfg
Only in .: cfg_test
Only in .: configure.rb
Only in .: doc
Only in .: extension
Only in ./include: extsvc_fncode.h
Only in ./include: itron.h
diff -r ./include/kernel.h extension/dcre/include/kernel.h
8c8
<  *  Copyright (C) 2004-2018 by Embedded and Real-Time Systems Laboratory
---
>  *  Copyright (C) 2004-2019 by Embedded and Real-Time Systems Laboratory
121a122,123
> #define TOPPERS_SUPPORT_DYNAMIC_CRE		/* 動的生成機能拡張 */
> 
162a165,230
>  *  タイムイベントの通知方法のパケット形式の定義
>  */
> typedef struct {
> 	intptr_t	exinf;		/* タイムイベントハンドラの拡張情報 */
> 	TMEHDR		tmehdr;		/* タイムイベントハンドラの先頭番地 */
> } T_NFY_HDR;
> 
> typedef struct {
> 	intptr_t	*p_var;		/* 変数の番地 */
> 	intptr_t	value;		/* 設定する値 */
> } T_NFY_VAR;
> 
> typedef struct {
> 	intptr_t	*p_var;		/* 変数の番地 */
> } T_NFY_IVAR;
> 
> typedef struct {
> 	ID			tskid;		/* タスクID */
> } T_NFY_TSK;
> 
> typedef struct {
> 	ID			semid;		/* セマフォID */
> } T_NFY_SEM;
> 
> typedef struct {
> 	ID			flgid;		/* イベントフラグID */
> 	FLGPTN		flgptn;		/* セットするビットパターン */
> } T_NFY_FLG;
> 
> typedef struct {
> 	ID			dtqid;		/* データキューID */
> 	intptr_t	data;		/* 送信する値 */
> } T_NFY_DTQ;
> 
> typedef struct {
> 	intptr_t	*p_var;		/* 変数の番地 */
> } T_ENFY_VAR;
> 
> typedef struct {
> 	ID			dtqid;		/* データキューID */
> } T_ENFY_DTQ;
> 
> typedef struct {
> 	MODE	nfymode;			/* 通知処理モード */
> 	union {						/* タイムイベントの通知に関する付随情報 */
> 		T_NFY_HDR	handler;
> 		T_NFY_VAR	setvar;		
> 		T_NFY_IVAR	incvar;		
> 		T_NFY_TSK	acttsk;
> 		T_NFY_TSK	wuptsk;
> 		T_NFY_SEM	sigsem;
> 		T_NFY_FLG	setflg;
> 		T_NFY_DTQ	snddtq;
> 	} nfy;
> 	union {						/* エラーの通知に関する付随情報 */
> 		T_ENFY_VAR	setvar;
> 		T_NFY_IVAR	incvar;		
> 		T_NFY_TSK	acttsk;
> 		T_NFY_TSK	wuptsk;
> 		T_NFY_SEM	sigsem;
> 		T_NFY_FLG	setflg;
> 		T_ENFY_DTQ	snddtq;
> 	} enfy;
> } T_NFYINFO;
> 
> /*
164a233,243
> typedef struct t_ctsk {
> 	ATR			tskatr;		/* タスク属性 */
> 	intptr_t	exinf;		/* タスクの拡張情報 */
> 	TASK		task;		/* タスクのメインルーチンの先頭番地 */
> 	PRI			itskpri;	/* タスクの起動時優先度 */
> 	size_t		stksz;		/* タスクのスタック領域のサイズ */
> 	STK_T		*stk;		/* タスクのスタック領域の先頭番地 */
> 	size_t		sstksz;		/* タスクのシステムスタック領域のサイズ */
> 	STK_T		*sstk;		/* タスクのシステムスタック領域の先頭番地 */
> } T_CTSK;
> 
178a258,263
> typedef struct t_csem {
> 	ATR		sematr;		/* セマフォ属性 */
> 	uint_t	isemcnt;	/* セマフォの初期資源数 */
> 	uint_t	maxsem;		/* セマフォの最大資源数 */
> } T_CSEM;
> 
183a269,273
> typedef struct t_cflg {
> 	ATR		flgatr;		/* イベントフラグ属性 */
> 	FLGPTN	iflgptn;	/* イベントフラグの初期ビットパターン */
> } T_CFLG;
> 
188a279,284
> typedef struct t_cdtq {
> 	ATR		dtqatr;		/* データキュー属性 */
> 	uint_t	dtqcnt;		/* データキュー管理領域に格納できるデータ数 */
> 	void	*dtqmb;		/* データキュー管理領域の先頭番地 */
> } T_CDTQ;
> 
194a291,298
> typedef struct t_cpdq {
> 	ATR		pdqatr;		/* 優先度データキュー属性 */
> 	uint_t	pdqcnt;		/* 優先度データキュー管理領域に格納できるデータ数 */
> 	PRI		maxdpri;	/* 優先度データキューに送信できるデータ優先度の最
> 						   大値 */
> 	void	*pdqmb;		/* 優先度データキュー管理領域の先頭番地 */
> } T_CPDQ;
> 
203a308,312
> typedef struct t_cmtx {
> 	ATR		mtxatr;		/* ミューテックス属性 */
> 	PRI		ceilpri;	/* ミューテックスの上限優先度 */
> } T_CMTX;
> 
208a318,326
> typedef struct t_cmbf {
> 	ATR		mbfatr;		/* メッセージバッファ属性 */
> 	uint_t	maxmsz;		/* メッセージバッファの最大メッセージ
> 							   サイズ（バイト数）*/
> 	size_t	mbfsz;		/* メッセージバッファ管理領域のサイズ
> 							   （バイト数）*/
> 	void	*mbfmb;		/* メッセージバッファ管理領域の先頭番地 */
> } T_CMBF;
> 
218a337,344
> typedef struct t_cmpf {
> 	ATR		mpfatr;		/* 固定長メモリプール属性 */
> 	uint_t	blkcnt;		/* 獲得できる固定長メモリブロックの数 */
> 	uint_t	blksz;		/* 固定長メモリブロックのサイズ */
> 	MPF_T	*mpf;		/* 固定長メモリプール領域の先頭番地 */
> 	void	*mpfmb;		/* 固定長メモリプール管理領域の先頭番地 */
> } T_CMPF;
> 
225a352,358
> typedef struct t_ccyc {
> 	ATR			cycatr;		/* 周期通知属性 */
> 	T_NFYINFO	nfyinfo;	/* 周期通知の通知方法 */
> 	RELTIM		cyctim;		/* 周期通知の通知周期 */
> 	RELTIM		cycphs;		/* 周期通知の通知位相 */
> } T_CCYC;
> 
230a364,368
> typedef struct t_calm {
> 	ATR			almatr;		/* アラーム通知属性 */
> 	T_NFYINFO	nfyinfo;	/* アラーム通知の通知方法 */
> } T_CALM;
> 
235a374,381
> typedef struct t_cisr {
> 	ATR			isratr;		/* 割込みサービスルーチン属性 */
> 	intptr_t	exinf;		/* 割込みサービスルーチンの拡張情報 */
> 	INTNO		intno;		/* 割込みサービスルーチンを登録する割込み番号 */
> 	ISR			isr;		/* 割込みサービスルーチンの先頭番地 */
> 	PRI			isrpri;		/* 割込みサービスルーチン優先度 */
> } T_CISR;
> 
289a436,438
> #define TA_DOM(domid)	((((uint_t) domid) & 0xffU) << 16)
> 										/* 属する保護ドメインの指定 */
> 
490a640,650
> #define COUNT_MB_T(sz)		TOPPERS_COUNT_SZ(sz, sizeof(MB_T))
> #define ROUND_MB_T(sz)		TOPPERS_ROUND_SZ(sz, sizeof(MB_T))
> 
> #define TSZ_DTQMB(dtqcnt)	(sizeof(intptr_t) * (dtqcnt))
> #define TCNT_DTQMB(dtqcnt)	COUNT_MB_T(TSZ_DTQMB(dtqcnt))
> 
> #ifndef TSZ_PDQMB
> #define TSZ_PDQMB(pdqcnt)	(sizeof(intptr_t) * 3 * (pdqcnt))
> #endif /* TSZ_PDQMB */
> #define TCNT_PDQMB(pdqcnt)	COUNT_MB_T(TSZ_PDQMB(pdqcnt))
> 
492a653
> #define TCNT_MBFMB(mbfcnt)	COUNT_MB_T(TSZ_MBFMB(mbfcnt))
496a658,660
> #define TSZ_MPFMB(blkcnt)	(sizeof(uint_t) * (blkcnt))
> #define TCNT_MPFMB(blkcnt)	COUNT_MB_T(TSZ_MPFMB(blkcnt))
> 
Only in ./include: kernel_fncode.h
Only in ./include: log_output.h
Only in ./include: queue.h
Only in ./include: sil.h
diff -r ./include/svc_call.h extension/dcre/include/svc_call.h
140a141,239
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER_ID _kernel_acre_tsk(const T_CTSK *pk_ctsk) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER_ID _kernel_acre_sem(const T_CSEM *pk_csem) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER_ID _kernel_acre_flg(const T_CFLG *pk_cflg) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER_ID _kernel_acre_dtq(const T_CDTQ *pk_cdtq) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER_ID _kernel_acre_pdq(const T_CPDQ *pk_cpdq) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER_ID _kernel_acre_mtx(const T_CMTX *pk_cmtx) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER_ID _kernel_acre_mbf(const T_CMBF *pk_cmbf) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER_ID _kernel_acre_mpf(const T_CMPF *pk_cmpf) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER_ID _kernel_acre_cyc(const T_CCYC *pk_ccyc) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER_ID _kernel_acre_alm(const T_CALM *pk_calm) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER_ID _kernel_acre_isr(const T_CISR *pk_cisr) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER _kernel_del_tsk(ID tskid) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER _kernel_del_sem(ID semid) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER _kernel_del_flg(ID flgid) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER _kernel_del_dtq(ID dtqid) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER _kernel_del_pdq(ID pdqid) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER _kernel_del_mtx(ID mtxid) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER _kernel_del_mbf(ID mbfid) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER _kernel_del_mpf(ID mpfid) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER _kernel_del_cyc(ID cycid) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER _kernel_del_alm(ID almid) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER _kernel_del_isr(ID isrid) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER _kernel_sac_tsk(ID tskid, const ACVCT *p_acvct) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER _kernel_sac_sem(ID semid, const ACVCT *p_acvct) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER _kernel_sac_flg(ID flgid, const ACVCT *p_acvct) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER _kernel_sac_dtq(ID dtqid, const ACVCT *p_acvct) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER _kernel_sac_pdq(ID pdqid, const ACVCT *p_acvct) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER _kernel_sac_mtx(ID mtxid, const ACVCT *p_acvct) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER _kernel_sac_mbf(ID mbfid, const ACVCT *p_acvct) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER _kernel_sac_mpf(ID mpfid, const ACVCT *p_acvct) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER _kernel_sac_cyc(ID cycid, const ACVCT *p_acvct) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER _kernel_sac_alm(ID almid, const ACVCT *p_acvct) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> extern ER _kernel_sac_isr(ID isrid, const ACVCT *p_acvct) throw();
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
284a384,482
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define acre_tsk _kernel_acre_tsk
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define acre_sem _kernel_acre_sem
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define acre_flg _kernel_acre_flg
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define acre_dtq _kernel_acre_dtq
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define acre_pdq _kernel_acre_pdq
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define acre_mtx _kernel_acre_mtx
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define acre_mbf _kernel_acre_mbf
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define acre_mpf _kernel_acre_mpf
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define acre_cyc _kernel_acre_cyc
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define acre_alm _kernel_acre_alm
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define acre_isr _kernel_acre_isr
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define del_tsk _kernel_del_tsk
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define del_sem _kernel_del_sem
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define del_flg _kernel_del_flg
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define del_dtq _kernel_del_dtq
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define del_pdq _kernel_del_pdq
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define del_mtx _kernel_del_mtx
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define del_mbf _kernel_del_mbf
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define del_mpf _kernel_del_mpf
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define del_cyc _kernel_del_cyc
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define del_alm _kernel_del_alm
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define del_isr _kernel_del_isr
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define sac_tsk _kernel_sac_tsk
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define sac_sem _kernel_sac_sem
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define sac_flg _kernel_sac_flg
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define sac_dtq _kernel_sac_dtq
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define sac_pdq _kernel_sac_pdq
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define sac_mtx _kernel_sac_mtx
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define sac_mbf _kernel_sac_mbf
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define sac_mpf _kernel_sac_mpf
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define sac_cyc _kernel_sac_cyc
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define sac_alm _kernel_sac_alm
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> #ifdef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define sac_isr _kernel_sac_isr
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
Only in ./include: t_stddef.h
Only in ./include: t_stdlib.h
Only in ./include: t_syslog.h
diff -r ./kernel/Makefile.kernel extension/dcre/kernel/Makefile.kernel
61c61
< startup = sta_ker.o ext_ker.o
---
> startup = sta_ker.o ext_ker.o kermem.o
74c74,75
< memory = memini.o memsearch.o memprbw.o memprbr.o secini.o
---
> memory = memini.o memsearch.o memprbw.o memprbr.o memprbwdom.o memprbrwdom.o \
> 		validmemobj.o validmemobjk.o validmemobjd.o validustack.o secini.o
79c80,81
< task_manage = act_tsk.o can_act.o get_tst.o chg_pri.o get_pri.o get_inf.o
---
> task_manage = acre_tsk.o sac_tsk.o del_tsk.o act_tsk.o can_act.o \
> 		get_tst.o chg_pri.o get_pri.o get_inf.o
88c90
< semaphore = semini.o sig_sem.o \
---
> semaphore = semini.o acre_sem.o sac_sem.o del_sem.o sig_sem.o \
91,92c93,94
< eventflag = flgini.o flgcnd.o set_flg.o clr_flg.o \
< 		wai_flg.o pol_flg.o twai_flg.o ini_flg.o ref_flg.o
---
> eventflag = flgini.o flgcnd.o acre_flg.o sac_flg.o del_flg.o set_flg.o \
> 		clr_flg.o wai_flg.o pol_flg.o twai_flg.o ini_flg.o ref_flg.o
94a97
> 		acre_dtq.o sac_dtq.o del_dtq.o \
98a102
> 		acre_pdq.o sac_pdq.o del_pdq.o \
102a107
> 		acre_mtx.o sac_mtx.o del_mtx.o \
107c112
< 		snd_mbf.o psnd_mbf.o tsnd_mbf.o \
---
> 		acre_mbf.o sac_mbf.o del_mbf.o snd_mbf.o psnd_mbf.o tsnd_mbf.o \
110,111c115,116
< mempfix = mpfini.o mpfget.o get_mpf.o pget_mpf.o tget_mpf.o \
< 		rel_mpf.o ini_mpf.o ref_mpf.o
---
> mempfix = mpfini.o mpfget.o acre_mpf.o sac_mpf.o del_mpf.o \
> 		get_mpf.o pget_mpf.o tget_mpf.o rel_mpf.o ini_mpf.o ref_mpf.o
113c118
< time_manage = set_tim.o get_tim.o adj_tim.o fch_hrt.o
---
> time_manage = set_tim.o get_tim.o adj_tim.o fch_hrt.o chknfy.o nfyhdr.o
115c120,121
< cyclic = cycini.o sta_cyc.o stp_cyc.o ref_cyc.o cyccal.o
---
> cyclic = cycini.o acre_cyc.o sac_cyc.o del_cyc.o \
> 		sta_cyc.o stp_cyc.o ref_cyc.o cyccal.o
117c123,124
< alarm = almini.o sta_alm.o stp_alm.o ref_alm.o almcal.o
---
> alarm = almini.o acre_alm.o sac_alm.o del_alm.o \
> 		sta_alm.o stp_alm.o ref_alm.o almcal.o
126,127c133,134
< interrupt = intini.o dis_int.o ena_int.o clr_int.o ras_int.o prb_int.o \
< 		chg_ipm.o get_ipm.o
---
> interrupt = isrini.o isrcal.o acre_isr.o sac_isr.o del_isr.o intini.o \
> 		dis_int.o ena_int.o clr_int.o ras_int.o prb_int.o chg_ipm.o get_ipm.o
diff -r ./kernel/alarm.c extension/dcre/kernel/alarm.c
40c40
<  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
---
>  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
48a49
> #include "domain.h"
61a63,86
> #ifndef LOG_ACRE_ALM_ENTER
> #define LOG_ACRE_ALM_ENTER(pk_calm)
> #endif /* LOG_ACRE_ALM_ENTER */
> 
> #ifndef LOG_ACRE_ALM_LEAVE
> #define LOG_ACRE_ALM_LEAVE(ercd)
> #endif /* LOG_ACRE_ALM_LEAVE */
> 
> #ifndef LOG_SAC_ALM_ENTER
> #define LOG_SAC_ALM_ENTER(almid, p_acvct)
> #endif /* LOG_SAC_ALM_ENTER */
> 
> #ifndef LOG_SAC_ALM_LEAVE
> #define LOG_SAC_ALM_LEAVE(ercd)
> #endif /* LOG_SAC_ALM_LEAVE */
> 
> #ifndef LOG_DEL_ALM_ENTER
> #define LOG_DEL_ALM_ENTER(almid)
> #endif /* LOG_DEL_ALM_ENTER */
> 
> #ifndef LOG_DEL_ALM_LEAVE
> #define LOG_DEL_ALM_LEAVE(ercd)
> #endif /* LOG_DEL_ALM_LEAVE */
> 
89a115
> #define tnum_salm	((uint_t)(tmax_salmid - TMIN_ALMID + 1))
98a125,128
>  *
>  *  未使用のアラーム通知管理ブロックのキューを作るために，アラーム通知
>  *  管理ブロックの先頭にはキューにつなぐための領域がないため，タイムイ
>  *  ベントブロック（tmevtb）の領域を用いる．
101a132,143
> static void
> initialize_almcb(ALMCB *p_almcb, ALMINIB *p_alminib, const DOMINIB *p_dominib)
> {
> 	p_alminib->p_tmevt_heap = p_dominib->p_tmevt_heap;
> 	p_alminib->almatr = TA_NOEXS;
> 	p_almcb->p_alminib = (const ALMINIB *) p_alminib;
> 	p_almcb->tmevtb.callback = (CBACK) call_alarm;
> 	p_almcb->tmevtb.arg = (void *) p_almcb;
> 	queue_insert_prev(&(p_dominib->p_domcb->free_almcb),
> 								((QUEUE *) &(p_almcb->tmevtb)));
> }
> 
105,106c147,150
< 	uint_t	i;
< 	ALMCB	*p_almcb;
---
> 	uint_t			i, j, k;
> 	ID				domid;
> 	ALMCB			*p_almcb;
> 	const DOMINIB	*p_dominib;
108c152
< 	for (i = 0; i < tnum_alm; i++) {
---
> 	for (i = 0; i < tnum_salm; i++) {
114a159,172
> 
> 	queue_initialize(&(dominib_kernel.p_domcb->free_almcb));
> 	for (j = 0; j < dominib_kernel.tnum_aalmid; i++, j++) {
> 		initialize_almcb(&(almcb_table[i]), &(aalminib_table[j]),
> 													&dominib_kernel);
> 	}
> 	for (domid = TMIN_DOMID; domid <= tmax_domid; domid++) {
> 		p_dominib = get_dominib(domid);
> 		queue_initialize(&(p_dominib->p_domcb->free_almcb));
> 		for (k = 0; k < p_dominib->tnum_aalmid; i++, j++, k++) {
> 			initialize_almcb(&(almcb_table[i]), &(aalminib_table[j]),
> 															p_dominib);
> 		}
> 	}
119a178,356
>  *  アラーム通知の生成
>  */
> #ifdef TOPPERS_acre_alm
> 
> ER_UINT
> acre_alm(const T_CALM *pk_calm)
> {
> 	ALMCB			*p_almcb;
> 	ALMINIB			*p_alminib;
> 	ATR				almatr;
> 	ID				domid;
> 	const DOMINIB	*p_dominib;
> 	T_NFYINFO		*p_nfyinfo;
> 	ACPTN			acptn;
> 	ER				ercd;
> 
> 	LOG_ACRE_ALM_ENTER(pk_calm);
> 	CHECK_TSKCTX_UNL();
> 	CHECK_MACV_READ(pk_calm, T_CALM);
> 
> 	almatr = pk_calm->almatr;
> 
> 	CHECK_VALIDATR(almatr, TA_NULL|TA_DOMMASK);
> 	domid = get_atrdomid(almatr);
> 	if (domid == TDOM_SELF) {
> 		if (rundom == TACP_KERNEL) {
> 			domid = TDOM_KERNEL;
> 		}
> 		else {
> 			domid = p_runtsk->p_tinib->domid;
> 		}
> 		almatr = set_atrdomid(almatr, domid);
> 	}
> 	if (domid == TDOM_KERNEL) {
> 		p_dominib = &dominib_kernel;
> 	}
> 	else {
> 		CHECK_RSATR(VALID_DOMID(domid));
> 		p_dominib = get_dominib(domid);
> 	}
> 	ercd = check_nfyinfo(&(pk_calm->nfyinfo), p_dominib->domptn);
> 	if (ercd != E_OK) {
> 		goto error_exit;
> 	}
> 	CHECK_ACPTN(p_dominib->acvct.acptn1);
> 	
> 	lock_cpu();
> 	if (tnum_alm == 0 || queue_empty(&(p_dominib->p_domcb->free_almcb))) {
> 		ercd = E_NOID;
> 	}
> 	else {
> 		p_almcb = (ALMCB *)
> 			(((char *) queue_delete_next(&(p_dominib->p_domcb->free_almcb)))
> 													- offsetof(ALMCB, tmevtb));
> 		p_alminib = (ALMINIB *)(p_almcb->p_alminib);
> 		p_alminib->almatr = almatr;
> 		if (pk_calm->nfyinfo.nfymode == TNFY_HANDLER) {
> 			p_alminib->exinf = pk_calm->nfyinfo.nfy.handler.exinf;
> 			p_alminib->nfyhdr = (NFYHDR)(pk_calm->nfyinfo.nfy.handler.tmehdr);
> 		}
> 		else {
> 			p_nfyinfo = &aalm_nfyinfo_table[p_alminib - aalminib_table];
> 			*p_nfyinfo = pk_calm->nfyinfo;
> 			p_alminib->exinf = (intptr_t) p_nfyinfo;
> 			p_alminib->nfyhdr = notify_handler;
> 		}
> 
> 		acptn = default_acptn(domid);
> 		p_alminib->acvct.acptn1 = acptn;
> 		p_alminib->acvct.acptn2 = acptn;
> 		p_alminib->acvct.acptn3 = p_dominib->acvct.acptn1;
> 		p_alminib->acvct.acptn4 = acptn;
> 
> 		p_almcb->almsta = false;
> 		ercd = ALMID(p_almcb);
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_ACRE_ALM_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_acre_alm */
> 
> /*
>  *  アラーム通知のアクセス許可ベクタの設定
>  */
> #ifdef TOPPERS_sac_alm
> 
> ER
> sac_alm(ID almid, const ACVCT *p_acvct)
> {
> 	ALMCB	*p_almcb;
> 	ALMINIB	*p_alminib;
> 	ER		ercd;
> 
> 	LOG_SAC_ALM_ENTER(almid, p_acvct);
> 	CHECK_TSKCTX_UNL();
> 	CHECK_ID(VALID_ALMID(almid));
> 	CHECK_MACV_READ(p_acvct, ACVCT);
> 	p_almcb = get_almcb(almid);
> 
> 	lock_cpu();
> 	if (p_almcb->p_alminib->almatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_almcb->p_alminib->acvct.acptn3)) {
> 		ercd = E_OACV;
> 	}
> 	else if (ALMID(p_almcb) <= tmax_salmid) {
> 		ercd = E_OBJ;
> 	}
> 	else {
> 		p_alminib = (ALMINIB *)(p_almcb->p_alminib);
> 		p_alminib->acvct = *p_acvct;
> 		ercd = E_OK;
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_SAC_ALM_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_sac_alm */
> 
> /*
>  *  アラーム通知の削除
>  */
> #ifdef TOPPERS_del_alm
> 
> ER
> del_alm(ID almid)
> {
> 	ALMCB			*p_almcb;
> 	ALMINIB			*p_alminib;
> 	const DOMINIB	*p_dominib;
> 	ER				ercd;
> 
> 	LOG_DEL_ALM_ENTER(almid);
> 	CHECK_TSKCTX_UNL();
> 	CHECK_ID(VALID_ALMID(almid));
> 	p_almcb = get_almcb(almid);
> 
> 	lock_cpu();
> 	if (p_almcb->p_alminib->almatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_almcb->p_alminib->acvct.acptn3)) {
> 		ercd = E_OACV;
> 	}
> 	else if (ALMID(p_almcb) <= tmax_salmid) {
> 		ercd = E_OBJ;
> 	}
> 	else {
> 		if (p_almcb->almsta) {
> 			p_almcb->almsta = false;
> 			tmevtb_dequeue(&(p_almcb->tmevtb),
> 									p_almcb->p_alminib->p_tmevt_heap);
> 		}
> 
> 		p_alminib = (ALMINIB *)(p_almcb->p_alminib);
> 		p_dominib = get_atrdominib(p_alminib->almatr);
> 		p_alminib->almatr = TA_NOEXS;
> 		queue_insert_prev(&(p_dominib->p_domcb->free_almcb),
> 									((QUEUE *) &(p_almcb->tmevtb)));
> 		ercd = E_OK;
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_DEL_ALM_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_del_alm */
> 
> /*
135d371
< 	CHECK_ACPTN(p_almcb->p_alminib->acvct.acptn1);
138,139c374,375
< 	if (p_almcb->almsta) {
< 		tmevtb_dequeue(&(p_almcb->tmevtb), p_almcb->p_alminib->p_tmevt_heap);
---
> 	if (p_almcb->p_alminib->almatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
141,142c377,378
< 	else {
< 		p_almcb->almsta = true;
---
> 	else if (VIOLATE_ACPTN(p_almcb->p_alminib->acvct.acptn1)) {
> 		ercd = E_OACV;
144c380,382
< 	tmevtb_enqueue_reltim(&(p_almcb->tmevtb), almtim,
---
> 	else {
> 		if (p_almcb->almsta) {
> 			tmevtb_dequeue(&(p_almcb->tmevtb),
146c384,391
< 	ercd = E_OK;
---
> 		}
> 		else {
> 			p_almcb->almsta = true;
> 		}
> 		tmevtb_enqueue_reltim(&(p_almcb->tmevtb), almtim,
> 									p_almcb->p_alminib->p_tmevt_heap);
> 		ercd = E_OK;
> 	}
171d415
< 	CHECK_ACPTN(p_almcb->p_alminib->acvct.acptn2);
174,176c418,430
< 	if (p_almcb->almsta) {
< 		p_almcb->almsta = false;
< 		tmevtb_dequeue(&(p_almcb->tmevtb), p_almcb->p_alminib->p_tmevt_heap);
---
> 	if (p_almcb->p_alminib->almatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_almcb->p_alminib->acvct.acptn2)) {
> 		ercd = E_OACV;
> 	}
> 	else {
> 		if (p_almcb->almsta) {
> 			p_almcb->almsta = false;
> 			tmevtb_dequeue(&(p_almcb->tmevtb),
> 									p_almcb->p_alminib->p_tmevt_heap);
> 		}
> 		ercd = E_OK;
178d431
< 	ercd = E_OK;
204d456
< 	CHECK_ACPTN(p_almcb->p_alminib->acvct.acptn4);
207,209c459,463
< 	if (p_almcb->almsta) {
< 		pk_ralm->almstat = TALM_STA;
< 		pk_ralm->lefttim = tmevt_lefttim(&(p_almcb->tmevtb));
---
> 	if (p_almcb->p_alminib->almatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_almcb->p_alminib->acvct.acptn4)) {
> 		ercd = E_OACV;
212c466,473
< 		pk_ralm->almstat = TALM_STP;
---
> 		if (p_almcb->almsta) {
> 			pk_ralm->almstat = TALM_STA;
> 			pk_ralm->lefttim = tmevt_lefttim(&(p_almcb->tmevtb));
> 		}
> 		else {
> 			pk_ralm->almstat = TALM_STP;
> 		}
> 		ercd = E_OK;
214d474
< 	ercd = E_OK;
238a499,501
> 	 *
> 	 *  アラーム通知の生成／削除はタスクからしか行えないため，アラーム
> 	 *  通知初期化ブロックをCPUロック解除状態で参照しても問題ない．
diff -r ./kernel/alarm.h extension/dcre/kernel/alarm.h
8c8
<  *  Copyright (C) 2005-2015 by Embedded and Real-Time Systems Laboratory
---
>  *  Copyright (C) 2005-2018 by Embedded and Real-Time Systems Laboratory
40c40
<  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
---
>  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
54a55,58
>  *
>  *  動的生成するアラーム通知については，p_tmevt_heap，almatrはシステム
>  *  初期化時に初期化し，他のフィールドはアラーム通知の生成時に初期化す
>  *  る．
65a70,73
>  *
>  *  動的生成するアラーム通知については，p_alminib，tmevtb.callback，
>  *  tmevtb.argはシステム初期化時に初期化し，他のフィールドはアラーム通
>  *  知の生成時に初期化する．
76a85
> extern const ID	tmax_salmid;
81a91,96
> extern ALMINIB			aalminib_table[];
> 
> /*
>  *  アラーム通知の通知方法の格納エリア（kernel_cfg.c）
>  */
> extern T_NFYINFO	aalm_nfyinfo_table[];
88a104,108
>  *  アラーム通知管理ブロックからアラーム通知IDを取り出すためのマクロ
>  */
> #define	ALMID(p_almcb)	((ID)(((p_almcb) - almcb_table) + TMIN_ALMID))
> 
> /*
diff -r ./kernel/alarm.trb extension/dcre/kernel/alarm.trb
49a50
>     @inibList["T_NFYINFO"] = "aalm_nfyinfo_table"
diff -r ./kernel/allfunc.h extension/dcre/kernel/allfunc.h
38c38
<  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
---
>  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
50a51
> #define TOPPERS_kermem
94a96,101
> #define TOPPERS_memprbwdom
> #define TOPPERS_memprbrwdom
> #define TOPPERS_validmemobj
> #define TOPPERS_validmemobjk
> #define TOPPERS_validmemobjd
> #define TOPPERS_validustack
112a120,122
> #define TOPPERS_acre_tsk
> #define TOPPERS_sac_tsk
> #define TOPPERS_del_tsk
141a152,154
> #define TOPPERS_acre_sem
> #define TOPPERS_sac_sem
> #define TOPPERS_del_sem
150a164,166
> #define TOPPERS_acre_flg
> #define TOPPERS_sac_flg
> #define TOPPERS_del_flg
161a178,180
> #define TOPPERS_acre_dtq
> #define TOPPERS_sac_dtq
> #define TOPPERS_del_dtq
179a199,201
> #define TOPPERS_acre_pdq
> #define TOPPERS_sac_pdq
> #define TOPPERS_del_pdq
194a217,219
> #define TOPPERS_acre_mtx
> #define TOPPERS_sac_mtx
> #define TOPPERS_del_mtx
209a235,237
> #define TOPPERS_acre_mbf
> #define TOPPERS_sac_mbf
> #define TOPPERS_del_mbf
226a255,257
> #define TOPPERS_acre_mpf
> #define TOPPERS_sac_mpf
> #define TOPPERS_del_mpf
240a272,273
> #define TOPPERS_chknfy
> #define TOPPERS_nfyhdr
242a276,278
> #define TOPPERS_acre_cyc
> #define TOPPERS_sac_cyc
> #define TOPPERS_del_cyc
249a286,288
> #define TOPPERS_acre_alm
> #define TOPPERS_sac_alm
> #define TOPPERS_del_alm
279a319,323
> #define TOPPERS_isrini
> #define TOPPERS_isrcal
> #define TOPPERS_acre_isr
> #define TOPPERS_sac_isr
> #define TOPPERS_del_isr
diff -r ./kernel/check.h extension/dcre/kernel/check.h
67a68
> #define VALID_ISRID(isrid)	(TMIN_ISRID <= (isrid) && (isrid) <= tmax_isrid)
72a74,76
> #define VALID_DPRI(dpri)	(TMIN_DPRI <= (dpri) && (dpri) <= TMAX_DPRI)
> #define VALID_ISRPRI(isrpri) \
> 					(TMIN_ISRPRI <= (isrpri) && (isrpri) <= TMAX_ISRPRI)
90a95,162
>  *  アラインしているかの判定
>  */
> #define ALIGNED(val, align)		((((uintptr_t)(val)) & ((align) - 1U)) == 0U)
> 
> #ifdef CHECK_SSTKSZ_ALIGN
> #define SSTKSZ_ALIGN(sstksz)	ALIGNED(sstksz, CHECK_SSTKSZ_ALIGN)
> #else /* CHECK_SSTKSZ_ALIGN */
> #define SSTKSZ_ALIGN(sstksz)	true
> #endif /* CHECK_SSTKSZ_ALIGN */
> 
> #ifdef CHECK_USTKSZ_ALIGN
> #define USTKSZ_ALIGN(ustksz)	ALIGNED(ustksz, CHECK_USTKSZ_ALIGN)
> #else /* CHECK_USTKSZ_ALIGN */
> #define USTKSZ_ALIGN(ustksz)	true
> #endif /* CHECK_USTKSZ_ALIGN */
> 
> #ifdef CHECK_INTPTR_ALIGN
> #define INTPTR_ALIGN(p_var)		ALIGNED(p_var, CHECK_INTPTR_ALIGN)
> #else /* CHECK_INTPTR_ALIGN */
> #define INTPTR_ALIGN(p_var)		true
> #endif /* CHECK_INTPTR_ALIGN */
> 
> #ifdef CHECK_FUNC_ALIGN
> #define FUNC_ALIGN(func)		ALIGNED(func, CHECK_FUNC_ALIGN)
> #else /* CHECK_FUNC_ALIGN */
> #define FUNC_ALIGN(func)		true
> #endif /* CHECK_FUNC_ALIGN */
> 
> #ifdef CHECK_SSTACK_ALIGN
> #define SSTACK_ALIGN(sstack)	ALIGNED(sstack, CHECK_SSTACK_ALIGN)
> #else /* CHECK_SSTACK_ALIGN */
> #define SSTACK_ALIGN(sstack)	true
> #endif /* CHECK_SSTACK_ALIGN */
> 
> #ifdef CHECK_USTACK_ALIGN
> #define USTACK_ALIGN(ustack)	ALIGNED(ustack, CHECK_USTACK_ALIGN)
> #else /* CHECK_USTACK_ALIGN */
> #define USTACK_ALIGN(ustack)	true
> #endif /* CHECK_USTACK_ALIGN */
> 
> #ifdef CHECK_MPF_ALIGN
> #define MPF_ALIGN(mpf)			ALIGNED(mpf, CHECK_MPF_ALIGN)
> #else /* CHECK_MPF_ALIGN */
> #define MPF_ALIGN(mpf)			true
> #endif /* CHECK_MPF_ALIGN */
> 
> #ifdef CHECK_MB_ALIGN
> #define MB_ALIGN(mb)			ALIGNED(mb, CHECK_MB_ALIGN)
> #else /* CHECK_MB_ALIGN */
> #define MB_ALIGN(mb)			true
> #endif /* CHECK_MB_ALIGN */
> 
> /*
>  *  NULLでないことの判定
>  */
> #ifdef CHECK_INTPTR_NONNULL
> #define INTPTR_NONNULL(p_var)	((p_var) != NULL)
> #else /* CHECK_INTPTR_NONNULL */
> #define INTPTR_NONNULL(p_var)	true
> #endif /* CHECK_INTPTR_NONNULL */
> 
> #ifdef CHECK_FUNC_NONNULL
> #define FUNC_NONNULL(func)		((func) != NULL)
> #else /* CHECK_FUNC_NONNULL */
> #define FUNC_NONNULL(func)		true
> #endif /* CHECK_FUNC_NONNULL */
> 
> /*
150a223,242
>  *  属性が無効なビットが立っていないかのチェック（E_RSATR）
>  */
> #define CHECK_VALIDATR(atr, valid_atr) do {					\
> 	if (((atr) & ~(valid_atr)) != 0U) {						\
> 		ercd = E_RSATR;										\
> 		goto error_exit;									\
> 	}														\
> } while (false)
> 
> /*
>  *  その他の予約属性のチェック（E_RSATR）
>  */
> #define CHECK_RSATR(exp) do {								\
> 	if (!(exp)) {											\
> 		ercd = E_RSATR;										\
> 		goto error_exit;									\
> 	}														\
> } while (false)
> 
> /*
170a263,272
>  *  未サポート機能エラーのチェック（E_NOSPT）
>  */
> #define CHECK_NOSPT(exp) do {								\
> 	if (!(exp)) {											\
> 		ercd = E_NOSPT;										\
> 		goto error_exit;									\
> 	}														\
> } while (false)
> 
> /*
200a303,312
>  *  その他のオブジェクトアクセス違反のチェック（E_OACV）
>  */
> #define CHECK_OACV(exp) do {								\
> 	if (!(exp)) {											\
> 		ercd = E_OACV;										\
> 		goto error_exit;									\
> 	}														\
> } while (false)
> 
> /*
230a343,352
> /*
>  *  その他のメモリアクセス違反のチェック（E_MACV）
>  */
> #define CHECK_MACV(exp) do {								\
> 	if (!(exp)) {											\
> 		ercd = E_MACV;										\
> 		goto error_exit;									\
> 	}														\
> } while (false)
> 
diff -r ./kernel/cyclic.c extension/dcre/kernel/cyclic.c
40c40
<  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
---
>  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
48a49
> #include "domain.h"
61a63,86
> #ifndef LOG_ACRE_CYC_ENTER
> #define LOG_ACRE_CYC_ENTER(pk_ccyc)
> #endif /* LOG_ACRE_CYC_ENTER */
> 
> #ifndef LOG_ACRE_CYC_LEAVE
> #define LOG_ACRE_CYC_LEAVE(ercd)
> #endif /* LOG_ACRE_CYC_LEAVE */
> 
> #ifndef LOG_SAC_CYC_ENTER
> #define LOG_SAC_CYC_ENTER(cycid, p_acvct)
> #endif /* LOG_SAC_CYC_ENTER */
> 
> #ifndef LOG_SAC_CYC_LEAVE
> #define LOG_SAC_CYC_LEAVE(ercd)
> #endif /* LOG_SAC_CYC_LEAVE */
> 
> #ifndef LOG_DEL_CYC_ENTER
> #define LOG_DEL_CYC_ENTER(cycid)
> #endif /* LOG_DEL_CYC_ENTER */
> 
> #ifndef LOG_DEL_CYC_LEAVE
> #define LOG_DEL_CYC_LEAVE(ercd)
> #endif /* LOG_DEL_CYC_LEAVE */
> 
89a115
> #define tnum_scyc	((uint_t)(tmax_scycid - TMIN_CYCID + 1))
98a125,128
>  *
>  *  未使用の周期通知管理ブロックのキューを作るために，周期通知管理ブロッ
>  *  クの先頭にはキューにつなぐための領域がないため，タイムイベントブロッ
>  *  ク（tmevtb）の領域を用いる．
101a132,143
> static void
> initialize_cyccb(CYCCB *p_cyccb, CYCINIB *p_cycinib, const DOMINIB *p_dominib)
> {
> 	p_cycinib->p_tmevt_heap = p_dominib->p_tmevt_heap;
> 	p_cycinib->cycatr = TA_NOEXS;
> 	p_cyccb->p_cycinib = (const CYCINIB *) p_cycinib;
> 	p_cyccb->tmevtb.callback = (CBACK) call_cyclic;
> 	p_cyccb->tmevtb.arg = (void *) p_cyccb;
> 	queue_insert_prev(&(p_dominib->p_domcb->free_cyccb),
> 								((QUEUE *) &(p_cyccb->tmevtb)));
> }
> 
105,106c147,150
< 	uint_t	i;
< 	CYCCB	*p_cyccb;
---
> 	uint_t			i, j, k;
> 	ID				domid;
> 	CYCCB			*p_cyccb;
> 	const DOMINIB	*p_dominib;
108c152
< 	for (i = 0; i < tnum_cyc; i++) {
---
> 	for (i = 0; i < tnum_scyc; i++) {
126a171,184
> 
> 	queue_initialize(&(dominib_kernel.p_domcb->free_cyccb));
> 	for (j = 0; j < dominib_kernel.tnum_acycid; i++, j++) {
> 		initialize_cyccb(&(cyccb_table[i]), &(acycinib_table[j]),
> 													&dominib_kernel);
> 	}
> 	for (domid = TMIN_DOMID; domid <= tmax_domid; domid++) {
> 		p_dominib = get_dominib(domid);
> 		queue_initialize(&(p_dominib->p_domcb->free_cyccb));
> 		for (k = 0; k < p_dominib->tnum_acycid; i++, j++, k++) {
> 			initialize_cyccb(&(cyccb_table[i]), &(acycinib_table[j]),
> 															p_dominib);
> 		}
> 	}
131a190,383
>  *  周期通知の生成
>  */
> #ifdef TOPPERS_acre_cyc
> 
> ER_UINT
> acre_cyc(const T_CCYC *pk_ccyc)
> {
> 	CYCCB			*p_cyccb;
> 	CYCINIB			*p_cycinib;
> 	ATR				cycatr;
> 	RELTIM			cyctim, cycphs;
> 	ID				domid;
> 	const DOMINIB	*p_dominib;
> 	T_NFYINFO		*p_nfyinfo;
> 	ACPTN			acptn;
> 	ER				ercd;
> 
> 	LOG_ACRE_CYC_ENTER(pk_ccyc);
> 	CHECK_TSKCTX_UNL();
> 	CHECK_MACV_READ(pk_ccyc, T_CCYC);
> 
> 	cycatr = pk_ccyc->cycatr;
> 	cyctim = pk_ccyc->cyctim;
> 	cycphs = pk_ccyc->cycphs;
> 
> 	CHECK_VALIDATR(cycatr, TA_STA|TA_DOMMASK);
> 	CHECK_PAR(0 < cyctim && cyctim <= TMAX_RELTIM);
> 	CHECK_PAR(0 <= cycphs && cycphs <= TMAX_RELTIM);
> 	domid = get_atrdomid(cycatr);
> 	if (domid == TDOM_SELF) {
> 		if (rundom == TACP_KERNEL) {
> 			domid = TDOM_KERNEL;
> 		}
> 		else {
> 			domid = p_runtsk->p_tinib->domid;
> 		}
> 		cycatr = set_atrdomid(cycatr, domid);
> 	}
> 	if (domid == TDOM_KERNEL) {
> 		p_dominib = &dominib_kernel;
> 	}
> 	else {
> 		CHECK_RSATR(VALID_DOMID(domid));
> 		p_dominib = get_dominib(domid);
> 	}
> 	ercd = check_nfyinfo(&(pk_ccyc->nfyinfo), p_dominib->domptn);
> 	if (ercd != E_OK) {
> 		goto error_exit;
> 	}
> 	CHECK_ACPTN(p_dominib->acvct.acptn1);
> 	
> 	lock_cpu();
> 	if (tnum_cyc == 0 || queue_empty(&(p_dominib->p_domcb->free_cyccb))) {
> 		ercd = E_NOID;
> 	}
> 	else {
> 		p_cyccb = (CYCCB *)
> 			(((char *) queue_delete_next(&(p_dominib->p_domcb->free_cyccb)))
> 													- offsetof(CYCCB, tmevtb));
> 		p_cycinib = (CYCINIB *)(p_cyccb->p_cycinib);
> 		p_cycinib->cycatr = cycatr;
> 		if (pk_ccyc->nfyinfo.nfymode == TNFY_HANDLER) {
> 			p_cycinib->exinf = pk_ccyc->nfyinfo.nfy.handler.exinf;
> 			p_cycinib->nfyhdr = (NFYHDR)(pk_ccyc->nfyinfo.nfy.handler.tmehdr);
> 		}
> 		else {
> 			p_nfyinfo = &acyc_nfyinfo_table[p_cycinib - acycinib_table];
> 			*p_nfyinfo = pk_ccyc->nfyinfo;
> 			p_cycinib->exinf = (intptr_t) p_nfyinfo;
> 			p_cycinib->nfyhdr = notify_handler;
> 		}
> 		p_cycinib->cyctim = cyctim;
> 		p_cycinib->cycphs = cycphs;
> 
> 		acptn = default_acptn(domid);
> 		p_cycinib->acvct.acptn1 = acptn;
> 		p_cycinib->acvct.acptn2 = acptn;
> 		p_cycinib->acvct.acptn3 = p_dominib->acvct.acptn1;
> 		p_cycinib->acvct.acptn4 = acptn;
> 
> 		if ((p_cyccb->p_cycinib->cycatr & TA_STA) != 0U) {
> 			p_cyccb->cycsta = true;
> 			tmevtb_enqueue_reltim(&(p_cyccb->tmevtb),
> 									p_cyccb->p_cycinib->cycphs,
> 									p_cyccb->p_cycinib->p_tmevt_heap);
> 		}
> 		else {
> 			p_cyccb->cycsta = false;
> 		}
> 		ercd = CYCID(p_cyccb);
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_ACRE_CYC_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_acre_cyc */
> 
> /*
>  *  周期通知のアクセス許可ベクタの設定
>  */
> #ifdef TOPPERS_sac_cyc
> 
> ER
> sac_cyc(ID cycid, const ACVCT *p_acvct)
> {
> 	CYCCB	*p_cyccb;
> 	CYCINIB	*p_cycinib;
> 	ER		ercd;
> 
> 	LOG_SAC_CYC_ENTER(cycid, p_acvct);
> 	CHECK_TSKCTX_UNL();
> 	CHECK_ID(VALID_CYCID(cycid));
> 	CHECK_MACV_READ(p_acvct, ACVCT);
> 	p_cyccb = get_cyccb(cycid);
> 
> 	lock_cpu();
> 	if (p_cyccb->p_cycinib->cycatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_cyccb->p_cycinib->acvct.acptn3)) {
> 		ercd = E_OACV;
> 	}
> 	else if (CYCID(p_cyccb) <= tmax_scycid) {
> 		ercd = E_OBJ;
> 	}
> 	else {
> 		p_cycinib = (CYCINIB *)(p_cyccb->p_cycinib);
> 		p_cycinib->acvct = *p_acvct;
> 		ercd = E_OK;
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_SAC_CYC_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_sac_cyc */
> 
> /*
>  *  周期通知の削除
>  */
> #ifdef TOPPERS_del_cyc
> 
> ER
> del_cyc(ID cycid)
> {
> 	CYCCB			*p_cyccb;
> 	CYCINIB			*p_cycinib;
> 	const DOMINIB	*p_dominib;
> 	ER				ercd;
> 
> 	LOG_DEL_CYC_ENTER(cycid);
> 	CHECK_TSKCTX_UNL();
> 	CHECK_ID(VALID_CYCID(cycid));
> 	p_cyccb = get_cyccb(cycid);
> 
> 	lock_cpu();
> 	if (p_cyccb->p_cycinib->cycatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_cyccb->p_cycinib->acvct.acptn3)) {
> 		ercd = E_OACV;
> 	}
> 	else if (CYCID(p_cyccb) <= tmax_scycid) {
> 		ercd = E_OBJ;
> 	}
> 	else {
> 		if (p_cyccb->cycsta) {
> 			p_cyccb->cycsta = false;
> 			tmevtb_dequeue(&(p_cyccb->tmevtb),
> 									p_cyccb->p_cycinib->p_tmevt_heap);
> 		}
> 
> 		p_cycinib = (CYCINIB *)(p_cyccb->p_cycinib);
> 		p_dominib = get_atrdominib(p_cycinib->cycatr);
> 		p_cycinib->cycatr = TA_NOEXS;
> 		queue_insert_prev(&(p_dominib->p_domcb->free_cyccb),
> 									((QUEUE *) &(p_cyccb->tmevtb)));
> 		ercd = E_OK;
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_DEL_CYC_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_del_cyc */
> 
> /*
146d397
< 	CHECK_ACPTN(p_cyccb->p_cycinib->acvct.acptn1);
149,150c400,404
< 	if (p_cyccb->cycsta) {
< 		tmevtb_dequeue(&(p_cyccb->tmevtb), p_cyccb->p_cycinib->p_tmevt_heap);
---
> 	if (p_cyccb->p_cycinib->cycatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_cyccb->p_cycinib->acvct.acptn1)) {
> 		ercd = E_OACV;
153c407,413
< 		p_cyccb->cycsta = true;
---
> 		if (p_cyccb->cycsta) {
> 			tmevtb_dequeue(&(p_cyccb->tmevtb),
> 									p_cyccb->p_cycinib->p_tmevt_heap);
> 		}
> 		else {
> 			p_cyccb->cycsta = true;
> 		}
185d444
< 	CHECK_ACPTN(p_cyccb->p_cycinib->acvct.acptn2);
188,190c447,459
< 	if (p_cyccb->cycsta) {
< 		p_cyccb->cycsta = false;
< 		tmevtb_dequeue(&(p_cyccb->tmevtb), p_cyccb->p_cycinib->p_tmevt_heap);
---
> 	if (p_cyccb->p_cycinib->cycatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_cyccb->p_cycinib->acvct.acptn2)) {
> 		ercd = E_OACV;
> 	}
> 	else {
> 		if (p_cyccb->cycsta) {
> 			p_cyccb->cycsta = false;
> 			tmevtb_dequeue(&(p_cyccb->tmevtb),
> 									p_cyccb->p_cycinib->p_tmevt_heap);
> 		}
> 		ercd = E_OK;
192d460
< 	ercd = E_OK;
218d485
< 	CHECK_ACPTN(p_cyccb->p_cycinib->acvct.acptn4);
221,223c488,492
< 	if (p_cyccb->cycsta) {
< 		pk_rcyc->cycstat = TCYC_STA;
< 		pk_rcyc->lefttim = tmevt_lefttim(&(p_cyccb->tmevtb));
---
> 	if (p_cyccb->p_cycinib->cycatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_cyccb->p_cycinib->acvct.acptn4)) {
> 		ercd = E_OACV;
226c495,502
< 		pk_rcyc->cycstat = TCYC_STP;
---
> 		if (p_cyccb->cycsta) {
> 			pk_rcyc->cycstat = TCYC_STA;
> 			pk_rcyc->lefttim = tmevt_lefttim(&(p_cyccb->tmevtb));
> 		}
> 		else {
> 			pk_rcyc->cycstat = TCYC_STP;
> 		}
> 		ercd = E_OK;
228d503
< 	ercd = E_OK;
257a533,535
> 	 *
> 	 *  周期通知の生成／削除はタスクからしか行えないため，周期通知初期
> 	 *  化ブロックをCPUロック解除状態で参照しても問題ない．
diff -r ./kernel/cyclic.h extension/dcre/kernel/cyclic.h
8c8
<  *  Copyright (C) 2005-2015 by Embedded and Real-Time Systems Laboratory
---
>  *  Copyright (C) 2005-2018 by Embedded and Real-Time Systems Laboratory
40c40
<  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
---
>  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
54a55,57
>  *
>  *  動的生成する周期通知については，p_tmevt_heap，cycatrはシステム初期
>  *  化時に初期化し，他のフィールドは周期通知の生成時に初期化する．
70a74,77
>  *
>  *  動的生成する周期通知については，p_cycinib，tmevtb.callback，
>  *  tmevtb.argはシステム初期化時に初期化し，他のフィールドは周期通知の
>  *  生成時に初期化する．
81a89
> extern const ID	tmax_scycid;
86a95,100
> extern CYCINIB			acycinib_table[];
> 
> /*
>  *  周期通知の通知方法の格納エリア（kernel_cfg.c）
>  */
> extern T_NFYINFO	acyc_nfyinfo_table[];
93a108,112
>  *  周期通知管理ブロックから周期通知IDを取り出すためのマクロ
>  */
> #define	CYCID(p_cyccb)	((ID)(((p_cyccb) - cyccb_table) + TMIN_CYCID))
> 
> /*
diff -r ./kernel/cyclic.trb extension/dcre/kernel/cyclic.trb
49a50
>     @inibList["T_NFYINFO"] = "acyc_nfyinfo_table"
diff -r ./kernel/dataqueue.c extension/dcre/kernel/dataqueue.c
8c8
<  *  Copyright (C) 2005-2018 by Embedded and Real-Time Systems Laboratory
---
>  *  Copyright (C) 2005-2019 by Embedded and Real-Time Systems Laboratory
40c40
<  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
---
>  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
48a49
> #include "domain.h"
55a57,80
> #ifndef LOG_ACRE_DTQ_ENTER
> #define LOG_ACRE_DTQ_ENTER(pk_cdtq)
> #endif /* LOG_ACRE_DTQ_ENTER */
> 
> #ifndef LOG_ACRE_DTQ_LEAVE
> #define LOG_ACRE_DTQ_LEAVE(ercd)
> #endif /* LOG_ACRE_DTQ_LEAVE */
> 
> #ifndef LOG_SAC_DTQ_ENTER
> #define LOG_SAC_DTQ_ENTER(dtqid, p_acvct)
> #endif /* LOG_SAC_DTQ_ENTER */
> 
> #ifndef LOG_SAC_DTQ_LEAVE
> #define LOG_SAC_DTQ_LEAVE(ercd)
> #endif /* LOG_SAC_DTQ_LEAVE */
> 
> #ifndef LOG_DEL_DTQ_ENTER
> #define LOG_DEL_DTQ_ENTER(dtqid)
> #endif /* LOG_DEL_DTQ_ENTER */
> 
> #ifndef LOG_DEL_DTQ_LEAVE
> #define LOG_DEL_DTQ_LEAVE(ercd)
> #endif /* LOG_DEL_DTQ_LEAVE */
> 
128,139c153
< /*
<  *  データキューの数
<  */
< #define tnum_dtq	((uint_t)(tmax_dtqid - TMIN_DTQID + 1))
< 
< /*
<  *  データキューIDからデータキュー管理ブロックを取り出すためのマクロ
<  */
< #define INDEX_DTQ(dtqid)	((uint_t)((dtqid) - TMIN_DTQID))
< #define get_dtqcb(dtqid)	(&(dtqcb_table[INDEX_DTQ(dtqid)]))
< 
< /*
---
> /* 
143a158,166
> static void
> initialize_dtqcb(DTQCB *p_dtqcb, DTQINIB *p_dtqinib, const DOMINIB *p_dominib)
> {
> 	p_dtqinib->dtqatr = TA_NOEXS;
> 	p_dtqcb->p_dtqinib = (const DTQINIB *) p_dtqinib;
> 	queue_insert_prev(&(p_dominib->p_domcb->free_dtqcb),
> 										&(p_dtqcb->swait_queue));
> }
> 
147,148c170,173
< 	uint_t	i;
< 	DTQCB	*p_dtqcb;
---
> 	uint_t			i, j, k;
> 	ID				domid;
> 	DTQCB			*p_dtqcb;
> 	const DOMINIB	*p_dominib;
150c175
< 	for (i = 0; i < tnum_dtq; i++) {
---
> 	for (i = 0; i < tnum_sdtq; i++) {
158a184,201
> 
> 	queue_initialize(&(dominib_kernel.p_domcb->free_dtqcb));
> 	for (j = 0; j < dominib_kernel.tnum_adtqid; i++, j++) {
> 		initialize_dtqcb(&(dtqcb_table[i]), &(adtqinib_table[j]),
> 													&dominib_kernel);
> 	}
> 	for (domid = TMIN_DOMID; domid <= tmax_domid; domid++) {
> 		p_dominib = get_dominib(domid);
> 		queue_initialize(&(p_dominib->p_domcb->free_dtqcb));
> 		for (k = 0; k < p_dominib->tnum_adtqid; i++, j++, k++) {
> 			initialize_dtqcb(&(dtqcb_table[i]), &(adtqinib_table[j]),
> 															p_dominib);
> 		}
> 	}
> 	for (k = 0; k < dominib_none.tnum_adtqid; i++, j++, k++) {
> 		initialize_dtqcb(&(dtqcb_table[i]), &(adtqinib_table[j]),
> 													&dominib_none);
> 	}
305a349,541
>  *  データキューの生成
>  */
> #ifdef TOPPERS_acre_dtq
> 
> ER_UINT
> acre_dtq(const T_CDTQ *pk_cdtq)
> {
> 	DTQCB			*p_dtqcb;
> 	DTQINIB			*p_dtqinib;
> 	ATR				dtqatr;
> 	uint_t			dtqcnt;
> 	DTQMB			*p_dtqmb;
> 	ID				domid;
> 	const DOMINIB	*p_dominib;
> 	ACPTN			acptn;
> 	ER				ercd;
> 
> 	LOG_ACRE_DTQ_ENTER(pk_cdtq);
> 	CHECK_TSKCTX_UNL();
> 	CHECK_MACV_READ(pk_cdtq, T_CDTQ);
> 
> 	dtqatr = pk_cdtq->dtqatr;
> 	dtqcnt = pk_cdtq->dtqcnt;
> 	p_dtqmb = pk_cdtq->dtqmb;
> 
> 	CHECK_VALIDATR(dtqatr, TA_TPRI|TA_DOMMASK);
> 	if (p_dtqmb != NULL) {
> 		CHECK_PAR(MB_ALIGN(p_dtqmb));
> 		CHECK_OBJ(valid_memobj_kernel(p_dtqmb, sizeof(DTQMB) * dtqcnt));
> 	}
> 	domid = get_atrdomid(dtqatr);
> 	if (domid == TDOM_SELF) {
> 		if (rundom == TACP_KERNEL) {
> 			domid = TDOM_KERNEL;
> 		}
> 		else {
> 			domid = p_runtsk->p_tinib->domid;
> 		}
> 		dtqatr = set_atrdomid(dtqatr, domid);
> 	}
> 	switch (domid) {
> 	case TDOM_KERNEL:
> 		p_dominib = &dominib_kernel;
> 		break;
> 	case TDOM_NONE:
> 		p_dominib = &dominib_none;
> 		break;
> 	default:
> 		CHECK_RSATR(VALID_DOMID(domid));
> 		p_dominib = get_dominib(domid);
> 		break;
> 	}
> 	CHECK_ACPTN(p_dominib->acvct.acptn1);
> 
> 	lock_cpu();
> 	if (tnum_dtq == 0 || queue_empty(&(p_dominib->p_domcb->free_dtqcb))) {
> 		ercd = E_NOID;
> 	}
> 	else {
> 		if (dtqcnt != 0 && p_dtqmb == NULL) {
> 			p_dtqmb = malloc_mpk(sizeof(DTQMB) * dtqcnt, p_dominib);
> 			dtqatr |= TA_MBALLOC;
> 		}
> 		if (dtqcnt != 0 && p_dtqmb == NULL) {
> 			ercd = E_NOMEM;
> 		}
> 		else {
> 			p_dtqcb = (DTQCB *)
> 						queue_delete_next(&(p_dominib->p_domcb->free_dtqcb));
> 			p_dtqinib = (DTQINIB *)(p_dtqcb->p_dtqinib);
> 			p_dtqinib->dtqatr = dtqatr;
> 			p_dtqinib->dtqcnt = dtqcnt;
> 			p_dtqinib->p_dtqmb = p_dtqmb;
> 
> 			acptn = default_acptn(domid);
> 			p_dtqinib->acvct.acptn1 = acptn;
> 			p_dtqinib->acvct.acptn2 = acptn;
> 			p_dtqinib->acvct.acptn3 = p_dominib->acvct.acptn1;
> 			p_dtqinib->acvct.acptn4 = acptn;
> 
> 			queue_initialize(&(p_dtqcb->swait_queue));
> 			queue_initialize(&(p_dtqcb->rwait_queue));
> 			p_dtqcb->count = 0U;
> 			p_dtqcb->head = 0U;
> 			p_dtqcb->tail = 0U;
> 			ercd = DTQID(p_dtqcb);
> 		}
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_ACRE_DTQ_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_acre_dtq */
> 
> /*
>  *  データキューのアクセス許可ベクタの設定
>  */
> #ifdef TOPPERS_sac_dtq
> 
> ER
> sac_dtq(ID dtqid, const ACVCT *p_acvct)
> {
> 	DTQCB	*p_dtqcb;
> 	DTQINIB	*p_dtqinib;
> 	ER		ercd;
> 
> 	LOG_SAC_DTQ_ENTER(dtqid, p_acvct);
> 	CHECK_TSKCTX_UNL();
> 	CHECK_ID(VALID_DTQID(dtqid));
> 	CHECK_MACV_READ(p_acvct, ACVCT);
> 	p_dtqcb = get_dtqcb(dtqid);
> 
> 	lock_cpu();
> 	if (p_dtqcb->p_dtqinib->dtqatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_dtqcb->p_dtqinib->acvct.acptn3)) {
> 		ercd = E_OACV;
> 	}
> 	else if (DTQID(p_dtqcb) <= tmax_sdtqid) {
> 		ercd = E_OBJ;
> 	}
> 	else {
> 		p_dtqinib = (DTQINIB *)(p_dtqcb->p_dtqinib);
> 		p_dtqinib->acvct = *p_acvct;
> 		ercd = E_OK;
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_SAC_DTQ_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_sac_dtq */
> 
> /*
>  *  データキューの削除
>  */
> #ifdef TOPPERS_del_dtq
> 
> ER
> del_dtq(ID dtqid)
> {
> 	DTQCB			*p_dtqcb;
> 	DTQINIB			*p_dtqinib;
> 	const DOMINIB	*p_dominib;
> 	ER				ercd;
> 
> 	LOG_DEL_DTQ_ENTER(dtqid);
> 	CHECK_TSKCTX_UNL();
> 	CHECK_ID(VALID_DTQID(dtqid));
> 	p_dtqcb = get_dtqcb(dtqid);
> 
> 	lock_cpu();
> 	if (p_dtqcb->p_dtqinib->dtqatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_dtqcb->p_dtqinib->acvct.acptn3)) {
> 		ercd = E_OACV;
> 	}
> 	else if (DTQID(p_dtqcb) <= tmax_sdtqid) {
> 		ercd = E_OBJ;
> 	}
> 	else {
> 		init_wait_queue(&(p_dtqcb->swait_queue));
> 		init_wait_queue(&(p_dtqcb->rwait_queue));
> 		p_dtqinib = (DTQINIB *)(p_dtqcb->p_dtqinib);
> 		p_dominib = get_atrdominib(p_dtqinib->dtqatr);
> 		if ((p_dtqinib->dtqatr & TA_MBALLOC) != 0U) {
> 			free_mpk(p_dtqinib->p_dtqmb, p_dominib);
> 		}
> 		p_dtqinib->dtqatr = TA_NOEXS;
> 		queue_insert_prev(&(p_dominib->p_domcb->free_dtqcb),
> 										&(p_dtqcb->swait_queue));
> 		if (p_runtsk != p_schedtsk) {
> 			dispatch();
> 		}
> 		ercd = E_OK;
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_DEL_DTQ_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_del_dtq */
> 
> /*
321d556
< 	CHECK_ACPTN(p_dtqcb->p_dtqinib->acvct.acptn1);
324c559,565
< 	if (p_runtsk->raster) {
---
> 	if (p_dtqcb->p_dtqinib->dtqatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_dtqcb->p_dtqinib->acvct.acptn1)) {
> 		ercd = E_OACV;
> 	}
> 	else if (p_runtsk->raster) {
364d604
< 	CHECK_ACPTN(p_dtqcb->p_dtqinib->acvct.acptn1);
367c607,613
< 	if (send_data(p_dtqcb, data)) {
---
> 	if (p_dtqcb->p_dtqinib->dtqatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_dtqcb->p_dtqinib->acvct.acptn1)) {
> 		ercd = E_OACV;
> 	}
> 	else if (send_data(p_dtqcb, data)) {
408d653
< 	CHECK_ACPTN(p_dtqcb->p_dtqinib->acvct.acptn1);
411c656,662
< 	if (p_runtsk->raster) {
---
> 	if (p_dtqcb->p_dtqinib->dtqatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_dtqcb->p_dtqinib->acvct.acptn1)) {
> 		ercd = E_OACV;
> 	}
> 	else if (p_runtsk->raster) {
454,455d704
< 	CHECK_ACPTN(p_dtqcb->p_dtqinib->acvct.acptn1);
< 	CHECK_ILUSE(p_dtqcb->p_dtqinib->dtqcnt > 0U);
458,464c707,724
< 	force_send_data(p_dtqcb, data);
< 	if (p_runtsk != p_schedtsk) {
< 		if (!sense_context()) {
< 			dispatch();
< 		}
< 		else {
< 			request_dispatch_retint();
---
> 	if (p_dtqcb->p_dtqinib->dtqatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_dtqcb->p_dtqinib->acvct.acptn1)) {
> 		ercd = E_OACV;
> 	}
> 	else if (!(p_dtqcb->p_dtqinib->dtqcnt > 0U)) {
> 		ercd = E_ILUSE;
> 	}
> 	else {
> 		force_send_data(p_dtqcb, data);
> 		if (p_runtsk != p_schedtsk) {
> 			if (!sense_context()) {
> 				dispatch();
> 			}
> 			else {
> 				request_dispatch_retint();
> 			}
465a726
> 		ercd = E_OK;
467d727
< 	ercd = E_OK;
494d753
< 	CHECK_ACPTN(p_dtqcb->p_dtqinib->acvct.acptn2);
497c756,762
< 	if (p_runtsk->raster) {
---
> 	if (p_dtqcb->p_dtqinib->dtqatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_dtqcb->p_dtqinib->acvct.acptn2)) {
> 		ercd = E_OACV;
> 	}
> 	else if (p_runtsk->raster) {
542d806
< 	CHECK_ACPTN(p_dtqcb->p_dtqinib->acvct.acptn2);
545c809,815
< 	if (receive_data(p_dtqcb, p_data)) {
---
> 	if (p_dtqcb->p_dtqinib->dtqatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_dtqcb->p_dtqinib->acvct.acptn2)) {
> 		ercd = E_OACV;
> 	}
> 	else if (receive_data(p_dtqcb, p_data)) {
582d851
< 	CHECK_ACPTN(p_dtqcb->p_dtqinib->acvct.acptn2);
585c854,860
< 	if (p_runtsk->raster) {
---
> 	if (p_dtqcb->p_dtqinib->dtqatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_dtqcb->p_dtqinib->acvct.acptn2)) {
> 		ercd = E_OACV;
> 	}
> 	else if (p_runtsk->raster) {
632d906
< 	CHECK_ACPTN(p_dtqcb->p_dtqinib->acvct.acptn3);
635,641c909,924
< 	init_wait_queue(&(p_dtqcb->swait_queue));
< 	init_wait_queue(&(p_dtqcb->rwait_queue));
< 	p_dtqcb->count = 0U;
< 	p_dtqcb->head = 0U;
< 	p_dtqcb->tail = 0U;
< 	if (p_runtsk != p_schedtsk) {
< 		dispatch();
---
> 	if (p_dtqcb->p_dtqinib->dtqatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_dtqcb->p_dtqinib->acvct.acptn3)) {
> 		ercd = E_OACV;
> 	}
> 	else {
> 		init_wait_queue(&(p_dtqcb->swait_queue));
> 		init_wait_queue(&(p_dtqcb->rwait_queue));
> 		p_dtqcb->count = 0U;
> 		p_dtqcb->head = 0U;
> 		p_dtqcb->tail = 0U;
> 		if (p_runtsk != p_schedtsk) {
> 			dispatch();
> 		}
> 		ercd = E_OK;
643d925
< 	ercd = E_OK;
669d950
< 	CHECK_ACPTN(p_dtqcb->p_dtqinib->acvct.acptn4);
672,675c953,964
< 	pk_rdtq->stskid = wait_tskid(&(p_dtqcb->swait_queue));
< 	pk_rdtq->rtskid = wait_tskid(&(p_dtqcb->rwait_queue));
< 	pk_rdtq->sdtqcnt = p_dtqcb->count;
< 	ercd = E_OK;
---
> 	if (p_dtqcb->p_dtqinib->dtqatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_dtqcb->p_dtqinib->acvct.acptn4)) {
> 		ercd = E_OACV;
> 	}
> 	else {
> 		pk_rdtq->stskid = wait_tskid(&(p_dtqcb->swait_queue));
> 		pk_rdtq->rtskid = wait_tskid(&(p_dtqcb->rwait_queue));
> 		pk_rdtq->sdtqcnt = p_dtqcb->count;
> 		ercd = E_OK;
> 	}
diff -r ./kernel/dataqueue.h extension/dcre/kernel/dataqueue.h
8c8
<  *  Copyright (C) 2005-2015 by Embedded and Real-Time Systems Laboratory
---
>  *  Copyright (C) 2005-2018 by Embedded and Real-Time Systems Laboratory
40c40
<  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
---
>  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
113a114
> extern const ID	tmax_sdtqid;
118a120
> extern DTQINIB			adtqinib_table[];
125a128,139
>  *  データキューの数
>  */
> #define tnum_dtq	((uint_t)(tmax_dtqid - TMIN_DTQID + 1))
> #define tnum_sdtq	((uint_t)(tmax_sdtqid - TMIN_DTQID + 1))
> 
> /*
>  *  データキューIDからデータキュー管理ブロックを取り出すためのマクロ
>  */
> #define INDEX_DTQ(dtqid)	((uint_t)((dtqid) - TMIN_DTQID))
> #define get_dtqcb(dtqid)	(&(dtqcb_table[INDEX_DTQ(dtqid)]))
> 
> /*
Only in ./kernel: dataqueue.trb
Only in ./kernel: domain.c
diff -r ./kernel/domain.h extension/dcre/kernel/domain.h
59,63d58
<  *  保護ドメイン初期化ブロックの型の前方参照
<  */
< typedef struct domain_initialization_block DOMINIB;
< 
< /*
246a242,262
>  *  保護ドメイン管理ブロック
>  *
>  *  保護ドメイン管理ブロックを参照することが少ないため，他の管理ブロッ
>  *  クと初期化ブロックの関係とは逆に，保護ドメイン初期化ブロックに保護
>  *  ドメイン管理ブロックへのポインタを持たせている．
>  */
> typedef struct domain_control_block {
> 	QUEUE		free_tcb;		/* 未使用のTCB */
> 	QUEUE		free_semcb;		/* 未使用のセマフォ管理ブロック */
> 	QUEUE		free_flgcb;		/* 未使用のイベントフラグ管理ブロック */
> 	QUEUE		free_dtqcb;		/* 未使用のデータキュー管理ブロック */
> 	QUEUE		free_pdqcb;		/* 未使用の優先度データキュー管理ブロック */
> 	QUEUE		free_mtxcb;		/* 未使用のミューテックス管理ブロック */
> 	QUEUE		free_mbfcb;		/* 未使用のメッセージバッファ管理ブロック */
> 	QUEUE		free_mpfcb;		/* 未使用の固定長メモリプール管理ブロック */
> 	QUEUE		free_cyccb;		/* 未使用の周期通知管理ブロック */
> 	QUEUE		free_almcb;		/* 未使用のアラーム通知管理ブロック */
> 	bool_t		mpk_valid;		/* カーネルメモリプール領域有効フラグ */
> } DOMCB;
> 
> /*
256a273,286
> 
> 	DOMCB		*p_domcb;		/* 管理ブロックへのポインタ */
> 	uint_t		tnum_atskid;	/* 割付け可能なタスクIDの数 */
> 	uint_t		tnum_asemid;	/* 割付け可能なセマフォIDの数 */
> 	uint_t		tnum_aflgid;	/* 割付け可能なイベントフラグIDの数 */
> 	uint_t		tnum_adtqid;	/* 割付け可能なデータキューIDの数 */
> 	uint_t		tnum_apdqid;	/* 割付け可能な優先度データキューIDの数 */
> 	uint_t		tnum_amtxid;	/* 割付け可能なミューテックスIDの数 */
> 	uint_t		tnum_ambfid;	/* 割付け可能なメッセージバッファIDの数 */
> 	uint_t		tnum_ampfid;	/* 割付け可能な固定長メモリプールIDの数 */
> 	uint_t		tnum_acycid;	/* 割付け可能な周期通知IDの数 */
> 	uint_t		tnum_aalmid;	/* 割付け可能なアラーム通知IDの数 */
> 	size_t		mpksz;			/* カーネルメモリプール領域のサイズ */
> 	MB_T		*mpk;			/* カーネルメモリプール領域の先頭番地 */
280a311,315
>  *  保護ドメイン管理ブロックのエリア（kernel_cfg.c）
>  */
> extern DOMCB	domcb_table[];
> 
> /*
290a326,330
>  *  無所属に対する保護ドメイン初期化ブロック（kernel_cfg.c）
>  */
> extern const DOMINIB	dominib_none;
> 
> /*
301a342,374
>  *  オブジェクト属性中のドメインIDを操作するためのマクロ
>  */
> #define TA_DOMMASK					(0xffU << 16)
> #define get_atrdomid(atr)			((ID)(int8_t)((atr) >> 16))
> #define set_atrdomid(atr, domid)	(((atr) & ~TA_DOMMASK) | TA_DOM(domid))
> 
> /*
>  *  オブジェクト属性から保護ドメイン初期化ブロックを取り出す
>  */
> Inline const DOMINIB *
> get_atrdominib(ATR atr)
> {
> 	ID	domid;
> 
> 	domid = get_atrdomid(atr);
> 	switch (domid) {
> 	case TDOM_KERNEL:
> 		return(&dominib_kernel);
> 	case TDOM_NONE:
> 		return(&dominib_none);
> 	default:
> 		return(get_dominib(domid));
> 	}
> }
> 
> /*
>  *  デフォルトのアクセス許可パターンを取り出すマクロ
>  */
> #define default_acptn(domid)	((domid) == TDOM_KERNEL ? TACP_KERNEL	\
> 								: (domid) == TDOM_NONE ? TACP_SHARED	\
> 								: TACP(domid))
> 
> /*
Only in ./kernel: domain.trb
diff -r ./kernel/domain_prep.trb extension/dcre/kernel/domain_prep.trb
82a83,91
> #  保護ドメイン毎の割り付け可能なオブジェクトIDの数の初期化
> #
> $domData.each do |_, params|
>   $tnum_aobjid_list.each do |tnum_aobjid|
>     params[tnum_aobjid] = 0
>   end
> end
> 
> #
290a300,304
> $cfgData[:AID_TSK].each do |_, params|
>   if params.has_key?(:domain)		# タスクに関するエラー処理前のため必要
>     $domData[params[:domain]][:tmevtCount] += params[:notsk]
>   end
> end
295a310,314
> $cfgData[:AID_CYC].each do |_, params|
>   if params.has_key?(:domain)		# 周期通知に関するエラー処理前のため必要
>     $domData[params[:domain]][:tmevtCount] += params[:nocyc]
>   end
> end
300a320,324
> $cfgData[:AID_ALM].each do |_, params|
>   if params.has_key?(:domain)		# アラーム通知に関するエラー処理前のため必要
>     $domData[params[:domain]][:tmevtCount] += params[:noalm]
>   end
> end
diff -r ./kernel/eventflag.c extension/dcre/kernel/eventflag.c
8c8
<  *  Copyright (C) 2005-2018 by Embedded and Real-Time Systems Laboratory
---
>  *  Copyright (C) 2005-2019 by Embedded and Real-Time Systems Laboratory
40c40
<  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
---
>  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
48a49
> #include "domain.h"
55a57,80
> #ifndef LOG_ACRE_FLG_ENTER
> #define LOG_ACRE_FLG_ENTER(pk_cflg)
> #endif /* LOG_ACRE_FLG_ENTER */
> 
> #ifndef LOG_ACRE_FLG_LEAVE
> #define LOG_ACRE_FLG_LEAVE(ercd)
> #endif /* LOG_ACRE_FLG_LEAVE */
> 
> #ifndef LOG_SAC_FLG_ENTER
> #define LOG_SAC_FLG_ENTER(flgid, p_acvct)
> #endif /* LOG_SAC_FLG_ENTER */
> 
> #ifndef LOG_SAC_FLG_LEAVE
> #define LOG_SAC_FLG_LEAVE(ercd)
> #endif /* LOG_SAC_FLG_LEAVE */
> 
> #ifndef LOG_DEL_FLG_ENTER
> #define LOG_DEL_FLG_ENTER(flgid)
> #endif /* LOG_DEL_FLG_ENTER */
> 
> #ifndef LOG_DEL_FLG_LEAVE
> #define LOG_DEL_FLG_LEAVE(ercd)
> #endif /* LOG_DEL_FLG_LEAVE */
> 
113,123d137
<  *  イベントフラグの数
<  */
< #define tnum_flg	((uint_t)(tmax_flgid - TMIN_FLGID + 1))
< 
< /*
<  *  イベントフラグIDからイベントフラグ管理ブロックを取り出すためのマクロ
<  */
< #define INDEX_FLG(flgid)	((uint_t)((flgid) - TMIN_FLGID))
< #define get_flgcb(flgid)	(&(flgcb_table[INDEX_FLG(flgid)]))
< 
< /*
127a142,150
> static void
> initialize_flgcb(FLGCB *p_flgcb, FLGINIB *p_flginib, const DOMINIB *p_dominib)
> {
> 	p_flginib->flgatr = TA_NOEXS;
> 	p_flgcb->p_flginib = (const FLGINIB *) p_flginib;
> 	queue_insert_prev(&(p_dominib->p_domcb->free_flgcb),
> 										&(p_flgcb->wait_queue));
> }
> 
131,132c154,157
< 	uint_t	i;
< 	FLGCB	*p_flgcb;
---
> 	uint_t			i, j, k;
> 	ID				domid;
> 	FLGCB			*p_flgcb;
> 	const DOMINIB	*p_dominib;
134c159
< 	for (i = 0; i < tnum_flg; i++) {
---
> 	for (i = 0; i < tnum_sflg; i++) {
139a165,182
> 
> 	queue_initialize(&(dominib_kernel.p_domcb->free_flgcb));
> 	for (j = 0; j < dominib_kernel.tnum_aflgid; i++, j++) {
> 		initialize_flgcb(&(flgcb_table[i]), &(aflginib_table[j]),
> 													&dominib_kernel);
> 	}
> 	for (domid = TMIN_DOMID; domid <= tmax_domid; domid++) {
> 		p_dominib = get_dominib(domid);
> 		queue_initialize(&(p_dominib->p_domcb->free_flgcb));
> 		for (k = 0; k < p_dominib->tnum_aflgid; i++, j++, k++) {
> 			initialize_flgcb(&(flgcb_table[i]), &(aflginib_table[j]),
> 															p_dominib);
> 		}
> 	}
> 	for (k = 0; k < dominib_none.tnum_aflgid; i++, j++, k++) {
> 		initialize_flgcb(&(flgcb_table[i]), &(aflginib_table[j]),
> 													&dominib_none);
> 	}
165a209,380
>  *  イベントフラグの生成
>  *
>  *  pk_cflg->iflgptnは，エラーチェックをせず，一度しか参照しないため，
>  *  ローカル変数にコピーする必要がない（途中で書き換わっても支障がな
>  *  い）．
>  */
> #ifdef TOPPERS_acre_flg
> 
> ER_UINT
> acre_flg(const T_CFLG *pk_cflg)
> {
> 	FLGCB			*p_flgcb;
> 	FLGINIB			*p_flginib;
> 	ATR				flgatr;
> 	ID				domid;
> 	const DOMINIB	*p_dominib;
> 	ACPTN			acptn;
> 	ER				ercd;
> 
> 	LOG_ACRE_FLG_ENTER(pk_cflg);
> 	CHECK_TSKCTX_UNL();
> 	CHECK_MACV_READ(pk_cflg, T_CFLG);
> 
> 	flgatr = pk_cflg->flgatr;
> 
> 	CHECK_VALIDATR(pk_cflg->flgatr, TA_TPRI|TA_WMUL|TA_CLR|TA_DOMMASK);
> 	domid = get_atrdomid(flgatr);
> 	if (domid == TDOM_SELF) {
> 		if (rundom == TACP_KERNEL) {
> 			domid = TDOM_KERNEL;
> 		}
> 		else {
> 			domid = p_runtsk->p_tinib->domid;
> 		}
> 		flgatr = set_atrdomid(flgatr, domid);
> 	}
> 	switch (domid) {
> 	case TDOM_KERNEL:
> 		p_dominib = &dominib_kernel;
> 		break;
> 	case TDOM_NONE:
> 		p_dominib = &dominib_none;
> 		break;
> 	default:
> 		CHECK_RSATR(VALID_DOMID(domid));
> 		p_dominib = get_dominib(domid);
> 		break;
> 	}
> 	CHECK_ACPTN(p_dominib->acvct.acptn1);
> 
> 	lock_cpu();
> 	if (tnum_flg == 0 || queue_empty(&(p_dominib->p_domcb->free_flgcb))) {
> 		ercd = E_NOID;
> 	}
> 	else {
> 		p_flgcb = (FLGCB *)
> 					queue_delete_next(&(p_dominib->p_domcb->free_flgcb));
> 		p_flginib = (FLGINIB *)(p_flgcb->p_flginib);
> 		p_flginib->flgatr = flgatr;
> 		p_flginib->iflgptn = pk_cflg->iflgptn;
> 
> 		acptn = default_acptn(domid);
> 		p_flginib->acvct.acptn1 = acptn;
> 		p_flginib->acvct.acptn2 = acptn;
> 		p_flginib->acvct.acptn3 = p_dominib->acvct.acptn1;
> 		p_flginib->acvct.acptn4 = acptn;
> 
> 		queue_initialize(&(p_flgcb->wait_queue));
> 		p_flgcb->flgptn = p_flgcb->p_flginib->iflgptn;
> 		ercd = FLGID(p_flgcb);
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_ACRE_FLG_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_acre_flg */
> 
> /*
>  *  イベントフラグのアクセス許可ベクタの設定
>  */
> #ifdef TOPPERS_sac_flg
> 
> ER
> sac_flg(ID flgid, const ACVCT *p_acvct)
> {
> 	FLGCB	*p_flgcb;
> 	FLGINIB	*p_flginib;
> 	ER		ercd;
> 
> 	LOG_SAC_FLG_ENTER(flgid, p_acvct);
> 	CHECK_TSKCTX_UNL();
> 	CHECK_ID(VALID_FLGID(flgid));
> 	CHECK_MACV_READ(p_acvct, ACVCT);
> 	p_flgcb = get_flgcb(flgid);
> 
> 	lock_cpu();
> 	if (p_flgcb->p_flginib->flgatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_flgcb->p_flginib->acvct.acptn3)) {
> 		ercd = E_OACV;
> 	}
> 	else if (FLGID(p_flgcb) <= tmax_sflgid) {
> 		ercd = E_OBJ;
> 	}
> 	else {
> 		p_flginib = (FLGINIB *)(p_flgcb->p_flginib);
> 		p_flginib->acvct = *p_acvct;
> 		ercd = E_OK;
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_SAC_FLG_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_sac_flg */
> 
> /*
>  *  イベントフラグの削除
>  */
> #ifdef TOPPERS_del_flg
> 
> ER
> del_flg(ID flgid)
> {
> 	FLGCB			*p_flgcb;
> 	FLGINIB			*p_flginib;
> 	const DOMINIB	*p_dominib;
> 	ER				ercd;
> 
> 	LOG_DEL_FLG_ENTER(flgid);
> 	CHECK_TSKCTX_UNL();
> 	CHECK_ID(VALID_FLGID(flgid));
> 	p_flgcb = get_flgcb(flgid);
> 
> 	lock_cpu();
> 	if (p_flgcb->p_flginib->flgatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_flgcb->p_flginib->acvct.acptn3)) {
> 		ercd = E_OACV;
> 	}
> 	else if (FLGID(p_flgcb) <= tmax_sflgid) {
> 		ercd = E_OBJ;
> 	}
> 	else {
> 		init_wait_queue(&(p_flgcb->wait_queue));
> 		p_flginib = (FLGINIB *)(p_flgcb->p_flginib);
> 		p_dominib = get_atrdominib(p_flginib->flgatr);
> 		p_flginib->flgatr = TA_NOEXS;
> 		queue_insert_prev(&(p_dominib->p_domcb->free_flgcb),
> 										&(p_flgcb->wait_queue));
> 		if (p_runtsk != p_schedtsk) {
> 			dispatch();
> 		}
> 		ercd = E_OK;
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_DEL_FLG_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_del_flg */
> 
> /*
183d397
< 	CHECK_ACPTN(p_flgcb->p_flginib->acvct.acptn1);
186,192c400,413
< 	p_flgcb->flgptn |= setptn;
< 	p_queue = p_flgcb->wait_queue.p_next;
< 	while (p_queue != &(p_flgcb->wait_queue)) {
< 		p_tcb = (TCB *) p_queue;
< 		p_queue = p_queue->p_next;
< 		p_winfo_flg = (WINFO_FLG *)(p_tcb->p_winfo);
< 		if (check_flg_cond(p_flgcb, p_winfo_flg->waiptn,
---
> 	if (p_flgcb->p_flginib->flgatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_flgcb->p_flginib->acvct.acptn1)) {
> 		ercd = E_OACV;
> 	}
> 	else {
> 		p_flgcb->flgptn |= setptn;
> 		p_queue = p_flgcb->wait_queue.p_next;
> 		while (p_queue != &(p_flgcb->wait_queue)) {
> 			p_tcb = (TCB *) p_queue;
> 			p_queue = p_queue->p_next;
> 			p_winfo_flg = (WINFO_FLG *)(p_tcb->p_winfo);
> 			if (check_flg_cond(p_flgcb, p_winfo_flg->waiptn,
194,197c415,419
< 			queue_delete(&(p_tcb->task_queue));
< 			wait_complete(p_tcb);
< 			if ((p_flgcb->p_flginib->flgatr & TA_CLR) != 0U) {
< 				break;
---
> 				queue_delete(&(p_tcb->task_queue));
> 				wait_complete(p_tcb);
> 				if ((p_flgcb->p_flginib->flgatr & TA_CLR) != 0U) {
> 					break;
> 				}
200,206c422,428
< 	}
< 	if (p_runtsk != p_schedtsk) {
< 		if (!sense_context()) {
< 			dispatch();
< 		}
< 		else {
< 			request_dispatch_retint();
---
> 		if (p_runtsk != p_schedtsk) {
> 			if (!sense_context()) {
> 				dispatch();
> 			}
> 			else {
> 				request_dispatch_retint();
> 			}
207a430
> 		ercd = E_OK;
209d431
< 	ercd = E_OK;
234d455
< 	CHECK_ACPTN(p_flgcb->p_flginib->acvct.acptn1);
237,238c458,467
< 	p_flgcb->flgptn &= clrptn; 
< 	ercd = E_OK;
---
> 	if (p_flgcb->p_flginib->flgatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_flgcb->p_flginib->acvct.acptn1)) {
> 		ercd = E_OACV;
> 	}
> 	else {
> 		p_flgcb->flgptn &= clrptn; 
> 		ercd = E_OK;
> 	}
267d495
< 	CHECK_ACPTN(p_flgcb->p_flginib->acvct.acptn2);
270c498,504
< 	if (p_runtsk->raster) {
---
> 	if (p_flgcb->p_flginib->flgatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_flgcb->p_flginib->acvct.acptn2)) {
> 		ercd = E_OACV;
> 	}
> 	else if (p_runtsk->raster) {
318d551
< 	CHECK_ACPTN(p_flgcb->p_flginib->acvct.acptn2);
321c554,560
< 	if ((p_flgcb->p_flginib->flgatr & TA_WMUL) == 0U
---
> 	if (p_flgcb->p_flginib->flgatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_flgcb->p_flginib->acvct.acptn2)) {
> 		ercd = E_OACV;
> 	}
> 	else if ((p_flgcb->p_flginib->flgatr & TA_WMUL) == 0U
361d599
< 	CHECK_ACPTN(p_flgcb->p_flginib->acvct.acptn2);
364c602,608
< 	if (p_runtsk->raster) {
---
> 	if (p_flgcb->p_flginib->flgatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_flgcb->p_flginib->acvct.acptn2)) {
> 		ercd = E_OACV;
> 	}
> 	else if (p_runtsk->raster) {
412d655
< 	CHECK_ACPTN(p_flgcb->p_flginib->acvct.acptn3);
415,418c658,670
< 	init_wait_queue(&(p_flgcb->wait_queue));
< 	p_flgcb->flgptn = p_flgcb->p_flginib->iflgptn;
< 	if (p_runtsk != p_schedtsk) {
< 		dispatch();
---
> 	if (p_flgcb->p_flginib->flgatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_flgcb->p_flginib->acvct.acptn3)) {
> 		ercd = E_OACV;
> 	}
> 	else {
> 		init_wait_queue(&(p_flgcb->wait_queue));
> 		p_flgcb->flgptn = p_flgcb->p_flginib->iflgptn;
> 		if (p_runtsk != p_schedtsk) {
> 			dispatch();
> 		}
> 		ercd = E_OK;
420d671
< 	ercd = E_OK;
446d696
< 	CHECK_ACPTN(p_flgcb->p_flginib->acvct.acptn4);
449,451c699,709
< 	pk_rflg->wtskid = wait_tskid(&(p_flgcb->wait_queue));
< 	pk_rflg->flgptn = p_flgcb->flgptn;
< 	ercd = E_OK;
---
> 	if (p_flgcb->p_flginib->flgatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_flgcb->p_flginib->acvct.acptn4)) {
> 		ercd = E_OACV;
> 	}
> 	else {
> 		pk_rflg->wtskid = wait_tskid(&(p_flgcb->wait_queue));
> 		pk_rflg->flgptn = p_flgcb->flgptn;
> 		ercd = E_OK;
> 	}
diff -r ./kernel/eventflag.h extension/dcre/kernel/eventflag.h
8c8
<  *  Copyright (C) 2005-2015 by Embedded and Real-Time Systems Laboratory
---
>  *  Copyright (C) 2005-2018 by Embedded and Real-Time Systems Laboratory
40c40
<  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
---
>  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
100a101
> extern const ID	tmax_sflgid;
105a107
> extern FLGINIB			aflginib_table[];
112a115,126
>  *  イベントフラグの数
>  */
> #define tnum_flg	((uint_t)(tmax_flgid - TMIN_FLGID + 1))
> #define tnum_sflg	((uint_t)(tmax_sflgid - TMIN_FLGID + 1))
> 
> /*
>  *  イベントフラグIDからイベントフラグ管理ブロックを取り出すためのマクロ
>  */
> #define INDEX_FLG(flgid)	((uint_t)((flgid) - TMIN_FLGID))
> #define get_flgcb(flgid)	(&(flgcb_table[INDEX_FLG(flgid)]))
> 
> /*
Only in ./kernel: eventflag.trb
Only in ./kernel: exception.c
Only in ./kernel: exception.h
Only in ./kernel: exception.trb
Only in ./kernel: genoffset.trb
diff -r ./kernel/interrupt.c extension/dcre/kernel/interrupt.c
48a49
> #include "domain.h"
54a56,87
> #ifndef LOG_ISR_ENTER
> #define LOG_ISR_ENTER(isrid)
> #endif /* LOG_ISR_ENTER */
> 
> #ifndef LOG_ISR_LEAVE
> #define LOG_ISR_LEAVE(isrid)
> #endif /* LOG_ISR_LEAVE */
> 
> #ifndef LOG_ACRE_ISR_ENTER
> #define LOG_ACRE_ISR_ENTER(pk_cisr)
> #endif /* LOG_ACRE_ISR_ENTER */
> 
> #ifndef LOG_ACRE_ISR_LEAVE
> #define LOG_ACRE_ISR_LEAVE(ercd)
> #endif /* LOG_ACRE_ISR_LEAVE */
> 
> #ifndef LOG_SAC_ISR_ENTER
> #define LOG_SAC_ISR_ENTER(isrid, p_acvct)
> #endif /* LOG_SAC_ISR_ENTER */
> 
> #ifndef LOG_SAC_ISR_LEAVE
> #define LOG_SAC_ISR_LEAVE(ercd)
> #endif /* LOG_SAC_ISR_LEAVE */
> 
> #ifndef LOG_DEL_ISR_ENTER
> #define LOG_DEL_ISR_ENTER(isrid)
> #endif /* LOG_DEL_ISR_ENTER */
> 
> #ifndef LOG_DEL_ISR_LEAVE
> #define LOG_DEL_ISR_LEAVE(ercd)
> #endif /* LOG_DEL_ISR_LEAVE */
> 
129a163,166
> #ifndef VALID_INTNO_CREISR
> #define VALID_INTNO_CREISR(intno)	VALID_INTNO(intno)
> #endif /* VALID_INTNO_CREISR */
> 
137a175,469
> /*
>  *  割込みサービスルーチンの数
>  */
> #define tnum_isr	((uint_t)(tmax_isrid - TMIN_ISRID + 1))
> #define tnum_sisr	((uint_t)(tmax_sisrid - TMIN_ISRID + 1))
> 
> /*
>  *  割込みサービスルーチンIDから割込みサービスルーチン管理ブロックを取
>  *  り出すためのマクロ
>  */
> #define INDEX_ISR(isrid)	((uint_t)((isrid) - TMIN_ISRID))
> #define get_isrcb(isrid)	(&(isrcb_table[INDEX_ISR(isrid)]))
> 
> /*
>  *  割込みサービスルーチンキューへの登録
>  */
> Inline void
> enqueue_isr(QUEUE *p_isr_queue, ISRCB *p_isrcb)
> {
> 	QUEUE	*p_entry;
> 	PRI		isrpri = p_isrcb->p_isrinib->isrpri;
> 
> 	for (p_entry = p_isr_queue->p_next; p_entry != p_isr_queue;
> 											p_entry = p_entry->p_next) {
> 		if (isrpri < ((ISRCB *) p_entry)->p_isrinib->isrpri) {
> 			break;
> 		}
> 	}
> 	queue_insert_prev(p_entry, &(p_isrcb->isr_queue));
> }
> 
> #ifdef TOPPERS_isrini
> 
> /*
>  *  使用していない割込みサービスルーチン管理ブロックのリスト
>  */
> QUEUE	free_isrcb;
> 
> /* 
>  *  割込みサービスルーチン機能の初期化
>  */
> void
> initialize_isr(void)
> {
> 	uint_t	i, j;
> 	ISRCB	*p_isrcb;
> 	ISRINIB	*p_isrinib;
> 
> 	for (i = 0; i < tnum_isr_queue; i++) {
> 		queue_initialize(&(isr_queue_table[i]));
> 	}
> 	for (i = 0; i < tnum_sisr; i++) {
> 		j = INDEX_ISR(isrorder_table[i]);
> 		p_isrcb = &(isrcb_table[j]);
> 		p_isrcb->p_isrinib = &(isrinib_table[j]);
> 		enqueue_isr(p_isrcb->p_isrinib->p_isr_queue, p_isrcb);
> 	}
> 
> 	queue_initialize(&free_isrcb);
> 	for (j = 0; i < tnum_isr; i++, j++) {
> 		p_isrcb = &(isrcb_table[i]);
> 		p_isrinib = &(aisrinib_table[j]);
> 		p_isrinib->isratr = TA_NOEXS;
> 		p_isrcb->p_isrinib = ((const ISRINIB *) p_isrinib);
> 		queue_insert_prev(&free_isrcb, &(p_isrcb->isr_queue));
> 	}
> }
> 
> #endif /* TOPPERS_isrini */
> 
> /*
>  *  割込みサービスルーチンの呼出し
>  */
> #ifdef TOPPERS_isrcal
> 
> void
> call_isr(QUEUE *p_isr_queue)
> {
> 	QUEUE	*p_queue;
> 	ISRCB	*p_isrcb;
> 
> 	for (p_queue = p_isr_queue->p_next; p_queue != p_isr_queue;
> 											p_queue = p_queue->p_next) {
> 		p_isrcb = (ISRCB *) p_queue;
> 		LOG_ISR_ENTER(ISRID(p_isrcb));
> 		(*(p_isrcb->p_isrinib->isr))(p_isrcb->p_isrinib->exinf);
> 		LOG_ISR_LEAVE(ISRID(p_isrcb));
> 
> 		if (p_queue->p_next != p_isr_queue) {
> 			/* ISRの呼出し前の状態に戻す */
> 			if (sense_lock()) {
> 				unlock_cpu();
> 			}
> 		}
> 	}
> }
> 
> #endif /* TOPPERS_isrcal */
> 
> /*
>  *  割込みサービスルーチン呼出しキューの検索
>  */
> Inline QUEUE *
> search_isr_queue(INTNO intno)
> {
> 	int_t	left, right, i;
> 
> 	if (tnum_isr_queue == 0) {
> 		return(NULL);
> 	}
> 
> 	left = 0;
> 	right = tnum_isr_queue - 1;
> 	while (left < right) {
> 		i = (left + right + 1) / 2;
> 		if (intno < isr_queue_list[i].intno) {
> 			right = i - 1;
> 		}
> 		else {
> 			left = i;
> 		}
> 	}
> 	if (isr_queue_list[left].intno == intno) {
> 		return(isr_queue_list[left].p_isr_queue);
> 	}
> 	else {
> 		return(NULL);
> 	}
> }
> 
> /*
>  *  割込みサービスルーチンの生成
>  *
>  *  pk_cisr->exinfは，エラーチェックをせず，一度しか参照しないため，ロー
>  *  カル変数にコピーする必要がない（途中で書き換わっても支障がない）．
>  */
> #ifdef TOPPERS_acre_isr
> 
> ER_UINT
> acre_isr(const T_CISR *pk_cisr)
> {
> 	ISRCB		*p_isrcb;
> 	ISRINIB		*p_isrinib;
> 	QUEUE		*p_isr_queue;
> 	ATR			isratr;
> 	INTNO		intno;
> 	ISR			isr;
> 	PRI			isrpri;
> 	ID			domid;
> 	ER			ercd;
> 
> 	LOG_ACRE_ISR_ENTER(pk_cisr);
> 	CHECK_TSKCTX_UNL();
> 	CHECK_MACV_READ(pk_cisr, T_CISR);
> 
> 	isratr = pk_cisr->isratr;
> 	intno = pk_cisr->intno;
> 	isr = pk_cisr->isr;
> 	isrpri = pk_cisr->isrpri;
> 
> 	CHECK_VALIDATR(isratr, TARGET_ISRATR|TA_DOMMASK);
> 	domid = get_atrdomid(isratr);
> 	if (domid == TDOM_SELF) {
> 		CHECK_RSATR(rundom == TACP_KERNEL);
> 		domid = TDOM_KERNEL;
> 		isratr = set_atrdomid(isratr, domid);
> 	}
> 	else {
> 		CHECK_RSATR(domid == TDOM_KERNEL);
> 	}
> 
> 	CHECK_PAR(VALID_INTNO_CREISR(intno));
> 	CHECK_PAR(FUNC_ALIGN(isr));
> 	CHECK_PAR(FUNC_NONNULL(isr));
> 	CHECK_PAR(VALID_ISRPRI(isrpri));
> 	CHECK_ACPTN(dominib_kernel.acvct.acptn1);
> 
> 	p_isr_queue = search_isr_queue(intno);
> 	CHECK_OBJ(p_isr_queue != NULL);
> 
> 	lock_cpu();
> 	if (tnum_isr == 0 || queue_empty(&free_isrcb)) {
> 		ercd = E_NOID;
> 	}
> 	else {
> 		p_isrcb = ((ISRCB *) queue_delete_next(&free_isrcb));
> 		p_isrinib = (ISRINIB *)(p_isrcb->p_isrinib);
> 		p_isrinib->isratr = isratr;
> 		p_isrinib->exinf = pk_cisr->exinf;
> 		p_isrinib->p_isr_queue = p_isr_queue;
> 		p_isrinib->isr = isr;
> 		p_isrinib->isrpri = isrpri;
> 
> 		p_isrinib->acvct.acptn1 = TACP_KERNEL;
> 		p_isrinib->acvct.acptn2 = TACP_KERNEL;
> 		p_isrinib->acvct.acptn3 = dominib_kernel.acvct.acptn1;
> 		p_isrinib->acvct.acptn4 = TACP_KERNEL;
> 
> 		enqueue_isr(p_isr_queue, p_isrcb);
> 		ercd = ISRID(p_isrcb);
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_ACRE_ISR_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_acre_isr */
> 
> /*
>  *  割込みサービスルーチンのアクセス許可ベクタの設定
>  */
> #ifdef TOPPERS_sac_isr
> 
> ER
> sac_isr(ID isrid, const ACVCT *p_acvct)
> {
> 	ISRCB	*p_isrcb;
> 	ISRINIB	*p_isrinib;
> 	ER		ercd;
> 
> 	LOG_SAC_ISR_ENTER(isrid, p_acvct);
> 	CHECK_TSKCTX_UNL();
> 	CHECK_ID(VALID_ISRID(isrid));
> 	CHECK_MACV_READ(p_acvct, ACVCT);
> 	p_isrcb = get_isrcb(isrid);
> 
> 	lock_cpu();
> 	if (p_isrcb->p_isrinib->isratr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_isrcb->p_isrinib->acvct.acptn3)) {
> 		ercd = E_OACV;
> 	}
> 	else if (ISRID(p_isrcb) > tmax_sisrid) {
> 		p_isrinib = (ISRINIB *)(p_isrcb->p_isrinib);
> 		p_isrinib->acvct = *p_acvct;
> 		ercd = E_OK;
> 	}
> 	else {
> 		ercd = E_OBJ;
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_SAC_ISR_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_sac_isr */
> 
> /*
>  *  割込みサービスルーチンの削除
>  */
> #ifdef TOPPERS_del_isr
> 
> ER
> del_isr(ID isrid)
> {
> 	ISRCB	*p_isrcb;
> 	ISRINIB	*p_isrinib;
> 	ER		ercd;
> 
> 	LOG_DEL_ISR_ENTER(isrid);
> 	CHECK_TSKCTX_UNL();
> 	CHECK_ID(VALID_ISRID(isrid));
> 	p_isrcb = get_isrcb(isrid);
> 
> 	lock_cpu();
> 	if (p_isrcb->p_isrinib->isratr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_isrcb->p_isrinib->acvct.acptn3)) {
> 		ercd = E_OACV;
> 	}
> 	else if (ISRID(p_isrcb) <= tmax_sisrid) {
> 		ercd = E_OBJ;
> 	}
> 	else {
> 		queue_delete(&(p_isrcb->isr_queue));
> 		p_isrinib = (ISRINIB *)(p_isrcb->p_isrinib);
> 		p_isrinib->isratr = TA_NOEXS;
> 		queue_insert_prev(&free_isrcb, &(p_isrcb->isr_queue));
> 		ercd = E_OK;
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_DEL_ISR_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_del_isr */
> 
diff -r ./kernel/interrupt.h extension/dcre/kernel/interrupt.h
8c8
<  *  Copyright (C) 2005-2015 by Embedded and Real-Time Systems Laboratory
---
>  *  Copyright (C) 2005-2018 by Embedded and Real-Time Systems Laboratory
40c40
<  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
---
>  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
50a51,138
> #include <queue.h>
> 
> /*
>  *  割込みサービスルーチン初期化ブロック
>  */
> typedef struct isr_initialization_block {
> 	ATR			isratr;			/* 割込みサービスルーチン属性 */
> 	intptr_t	exinf;			/* 割込みサービスルーチンの拡張情報 */
> 	QUEUE		*p_isr_queue;	/* 登録先割込みサービスルーチンキューの番地 */
> 	ISR			isr;			/* 割込みサービスルーチンの先頭番地 */
> 	PRI			isrpri;			/* 割込みサービスルーチン優先度 */
> 	ACVCT		acvct;			/* アクセス許可ベクタ */
> } ISRINIB;
> 
> /*
>  *  割込みサービスルーチン管理ブロック
>  */
> typedef struct isr_control_block {
> 	QUEUE		isr_queue;		/* 割込みサービスルーチン呼出しキュー */
> 	const ISRINIB *p_isrinib;	/* 初期化ブロックへのポインタ */
> } ISRCB;
> 
> /*
>  *  割込みサービスルーチン呼出しキューを検索するためのデータ構造
>  */
> typedef struct {
> 	INTNO		intno;			/* 割込み番号 */
> 	QUEUE		*p_isr_queue;	/* 割込みサービスルーチン呼出しキュー */
> } ISR_ENTRY;
> 
> /*
>  *  割込みサービスルーチン呼出しキューのエントリ数（kernel_cfg.c）
>  */
> extern const uint_t tnum_isr_queue;
> 
> /*
>  *  割込みサービスルーチン呼出しキューリスト（kernel_cfg.c）
>  */
> extern const ISR_ENTRY isr_queue_list[];
> 
> /*
>  *  割込みサービスルーチン呼出しキューのエリア（kernel_cfg.c）
>  */
> extern QUEUE isr_queue_table[];
> 
> /*
>  *  使用していない割込みサービスルーチン管理ブロックのリスト
>  */
> extern QUEUE	free_isrcb;
> 
> /*
>  *  割込みサービスルーチンIDの最大値（kernel_cfg.c）
>  */
> extern const ID	tmax_isrid;
> extern const ID	tmax_sisrid;
> 
> /*
>  *  割込みサービスルーチン初期化ブロックのエリア（kernel_cfg.c）
>  */
> extern const ISRINIB	isrinib_table[];
> extern ISRINIB			aisrinib_table[];
> 
> /*
>  *  割込みサービスルーチン生成順序テーブル（kernel_cfg.c）
>  */
> extern const ID	isrorder_table[];
> 
> /*
>  *  割込みサービスルーチン管理ブロックのエリア（kernel_cfg.c）
>  */
> extern ISRCB	isrcb_table[];
> 
> /*
>  *  割込みサービスルーチン管理ブロックから割込みサービスルーチンIDを取
>  *  り出すためのマクロ
>  */
> #define	ISRID(p_isrcb)	((ID)(((p_isrcb) - isrcb_table) \
> 										- tnum_sisr + TMIN_ISRID))
> 
> /*
>  *  割込みサービスルーチン機能の初期化
>  */
> extern void initialize_isr(void);
> 
> /*
>  *  割込みサービスルーチンの呼出し
>  */
> extern void call_isr(QUEUE *p_isr_queue);
diff -r ./kernel/interrupt.trb extension/dcre/kernel/interrupt.trb
40c40
< #   $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
---
> #   $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
48,57d47
< #  kernel_cfg.hの生成
< #
< $kernelCfgH.add("#define TNUM_ISRID\t#{$cfgData[:CRE_ISR].size}")
< 
< $cfgData[:CRE_ISR].sort.each do |_, params|
<   $kernelCfgH.add("#define #{params[:isrid]}\t#{params[:isrid].val}")
< end
< $kernelCfgH.add()
< 
< #
63,75d52
< #  トレースログマクロのデフォルト定義
< #
< $kernelCfgC.add(<<EOS)
< #ifndef LOG_ISR_ENTER
< #define LOG_ISR_ENTER(isrid)
< #endif /* LOG_ISR_ENTER */
< 
< #ifndef LOG_ISR_LEAVE
< #define LOG_ISR_LEAVE(isrid)
< #endif /* LOG_ISR_LEAVE */
< EOS
< 
< #
239c216
< #  割込みサービスルーチン（ISR）に関するエラーチェックと割込みハンドラの生成
---
> #  割込みサービスルーチン（ISR）に関するエラーチェック
294a272,285
> #
> #  AID_ISRに関するエラーチェック
> #
> $cfgData[:AID_ISR].each do |_, params|
>   # カーネルドメインの囲みの中に記述されていない場合（E_RSATR）［NGKI3982］
>   if !params.has_key?(:domain) || params[:domain] != $TDOM_KERNEL
>     error_ercd("E_RSATR", params, "%apiname must be within the kernel domain")
>   end
> end
> 
> #
> #  割込みサービスルーチン（ISR）管理のデータ構造
> #
> intnoIsrList = []
296,301c287,290
<   # 割込み番号intnoValに対して登録されたISRのリストの作成
<   isrParamsList = []
<   $cfgData[:CRE_ISR].sort.each do |_, params|
<     if params[:intno] == intnoVal
<       isrParamsList.push(params)
<     end
---
>   inhnoVal = $toInhnoVal[intnoVal]
>   if $cfgData[:CFG_INT].has_key?(intnoVal) \
> 							&& !$cfgData[:DEF_INH].has_key?(inhnoVal)
>     intnoIsrList.push(intnoVal)
302a292
> end
304,338c294,307
<   # 割込み番号intnoValに対して登録されたISRが存在する場合
<   if isrParamsList.size > 0
<     inhnoVal = $toInhnoVal[intnoVal]
< 
<     # 次の静的APIに相当するデータを生成
<     # KERNEL_DOMAIN {
<     #   DEF_INH(inhno, { TA_NULL, _kernel_inthdr_<intno> } );
<     # }
<     $cfgData[:DEF_INH][inhnoVal] = {
<       inhno: NumStr.new(inhnoVal),
<       inhatr: NumStr.new($TA_NULL, "TA_NULL"),
<       inthdr: "_kernel_inthdr_#{intnoVal}",
<       domain: $TDOM_KERNEL
<     }
< 
<     # 割込みサービスルーチンを呼び出す割込みハンドラの生成［NGKI2941］
<     $kernelCfgC.add("void")
<     $kernelCfgC.add("_kernel_inthdr_#{intnoVal}(void)")
<     $kernelCfgC.add("{")
<     # 割込みサービスルーチンを優先度順に呼び出す
<     i = 0		# stable sortを行うための変数
<     isrParamsList.sort_by {|params| [ params[:isrpri].val, i += 1 ]} \
< 										.each_with_index do |params, index|
<       if index > 0
<         $kernelCfgC.add
<         $kernelCfgC.add("\tif (sense_lock()) {")
<         $kernelCfgC.add("\t\tunlock_cpu();")
<         $kernelCfgC.add2("\t}")
<       end
<       $kernelCfgC.add("\tLOG_ISR_ENTER(#{params[:isrid]});")
<       $kernelCfgC.add("\t((ISR)(#{params[:isr]}))" \
< 						"((intptr_t)(#{params[:exinf]}));")
<       $kernelCfgC.add("\tLOG_ISR_LEAVE(#{params[:isrid]});")
<     end
<     $kernelCfgC.add2("}")
---
> intnoIsrList.sort!
> $isrQueueHeader = {}
> intnoIsrList.each_with_index do |intnoVal, index|
>   $isrQueueHeader[intnoVal] = "&(_kernel_isr_queue_table[#{index}])"
> end
> 
> $kernelCfgC.add2("const uint_t _kernel_tnum_isr_queue = #{intnoIsrList.size};")
> 
> if intnoIsrList.size > 0
>   $kernelCfgC.add("const ISR_ENTRY _kernel_isr_queue_list" \
> 										"[#{intnoIsrList.size}] = {")
>   intnoIsrList.each_with_index do |intnoVal, index|
>     $kernelCfgC.add(",") if index > 0
>     $kernelCfgC.append("\t{ #{intnoVal}, #{$isrQueueHeader[intnoVal]} }")
339a309,369
>   $kernelCfgC.add
>   $kernelCfgC.add2("};")
>   $kernelCfgC.add2("QUEUE _kernel_isr_queue_table[#{intnoIsrList.size}];")
> else
>   $kernelCfgC.add("TOPPERS_EMPTY_LABEL(const ISR_ENTRY, " \
> 											"_kernel_isr_queue_list);")
>   $kernelCfgC.add2("TOPPERS_EMPTY_LABEL(QUEUE, _kernel_isr_queue_table);")
> end
> 
> #
> #  割込みサービスルーチン（ISR）呼出しのための割込みハンドラ
> #
> intnoIsrList.each do |intnoVal|
>   inhnoVal = $toInhnoVal[intnoVal]
> 
>   # 次の静的APIに相当するデータを生成
>   # KERNEL_DOMAIN {
>   #   DEF_INH(inhno, { TA_NULL, _kernel_inthdr_<intno> } );
>   # }
>   $cfgData[:DEF_INH][inhnoVal] = {
>     inhno: NumStr.new(inhnoVal),
>     inhatr: NumStr.new($TA_NULL, "TA_NULL"),
>     inthdr: "_kernel_inthdr_#{intnoVal}",
>     domain: $TDOM_KERNEL
>   }
> 
>   # 割込みサービスルーチンを呼び出す割込みハンドラの生成［NGKI2941］
>   $kernelCfgC.add("void")
>   $kernelCfgC.add("_kernel_inthdr_#{intnoVal}(void)")
>   $kernelCfgC.add("{")
>   $kernelCfgC.add("\t_kernel_call_isr(#{$isrQueueHeader[intnoVal]});");
>   $kernelCfgC.add2("}")
> end
> 
> #
> #  割込みサービスルーチンに関する一般的な情報の生成
> #
> class IsrObject < KernelObject
>   def initialize()
>     super("isr", "isr")
>   end
> 
>   def prepare(key, params)
>     # エラーチェックは実施済みなので，ここでの処理は不要
>   end
> 
>   def generateInib(key, params)
>     return("(#{params[:isratr]}), (intptr_t)(#{params[:exinf]}), " \
> 						"(#{$isrQueueHeader[params[:intno].val]}), " \
> 						"(ISR)(#{params[:isr]}), (#{params[:isrpri]}), " \
> 						"#{GenerateAcvct(params)}")
>   end
> end
> IsrObject.new.generate()
> 
> # 割込みサービスルーチン生成順序テーブルの生成
> $kernelCfgC.add("const ID _kernel_isrorder_table[TNUM_SISRID] = { ")
> $kernelCfgC.append("\t")
> $cfgData[:CRE_ISR].each_with_index do |(_, params), index|
>   $kernelCfgC.append(", ") if index > 0
>   $kernelCfgC.append("#{params[:isrid]}")
340a371,372
> $kernelCfgC.add
> $kernelCfgC.add2("};")
diff -r ./kernel/kernel.trb extension/dcre/kernel/kernel.trb
121a122,123
>     @noobj = ("no" + obj).to_sym
>     @tnum_aobjid = ("tnum_a" + obj + "id").to_sym
122a125
>     @aidapi = "AID_#{@OBJ}".to_sym
123a127
>     @inibList = { "#{@OBJ_S}INIB" => "a#{@obj_s}inib_table"}
127a132,157
>     # AID_@OBJの処理
>     numAutoObjid = 0
>     $cfgData[@aidapi].each do |_, params|
>       # 事前準備（エラーチェック）
>       if @within_domain
>         # 保護ドメインの囲みの中に記述されていない場合（E_RSATR）
>         # ［NGKI3979］［NGKI3980］［NGKI3981］
>         if !params.has_key?(:domain) || params[:domain] == $TDOM_NONE
>           error_ercd("E_RSATR", params, \
> 							"#{@api} must be within a protection domain")
>           # 以降のエラーの抑止
>           params[:domain] = $TDOM_KERNEL
>         end
>       else
>         # 保護ドメインの囲みの中に記述されていない場合は無所属とする
>         params[:domain] ||= $TDOM_NONE
>       end
> 
>       # 割り付け可能なオブジェクト数のカウント
>       numAutoObjid += params[@noobj]
>       if $domData[params[:domain]].has_key?(@tnum_aobjid)
>         $domData[params[:domain]][@tnum_aobjid] += params[@noobj]
>       end
>     end
>     numObjid = $cfgData[@api].size + numAutoObjid
> 
129c159
<     $kernelCfgH.add("#define TNUM_#{@OBJ}ID\t#{$cfgData[@api].size}")
---
>     $kernelCfgH.add("#define TNUM_#{@OBJ}ID\t#{numObjid}")
145a176,178
>     # 静的に生成されたオブジェクトの数
>     $kernelCfgC.add("#define TNUM_S#{@OBJ}ID\t#{$cfgData[@api].size}")
> 
147c180
<     $kernelCfgC.add2("const ID _kernel_tmax_#{@obj}id" \
---
>     $kernelCfgC.add("const ID _kernel_tmax_#{@obj}id" \
148a182,183
>     $kernelCfgC.add2("const ID _kernel_tmax_s#{@obj}id" \
> 							" = (TMIN_#{@OBJ}ID + TNUM_S#{@OBJ}ID - 1);")
211c246
< 													"[TNUM_#{@OBJ}ID] = {")
---
> 													"[TNUM_S#{@OBJ}ID] = {")
217a253,256
>     else
>       $kernelCfgC.add2("TOPPERS_EMPTY_LABEL(const #{@OBJ_S}INIB, " \
> 										"_kernel_#{@obj_s}inib_table);")
>     end
218a258,267
>     # 動的生成オブジェクト用のオブジェクト初期化ブロック
>     @inibList.each do |type, array|
>       if numAutoObjid > 0
>         $kernelCfgC.add2("#{type} _kernel_#{array}[#{numAutoObjid}];")
>       else
>         $kernelCfgC.add2("TOPPERS_EMPTY_LABEL(#{type}, _kernel_#{array});")
>       end
>     end
> 
>     if numObjid > 0
226,228d274
<       # オブジェクトが1つもない場合
<       $kernelCfgC.add("TOPPERS_EMPTY_LABEL(const #{@OBJ_S}INIB, " \
< 										"_kernel_#{@obj_s}inib_table);")
529a576,630
> #  カーネルメモリプール領域
> #
> $kernelCfgC.comment_header("Kernel Memory Pool Area")
> 
> $cfgData[:DEF_MPK].each do |key, params|
>   # 保護ドメインの囲みの中に記述されていない場合は無所属とする
>   params[:domain] ||= $TDOM_NONE
> 
>   # 保護ドメイン中に複数のDEF_MPKがある場合（E_OBJ）［NGKI5073］
>   $cfgData[:DEF_MPK].each do |key2, params2|
>     break if key2 == key
>     if params2[:domain] == params[:domain]
>       error_ercd("E_OBJ", params, \
> 						"%apiname is duplicated in a protection domain")
>     end
>   end
> 
>   # パラメータが省略された時のデフォルト値の設定
>   params[:mpk] ||= "NULL"
> 
>   # mpkszが0の場合（E_PAR）［NGKI5071］
>   if params[:mpksz] == 0
>     error_wrong("E_PAR", params, :mpksz, "zero")
>   end
> 
>   if params[:mpk] == "NULL"
>     # カーネルメモリプール領域の自動割付け
>     $kernelCfgC.add("static MB_T _kernel_memory_pool" \
> 						"_#{$domData[params[:domain]][:label]}" \
> 						"[COUNT_MB_T(#{params[:mpksz]})];")
>     mpksz = "ROUND_MB_T(#{params[:mpksz]})"
>     mpk = "_kernel_memory_pool_#{$domData[params[:domain]][:label]}"
>   else
>     # mpkszがターゲット定義の制約に合致しない場合（E_PAR）［NGKI5083］
>     if (params[:mpksz] & ($CHECK_MB_ALIGN - 1)) != 0
>       error_wrong("E_PAR", params, :mpksz, "not aligned")
>     end
> 
>     mpksz = "(#{params[:mpksz]})"
>     mpk = "(void *)(#{params[:mpk]})"
>   end
> 
>   # DEF_MPKのデータを$domDataに取り込む
>   $domData[params[:domain]][:mpksz] = mpksz
>   $domData[params[:domain]][:mpk] = mpk
> end
> $kernelCfgC.add()
> 
> # DEF_MPKがない時のデフォルト値の設定
> $domData.each do |_, params|
>   params[:mpksz] ||= "0"
>   params[:mpk] ||= "NULL"
> end
> 
> #
diff -r ./kernel/kernel_api.def extension/dcre/kernel/kernel_api.def
1a2
> AID_TSK .notsk
3a5
> AID_SEM .nosem
5a8
> AID_FLG .noflg
7a11
> AID_DTQ .nodtq
9a14
> AID_PDQ .nopdq
11a17
> AID_MTX .nomtx
13a20
> AID_MBF .nombf
15a23
> AID_MPF .nompf
17a26
> AID_CYC .nocyc
19a29
> AID_ALM .noalm
29a40,41
> AID_ISR .noisr
> SAC_ISR %isrid* { .acptn1 .acptn2 .acptn3 .acptn4 }
37a50
> DEF_MPK { .mpksz &mpk? }
diff -r ./kernel/kernel_api_mml.def extension/dcre/kernel/kernel_api_mml.def
1a2
> AID_TSK .notsk
3a5
> AID_SEM .nosem
5a8
> AID_FLG .noflg
7a11
> AID_DTQ .nodtq
9a14
> AID_PDQ .nopdq
11a17
> AID_MTX .nomtx
13a20
> AID_MBF .nombf
15a23
> AID_MPF .nompf
17a26
> AID_CYC .nocyc
19a29
> AID_ALM .noalm
29a40,41
> AID_ISR .noisr
> SAC_ISR %isrid* { .acptn1 .acptn2 .acptn3 .acptn4 }
37a50
> DEF_MPK { .mpksz &mpk? }
diff -r ./kernel/kernel_check.trb extension/dcre/kernel/kernel_check.trb
479a480,497
> #  割込みサービスルーチンに関するチェック
> #
> isrinib = SYMBOL("_kernel_isrinib_table")
> $cfgData[:CRE_ISR].sort.each do |_, params|
>   isr = PEEK(isrinib + $offsetof_ISRINIB_isr, $sizeof_ISR)
> 
>   # isrがプログラムの先頭番地として正しくない場合（E_PAR）［NGKI3004］
>   if (isr & ($CHECK_FUNC_ALIGN - 1)) != 0
>     error_wrong_id("E_PAR", params, :isr, :isrid, "not aligned")
>   end
>   if $CHECK_FUNC_NONNULL && isr == 0
>     error_wrong_id("E_PAR", params, :isr, :isrid, "null")
>   end
> 
>   isrinib += $sizeof_ISRINIB
> end
> 
> #
553a572,602
> #  カーネルメモリプール領域に関するチェック
> #
> $cfgData[:DEF_MPK].each do |_, params|
>   case params[:domain]
>   when $TDOM_KERNEL
>     dominib = SYMBOL("_kernel_dominib_kernel")
>   when $TDOM_NONE
>     dominib = SYMBOL("_kernel_dominib_none")
>   else
>     dominib = SYMBOL("_kernel_dominib_table") \
> 								+ (params[:domain] - 1) * $sizeof_DOMINIB
>   end
>   mpksz = PEEK(dominib + $offsetof_DOMINIB_mpksz, $sizeof_size_t)
>   mpk = PEEK(dominib + $offsetof_DOMINIB_mpk, $sizeof_void_ptr)
> 
>   # mpkがターゲット定義の制約に合致しない場合（E_PAR）［NGKI5083］
>   if (mpk & ($CHECK_MPK_ALIGN - 1)) != 0
>     error_wrong("E_PAR", params, :mpk, "not aligned")
>   end
>   if $CHECK_MPK_NONNULL && mpk == 0
>     error_wrong("E_PAR", params, :mpk, "null")
>   end
> 
>   # カーネル専用のメモリオブジェクトに含まれていない場合（E_OBJ）［NGKI5084］
>   if CheckMemobjKernel(mpk, mpksz)
>     error_ercd("E_OBJ", params, "kernel memory pool area " \
> 							"is not included in any kernel memory object")
>   end
> end
> 
> #
diff -r ./kernel/kernel_impl.h extension/dcre/kernel/kernel_impl.h
138a139
> #define TMIN_ISRID		1		/* 割込みサービスルーチンIDの最小値 */
151a153,178
> #ifndef TA_MEMALLOC
> #define TA_MEMALLOC		UINT_C(0x8000)		/* メモリ領域をカーネルで確保 */
> #endif /* TA_MEMALLOC */
> #ifndef TA_MBALLOC
> #define TA_MBALLOC		UINT_C(0x4000)		/* 管理領域をカーネルで確保 */
> #endif /* TA_MBALLOC */
> 
> /*
>  *  ターゲット定義のエラーチェックマクロのデフォルト値の定義
>  */
> #ifndef TARGET_TSKATR
> #define TARGET_TSKATR		0U		/* ターゲット定義のタスク属性 */
> #endif /* TARGET_TSKATR */
> 
> #ifndef TARGET_ISRATR
> #define TARGET_ISRATR		0U		/* ターゲット定義のISR属性 */
> #endif /* TARGET_ISRATR */
> 
> #ifndef TARGET_MIN_SSTKSZ			/* タスクのシステムスタックサイズの最小値 */
> #define TARGET_MIN_SSTKSZ	1U		/* 未定義の場合は0でないことをチェック */
> #endif /* TARGET_MIN_SSTKSZ */
> 
> #ifndef TARGET_MIN_USTKSZ			/* タスクのユーザスタックサイズの最小値 */
> #define TARGET_MIN_USTKSZ	1U		/* 未定義の場合は0でないことをチェック */
> #endif /* TARGET_MIN_USTKSZ */
> 
154a182,186
>  *  保護ドメイン初期化ブロックの型の前方参照（domain.h）
>  */
> typedef struct domain_initialization_block DOMINIB;
> 
> /*
226a259,272
>  *  メモリプール領域の管理（startup.c）
>  */
> extern bool_t	initialize_mempool(MB_T *mempool, size_t size);
> extern void		*malloc_mempool(MB_T *mempool, size_t size);
> extern void		free_mempool(MB_T *mempool, void *ptr);
> 
> /*
>  *  カーネルメモリプール領域からのメモリ獲得／解放（startup.c）
>  */
> extern void	initialize_mpk(const DOMINIB *p_dominib);
> extern void	*malloc_mpk(size_t size, const DOMINIB *p_dominib);
> extern void	free_mpk(void *ptr, const DOMINIB *p_dominib);
> 
> /*
230a277,286
> /*
>  *  通知方法のエラーチェック（time_manage.c）
>  */
> extern ER check_nfyinfo(const T_NFYINFO *p_nfyinfo, ACPTN domptn);
> 
> /*
>  *  通知ハンドラ（time_manage.c）
>  */
> extern void notify_handler(intptr_t exinf);
> 
Only in ./kernel: kernel_int.h
diff -r ./kernel/kernel_lib.trb extension/dcre/kernel/kernel_lib.trb
120a121,140
> #  保護ドメイン毎に持つ割り付け可能なオブジェクトIDの数のシンボルのリスト
> #
> $tnum_aobjid_list = [
>   :tnum_atskid, :tnum_asemid, :tnum_aflgid, :tnum_adtqid,
>   :tnum_apdqid, :tnum_amtxid, :tnum_ambfid, :tnum_ampfid,
>   :tnum_acycid, :tnum_aalmid
> ]
> 
> #
> #  保護ドメインに割り付けられたリソース量の定義の生成
> #
> def GenerateDominibResource(genFile, params)
>   $tnum_aobjid_list.each do |tnum_aobjid|
>     genFile.append("#{params[tnum_aobjid] || 0}, ")
>   end
>   genFile.append("#{params[:mpksz]}, ")
>   genFile.append(params[:mpk])
> end
> 
> #
137a158,162
>   # 保護ドメイン管理ブロックの生成
>   genFile.add("DOMCB _kernel_domcb_kernel;")
>   genFile.add("DOMCB _kernel_domcb_table[TNUM_DOMID];")
>   genFile.add2("DOMCB _kernel_domcb_none;")
> 
150a176,178
>   genFile.append(", ")
>   genFile.append("&_kernel_domcb_kernel, ")
>   GenerateDominibResource(genFile, params)
165a194,196
>       genFile.append(", ")
>       genFile.append("&(_kernel_domcb_table[#{index}]), ")
>       GenerateDominibResource(genFile, params)
172a204,220
> 
>   # 無所属に対する保護ドメイン初期化ブロックの生成
>   params = $domData[$TDOM_NONE]
>   genFile.append("const DOMINIB _kernel_dominib_none = { " \
> 								"TACP_SHARED, NULL, NULL, ")
>   if $USE_DOMINICTXB
>     if defined?($noneDominictxb)
>       genFile.append("#{$noneDominictxb}, ")
>     else
>       genFile.append("#{$kernelDominictxb}, ")
>     end
>   end
>   genFile.append(GenerateAcvct(params))
>   genFile.append(", ")
>   genFile.append("&_kernel_domcb_none, ")
>   GenerateDominibResource(genFile, params)
>   genFile.add2(" };")
Only in ./kernel: kernel_mem.trb
Only in ./kernel: kernel_opt.trb
diff -r ./kernel/kernel_rename.def extension/dcre/kernel/kernel_rename.def
3a4,8
> initialize_mempool
> malloc_mempool
> free_mempool
> malloc_mpk
> free_mpk
66a72,73
> probe_mem_write_domptn
> probe_mem_rw_domptn
134a142,145
> # time_manage.c
> check_nfyinfo
> notify_handler
> 
143a155,156
> initialize_isr
> call_isr
153a167
> tmax_stskid
154a169
> atinib_table
157a173
> tmax_ssemid
158a175
> aseminib_table
160a178
> tmax_sflgid
161a180
> aflginib_table
163a183
> tmax_sdtqid
164a185
> adtqinib_table
166a188
> tmax_spdqid
167a190
> apdqinib_table
169a193
> tmax_smtxid
170a195
> amtxinib_table
172a198
> tmax_smbfid
173a200
> ambfinib_table
175a203
> tmax_smpfid
176a205
> ampfinib_table
178a208
> tmax_scycid
179a210,211
> acycinib_table
> acyc_nfyinfo_table
181a214
> tmax_salmid
182a216,217
> aalminib_table
> aalm_nfyinfo_table
183a219,228
> tnum_isr_queue
> isr_queue_list
> isr_queue_table
> free_isrcb
> tmax_isrid
> tmax_sisrid
> isrinib_table
> aisrinib_table
> isrorder_table
> isrcb_table
210a256,258
> domcb_kernel
> domcb_table
> domcb_none
212a261
> dominib_none
diff -r ./kernel/kernel_rename.h extension/dcre/kernel/kernel_rename.h
10a11,15
> #define initialize_mempool			_kernel_initialize_mempool
> #define malloc_mempool				_kernel_malloc_mempool
> #define free_mempool				_kernel_free_mempool
> #define malloc_mpk					_kernel_malloc_mpk
> #define free_mpk					_kernel_free_mpk
83a89,90
> #define probe_mem_write_domptn		_kernel_probe_mem_write_domptn
> #define probe_mem_rw_domptn			_kernel_probe_mem_rw_domptn
168a176,181
>  *  time_manage.c
>  */
> #define check_nfyinfo				_kernel_check_nfyinfo
> #define notify_handler				_kernel_notify_handler
> 
> /*
182a196,197
> #define initialize_isr				_kernel_initialize_isr
> #define call_isr					_kernel_call_isr
198a214
> #define tmax_stskid					_kernel_tmax_stskid
199a216
> #define atinib_table				_kernel_atinib_table
202a220
> #define tmax_ssemid					_kernel_tmax_ssemid
203a222
> #define aseminib_table				_kernel_aseminib_table
205a225
> #define tmax_sflgid					_kernel_tmax_sflgid
206a227
> #define aflginib_table				_kernel_aflginib_table
208a230
> #define tmax_sdtqid					_kernel_tmax_sdtqid
209a232
> #define adtqinib_table				_kernel_adtqinib_table
211a235
> #define tmax_spdqid					_kernel_tmax_spdqid
212a237
> #define apdqinib_table				_kernel_apdqinib_table
214a240
> #define tmax_smtxid					_kernel_tmax_smtxid
215a242
> #define amtxinib_table				_kernel_amtxinib_table
217a245
> #define tmax_smbfid					_kernel_tmax_smbfid
218a247
> #define ambfinib_table				_kernel_ambfinib_table
220a250
> #define tmax_smpfid					_kernel_tmax_smpfid
221a252
> #define ampfinib_table				_kernel_ampfinib_table
223a255
> #define tmax_scycid					_kernel_tmax_scycid
224a257,258
> #define acycinib_table				_kernel_acycinib_table
> #define acyc_nfyinfo_table			_kernel_acyc_nfyinfo_table
226a261
> #define tmax_salmid					_kernel_tmax_salmid
227a263,264
> #define aalminib_table				_kernel_aalminib_table
> #define aalm_nfyinfo_table			_kernel_aalm_nfyinfo_table
228a266,275
> #define tnum_isr_queue				_kernel_tnum_isr_queue
> #define isr_queue_list				_kernel_isr_queue_list
> #define isr_queue_table				_kernel_isr_queue_table
> #define free_isrcb					_kernel_free_isrcb
> #define tmax_isrid					_kernel_tmax_isrid
> #define tmax_sisrid					_kernel_tmax_sisrid
> #define isrinib_table				_kernel_isrinib_table
> #define aisrinib_table				_kernel_aisrinib_table
> #define isrorder_table				_kernel_isrorder_table
> #define isrcb_table					_kernel_isrcb_table
255a303,305
> #define domcb_kernel				_kernel_domcb_kernel
> #define domcb_table					_kernel_domcb_table
> #define domcb_none					_kernel_domcb_none
257a308
> #define dominib_none				_kernel_dominib_none
diff -r ./kernel/kernel_sym.def extension/dcre/kernel/kernel_sym.def
95c95
< TARGET_TSKATR,,,defined(TARGET_TSKATR),0
---
> TARGET_TSKATR
98c98
< TARGET_ISRATR,,,defined(TARGET_ISRATR),0
---
> TARGET_ISRATR
104,105c104,105
< TARGET_MIN_SSTKSZ,,,defined(TARGET_MIN_SSTKSZ),1
< TARGET_MIN_USTKSZ,,,defined(TARGET_MIN_USTKSZ),1
---
> TARGET_MIN_SSTKSZ
> TARGET_MIN_USTKSZ
122a123,125
> CHECK_MPK_ALIGN,,,defined(CHECK_MPK_ALIGN),1
> CHECK_MPK_NONNULL,true,bool,defined(CHECK_MPK_NONNULL),false
> CHECK_MB_ALIGN,,,defined(CHECK_MB_ALIGN),1
160a164,176
> offsetof_DOMINIB_p_domcb,"offsetof(DOMINIB,p_domcb)"
> offsetof_DOMINIB_tnum_atskid,"offsetof(DOMINIB,tnum_atskid)"
> offsetof_DOMINIB_tnum_asemid,"offsetof(DOMINIB,tnum_asemid)"
> offsetof_DOMINIB_tnum_aflgid,"offsetof(DOMINIB,tnum_aflgid)"
> offsetof_DOMINIB_tnum_adtqid,"offsetof(DOMINIB,tnum_adtqid)"
> offsetof_DOMINIB_tnum_apdqid,"offsetof(DOMINIB,tnum_apdqid)"
> offsetof_DOMINIB_tnum_amtxid,"offsetof(DOMINIB,tnum_amtxid)"
> offsetof_DOMINIB_tnum_ambfid,"offsetof(DOMINIB,tnum_ambfid)"
> offsetof_DOMINIB_tnum_ampfid,"offsetof(DOMINIB,tnum_ampfid)"
> offsetof_DOMINIB_tnum_acycid,"offsetof(DOMINIB,tnum_acycid)"
> offsetof_DOMINIB_tnum_aalmid,"offsetof(DOMINIB,tnum_aalmid)"
> offsetof_DOMINIB_mpksz,"offsetof(DOMINIB,mpksz)"
> offsetof_DOMINIB_mpk,"offsetof(DOMINIB,mpk)"
220a237,243
> sizeof_ISRINIB,sizeof(ISRINIB)
> offsetof_ISRINIB_isratr,"offsetof(ISRINIB,isratr)"
> offsetof_ISRINIB_exinf,"offsetof(ISRINIB,exinf)"
> offsetof_ISRINIB_p_isr_queue,"offsetof(ISRINIB,p_isr_queue)"
> offsetof_ISRINIB_isr,"offsetof(ISRINIB,isr)"
> offsetof_ISRINIB_isrpri,"offsetof(ISRINIB,isrpri)"
> offsetof_ISRINIB_acvct,"offsetof(ISRINIB,acvct)"
diff -r ./kernel/kernel_unrename.h extension/dcre/kernel/kernel_unrename.h
11a12,16
> #undef initialize_mempool
> #undef malloc_mempool
> #undef free_mempool
> #undef malloc_mpk
> #undef free_mpk
84a90,91
> #undef probe_mem_write_domptn
> #undef probe_mem_rw_domptn
169a177,182
>  *  time_manage.c
>  */
> #undef check_nfyinfo
> #undef notify_handler
> 
> /*
183a197,198
> #undef initialize_isr
> #undef call_isr
199a215
> #undef tmax_stskid
200a217
> #undef atinib_table
203a221
> #undef tmax_ssemid
204a223
> #undef aseminib_table
206a226
> #undef tmax_sflgid
207a228
> #undef aflginib_table
209a231
> #undef tmax_sdtqid
210a233
> #undef adtqinib_table
212a236
> #undef tmax_spdqid
213a238
> #undef apdqinib_table
215a241
> #undef tmax_smtxid
216a243
> #undef amtxinib_table
218a246
> #undef tmax_smbfid
219a248
> #undef ambfinib_table
221a251
> #undef tmax_smpfid
222a253
> #undef ampfinib_table
224a256
> #undef tmax_scycid
225a258,259
> #undef acycinib_table
> #undef acyc_nfyinfo_table
227a262
> #undef tmax_salmid
228a264,265
> #undef aalminib_table
> #undef aalm_nfyinfo_table
229a267,276
> #undef tnum_isr_queue
> #undef isr_queue_list
> #undef isr_queue_table
> #undef free_isrcb
> #undef tmax_isrid
> #undef tmax_sisrid
> #undef isrinib_table
> #undef aisrinib_table
> #undef isrorder_table
> #undef isrcb_table
256a304,306
> #undef domcb_kernel
> #undef domcb_table
> #undef domcb_none
258a309
> #undef dominib_none
diff -r ./kernel/mem_manage.c extension/dcre/kernel/mem_manage.c
71a72,78
>  *  ターゲット依存部で定義がない場合のデフォルト値の設定
>  */
> #ifndef TARGET_MEMATR_USTACK
> #define TARGET_MEMATR_USTACK	TA_NOINITSEC
> #endif /* TARGET_MEMATR_USTACK */
> 
> /*
91a99,110
> #ifndef OMIT_USTACK_PROTECT
> 		if (!within_ustack(base, size, p_tcb)) {
> 			ercd = E_NOEXS;						/*［NGKI2930］*/
> 		}
> 		else if ((pmmode & TPM_EXEC) != 0U
> 							&& ((TARGET_MEMATR_USTACK & TA_EXEC) == 0U)) {
> 			ercd = E_MACV;
> 		}
> 		else {
> 			ercd = E_OK;
> 		}
> #else /* OMIT_USTACK_PROTECT */
92a112
> #endif /* OMIT_USTACK_PROTECT */
184d203
< 	CHECK_ACPTN(p_tcb->p_tinib->acvct.acptn4);	/*［NGKI3426］*/
186c205,215
< 	ercd = probe_memory(base, size, p_tcb, pmmode);
---
> 	lock_cpu();
> 	if (p_tcb->p_tinib->tskatr == TA_NOEXS) {
> 		ercd = E_NOEXS;							/*［NGKI3425］*/
> 	}
> 	else if (VIOLATE_ACPTN(p_tcb->p_tinib->acvct.acptn4)) {
> 		ercd = E_OACV;							/*［NGKI3426］*/
> 	}
> 	else {
> 		ercd = probe_memory(base, size, p_tcb, pmmode);
> 	}
> 	unlock_cpu();
diff -r ./kernel/memory.c extension/dcre/kernel/memory.c
112a113,115
> #ifndef OMIT_USTACK_PROTECT
> 		return(within_ustack(base, size, p_runtsk));
> #else /* OMIT_USTACK_PROTECT */
113a117
> #endif /* OMIT_USTACK_PROTECT */
157a162,164
> #ifndef OMIT_USTACK_PROTECT
> 		return(within_ustack(base, size, p_runtsk));
> #else /* OMIT_USTACK_PROTECT */
158a166
> #endif /* OMIT_USTACK_PROTECT */
181a190,369
>  *  指定した保護ドメインからのメモリへの書込み権のチェック
>  */
> #ifdef TOPPERS_memprbwdom
> #ifndef OMIT_PROBE_MEM_WRITE_DOMPTN
> 
> bool_t
> probe_mem_write_domptn(const void *base, size_t size, ACPTN domptn)
> {
> 	int_t	meminib;
> 	ATR		accatr;
> 	size_t	memsize;
> 
> 	meminib = search_meminib(base);
> 	accatr = meminib_table[meminib].accatr;
> 	memsize = ((char *)((meminib + 1 < tnum_meminib) ?
> 					memtop_table[meminib + 1] : 0)) - ((char *) base);
> 
> 	if (accatr == TA_NOEXS) {
> 		return(false);
> 	}
> 	else if (size > memsize) {
> 		/*
> 		 *  指定されたメモリ領域が，複数のメモリオブジェクトにまたがっ
> 		 *  ている場合
> 		 */
> 		return(false);
> 	}
> 	else if ((accatr & TA_USTACK) == 0U) {
> 		/*
> 		 *  ((accatr & TA_NOWRITE) != 0U)の時は，acptn1を0にしているた
> 		 *  め，acptn1のチェックのみを行えばよい．
> 		 */
> 		return((domptn & meminib_table[meminib].acptn1) != 0U);
> 	}
> 	else {
> 		return(false);
> 	}
> }
> 
> #endif /* OMIT_PROBE_MEM_WRITE_DOMPTN */
> #endif /* TOPPERS_memprbwdom */
> 
> /*
>  *  指定した保護ドメインからのメモリへの書込み＆読出し権のチェック
>  */
> #ifdef TOPPERS_memprbrwdom
> #ifndef OMIT_PROBE_MEM_RW_DOMPTN
> 
> bool_t
> probe_mem_rw_domptn(const void *base, size_t size, ACPTN domptn)
> {
> 	int_t	meminib;
> 	ATR		accatr;
> 	size_t	memsize;
> 
> 	meminib = search_meminib(base);
> 	accatr = meminib_table[meminib].accatr;
> 	memsize = ((char *)((meminib + 1 < tnum_meminib) ?
> 					memtop_table[meminib + 1] : 0)) - ((char *) base);
> 
> 	if (accatr == TA_NOEXS) {
> 		return(false);
> 	}
> 	else if (size > memsize) {
> 		/*
> 		 *  指定されたメモリ領域が，複数のメモリオブジェクトにまたがっ
> 		 *  ている場合
> 		 */
> 		return(false);
> 	}
> 	else if ((accatr & TA_USTACK) == 0U) {
> 		return((accatr & TA_NOREAD) == 0U
> 					&& (rundom & meminib_table[meminib].acptn1) != 0U
> 					&& (rundom & meminib_table[meminib].acptn2) != 0U);
> 	}
> 	else {
> 		return(false);
> 	}
> }
> 
> #endif /* OMIT_PROBE_MEM_WRITE_DOMPTN */
> #endif /* TOPPERS_memprbwdom */
> 
> /*
>  *  メモリ領域がメモリオブジェクトに含まれているかのチェック
>  */
> #ifdef TOPPERS_validmemobj
> 
> bool_t
> valid_memobj(const void *base, size_t size)
> {
> 	int_t	meminib;
> 	ATR		accatr;
> 	size_t	memsize;
> 
> 	meminib = search_meminib(base);
> 	accatr = meminib_table[meminib].accatr;
> 	memsize = ((char *)((meminib + 1 < tnum_meminib) ?
> 					memtop_table[meminib + 1] : 0)) - ((char *) base);
> 	return(accatr != TA_NOEXS && size <= memsize);
> }
> 
> #endif /* TOPPERS_validmemobj */
> 
> /*
>  *  メモリ領域がカーネル専用のメモリオブジェクトに含まれているかのチェック
>  */
> #ifdef TOPPERS_validmemobjk
> 
> bool_t
> valid_memobj_kernel(const void *base, size_t size)
> {
> 	int_t	meminib;
> 	ATR		accatr;
> 	size_t	memsize;
> 
> 	meminib = search_meminib(base);
> 	accatr = meminib_table[meminib].accatr;
> 	memsize = ((char *)((meminib + 1 < tnum_meminib) ?
> 					memtop_table[meminib + 1] : 0)) - ((char *) base);
> 	return(accatr != TA_NOEXS && size <= memsize
> 			&& (meminib_table[meminib].accatr & (TA_NOWRITE|TA_NOREAD)) == 0U
> 			&& meminib_table[meminib].acptn1 == TACP_KERNEL
> 			&& meminib_table[meminib].acptn2 == TACP_KERNEL
> 			&& meminib_table[meminib].acptn4 == TACP_KERNEL);
> }
> 
> #endif /* TOPPERS_validmemobjk */
> 
> /*
>  *  メモリ領域が保護ドメインに対して書込みアクセスと読出しアクセスが許
>  *  可されているメモリオブジェクトに含まれているかのチェック
>  */
> #ifdef TOPPERS_validmemobjd
> #ifndef OMIT_VALID_MEMOBJ_DOM
> 
> bool_t
> valid_memobj_dom(const void *base, size_t size, ACPTN domptn)
> {
> 	int_t	meminib;
> 	ATR		accatr;
> 	size_t	memsize;
> 
> 	meminib = search_meminib(base);
> 	accatr = meminib_table[meminib].accatr;
> 	memsize = ((char *)((meminib + 1 < tnum_meminib) ?
> 					memtop_table[meminib + 1] : 0)) - ((char *) base);
> 	return(accatr != TA_NOEXS && size <= memsize
> 			&& (meminib_table[meminib].accatr & (TA_NOWRITE|TA_NOREAD)) == 0U
> 			&& (meminib_table[meminib].acptn1 & domptn) != 0U
> 			&& (meminib_table[meminib].acptn2 & domptn) != 0U);
> }
> 
> #endif /* OMIT_VALID_MEMOBJ_DOM */
> #endif /* TOPPERS_validmemobjd */
> 
> /*
>  *  ユーザスタック領域として妥当かのチェック
>  */
> #ifdef TOPPERS_validustack
> #ifndef OMIT_VALID_USTACK
> 
> bool_t
> valid_ustack(const void *base, size_t size)
> {
> 	int_t	meminib;
> 	ATR		accatr;
> 	size_t	memsize;
> 
> 	meminib = search_meminib(base);
> 	accatr = meminib_table[meminib].accatr;
> 	memsize = ((char *)((meminib + 1 < tnum_meminib) ?
> 					memtop_table[meminib + 1] : 0)) - ((char *) base);
> 	return(accatr == TA_NOEXS && size <= memsize);
> }
> 
> #endif /* OMIT_VALID_USTACK */
> #endif /* TOPPERS_validustack */
> 
> /*
diff -r ./kernel/memory.h extension/dcre/kernel/memory.h
8c8
<  *  Copyright (C) 2005-2016 by Embedded and Real-Time Systems Laboratory
---
>  *  Copyright (C) 2005-2018 by Embedded and Real-Time Systems Laboratory
40c40
<  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
---
>  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
160a161,184
>  *  指定した保護ドメインからのメモリへの書込み権のチェック
>  *
>  *  domptnで指定した保護ドメイン（ユーザドメイン）が，指定したメモリ領
>  *  域への書込み権を持っているかをチェックし，書込み権を持っている場合
>  *  にtrue，そうでない場合にfalseを返す．domptnでカーネルドメインを指
>  *  定してはならない．あるタスクのみがアクセスできるメモリ領域（ユーザ
>  *  スタック領域のみが該当）を指定した場合には，falseを返す．
>  */
> extern bool_t	probe_mem_write_domptn(const void *base, size_t size,
> 														ACPTN domptn);
> 
> /*
>  *  指定した保護ドメインからのメモリへの書込み＆読出し権のチェック
>  *
>  *  domptnで指定した保護ドメイン（ユーザドメイン）が，指定したメモリ領
>  *  域への書込み権と読出し権を持っているかをチェックし，両方の権限を持っ
>  *  ている場合にtrue，そうでない場合にfalseを返す．domptnでカーネルド
>  *  メインを指定してはならない．あるタスクのみがアクセスできるメモリ領
>  *  域（ユーザスタック領域のみが該当）を指定した場合には，falseを返す．
>  */
> extern bool_t	probe_mem_rw_domptn(const void *base, size_t size,
> 														ACPTN domptn);
> 
> /*
183a208,231
>  *  メモリ領域がメモリオブジェクトに含まれているかのチェック
>  */
> extern bool_t	valid_memobj(const void *base, size_t size);
> 
> /*
>  *  メモリ領域がカーネル専用のメモリオブジェクトに含まれているかのチェック
>  */
> extern bool_t	valid_memobj_kernel(const void *base, size_t size);
> 
> /*
>  *  メモリ領域が保護ドメインに対して書込みアクセスと読出しアクセスが許
>  *  可されているメモリオブジェクトに含まれているかのチェック
>  */
> extern bool_t	valid_memobj_dom(const void *base, size_t size, ACPTN domptn);
> 
> /*
>  *  ユーザスタック領域として妥当かのチェック
>  *
>  *  指定されたメモリ領域が，登録済みのメモリオブジェクトと重ならない場
>  *  合にtrueを返す．
>  */
> extern bool_t	valid_ustack(const void *base, size_t size);
> 
> /*
Only in ./kernel: memory.trb
Only in ./kernel: memory_prep.trb
diff -r ./kernel/mempfix.c extension/dcre/kernel/mempfix.c
8c8
<  *  Copyright (C) 2005-2018 by Embedded and Real-Time Systems Laboratory
---
>  *  Copyright (C) 2005-2019 by Embedded and Real-Time Systems Laboratory
40c40
<  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
---
>  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
48a49
> #include "domain.h"
55a57,80
> #ifndef LOG_ACRE_MPF_ENTER
> #define LOG_ACRE_MPF_ENTER(pk_cmpf)
> #endif /* LOG_ACRE_MPF_ENTER */
> 
> #ifndef LOG_ACRE_MPF_LEAVE
> #define LOG_ACRE_MPF_LEAVE(ercd)
> #endif /* LOG_ACRE_MPF_LEAVE */
> 
> #ifndef LOG_SAC_MPF_ENTER
> #define LOG_SAC_MPF_ENTER(mpfid, p_acvct)
> #endif /* LOG_SAC_MPF_ENTER */
> 
> #ifndef LOG_SAC_MPF_LEAVE
> #define LOG_SAC_MPF_LEAVE(ercd)
> #endif /* LOG_SAC_MPF_LEAVE */
> 
> #ifndef LOG_DEL_MPF_ENTER
> #define LOG_DEL_MPF_ENTER(mpfid)
> #endif /* LOG_DEL_MPF_ENTER */
> 
> #ifndef LOG_DEL_MPF_LEAVE
> #define LOG_DEL_MPF_LEAVE(ercd)
> #endif /* LOG_DEL_MPF_LEAVE */
> 
107a133
> #define tnum_smpf	((uint_t)(tmax_smpfid - TMIN_MPFID + 1))
126a153,161
> static void
> initialize_mpfcb(MPFCB *p_mpfcb, MPFINIB *p_mpfinib, const DOMINIB *p_dominib)
> {
> 	p_mpfinib->mpfatr = TA_NOEXS;
> 	p_mpfcb->p_mpfinib = (const MPFINIB *) p_mpfinib;
> 	queue_insert_prev(&(p_dominib->p_domcb->free_mpfcb),
> 										&(p_mpfcb->wait_queue));
> }
> 
130,131c165,168
< 	uint_t	i;
< 	MPFCB	*p_mpfcb;
---
> 	uint_t			i, j, k;
> 	ID				domid;
> 	MPFCB			*p_mpfcb;
> 	const DOMINIB	*p_dominib;
133c170
< 	for (i = 0; i < tnum_mpf; i++) {
---
> 	for (i = 0; i < tnum_smpf; i++) {
140a178,195
> 
> 	queue_initialize(&(dominib_kernel.p_domcb->free_mpfcb));
> 	for (j = 0; j < dominib_kernel.tnum_ampfid; i++, j++) {
> 		initialize_mpfcb(&(mpfcb_table[i]), &(ampfinib_table[j]),
> 													&dominib_kernel);
> 	}
> 	for (domid = TMIN_DOMID; domid <= tmax_domid; domid++) {
> 		p_dominib = get_dominib(domid);
> 		queue_initialize(&(p_dominib->p_domcb->free_mpfcb));
> 		for (k = 0; k < p_dominib->tnum_ampfid; i++, j++, k++) {
> 			initialize_mpfcb(&(mpfcb_table[i]), &(ampfinib_table[j]),
> 															p_dominib);
> 		}
> 	}
> 	for (k = 0; k < dominib_none.tnum_ampfid; i++, j++, k++) {
> 		initialize_mpfcb(&(mpfcb_table[i]), &(ampfinib_table[j]),
> 													&dominib_none);
> 	}
171a227,427
>  *  固定長メモリプールの生成
>  */
> #ifdef TOPPERS_acre_mpf
> 
> ER_UINT
> acre_mpf(const T_CMPF *pk_cmpf)
> {
> 	MPFCB			*p_mpfcb;
> 	MPFINIB			*p_mpfinib;
> 	ATR				mpfatr;
> 	uint_t			blkcnt, blksz;
> 	MPF_T			*mpf;
> 	void			*p_mpfmb;
> 	ID				domid;
> 	const DOMINIB	*p_dominib;
> 	ACPTN			acptn;
> 	ER				ercd;
> 
> 	LOG_ACRE_MPF_ENTER(pk_cmpf);
> 	CHECK_TSKCTX_UNL();
> 	CHECK_MACV_READ(pk_cmpf, T_CMPF);
> 
> 	mpfatr = pk_cmpf->mpfatr;
> 	blkcnt = pk_cmpf->blkcnt;
> 	blksz = pk_cmpf->blksz;
> 	mpf = pk_cmpf->mpf;
> 	p_mpfmb = pk_cmpf->mpfmb;
> 
> 	CHECK_VALIDATR(mpfatr, TA_TPRI|TA_DOMMASK);
> 	CHECK_PAR(blkcnt != 0);
> 	CHECK_PAR(blksz != 0);
> 	CHECK_NOSPT(mpf != NULL);
> 	CHECK_PAR(MPF_ALIGN(mpf));
> 	CHECK_OBJ(valid_memobj(mpf, ROUND_MPF_T(blksz) * blkcnt));
> 	if (p_mpfmb != NULL) {
> 		CHECK_PAR(MB_ALIGN(p_mpfmb));
> 		CHECK_OBJ(valid_memobj_kernel(p_mpfmb, sizeof(MPFMB) * blkcnt));
> 	}
> 	domid = get_atrdomid(mpfatr);
> 	if (domid == TDOM_SELF) {
> 		if (rundom == TACP_KERNEL) {
> 			domid = TDOM_KERNEL;
> 		}
> 		else {
> 			domid = p_runtsk->p_tinib->domid;
> 		}
> 		mpfatr = set_atrdomid(mpfatr, domid);
> 	}
> 	switch (domid) {
> 	case TDOM_KERNEL:
> 		p_dominib = &dominib_kernel;
> 		break;
> 	case TDOM_NONE:
> 		p_dominib = &dominib_none;
> 		break;
> 	default:
> 		CHECK_RSATR(VALID_DOMID(domid));
> 		p_dominib = get_dominib(domid);
> 		break;
> 	}
> 	CHECK_ACPTN(p_dominib->acvct.acptn1);
> 
> 	lock_cpu();
> 	if (tnum_mpf == 0 || queue_empty(&(p_dominib->p_domcb->free_mpfcb))) {
> 		ercd = E_NOID;
> 	}
> 	else {
> 		if (p_mpfmb == NULL) {
> 			p_mpfmb = malloc_mpk(sizeof(MPFMB) * blkcnt, p_dominib);
> 			mpfatr |= TA_MBALLOC;
> 		}
> 		if (p_mpfmb == NULL) {
> 			ercd = E_NOMEM;
> 		}
> 		else {
> 			p_mpfcb = (MPFCB *)
> 						queue_delete_next(&(p_dominib->p_domcb->free_mpfcb));
> 			p_mpfinib = (MPFINIB *)(p_mpfcb->p_mpfinib);
> 			p_mpfinib->mpfatr = mpfatr;
> 			p_mpfinib->blkcnt = blkcnt;
> 			p_mpfinib->blksz = ROUND_MPF_T(blksz);
> 			p_mpfinib->mpf = mpf;
> 			p_mpfinib->p_mpfmb = p_mpfmb;
> 
> 			acptn = default_acptn(domid);
> 			p_mpfinib->acvct.acptn1 = acptn;
> 			p_mpfinib->acvct.acptn2 = acptn;
> 			p_mpfinib->acvct.acptn3 = p_dominib->acvct.acptn1;
> 			p_mpfinib->acvct.acptn4 = acptn;
> 
> 			queue_initialize(&(p_mpfcb->wait_queue));
> 			p_mpfcb->fblkcnt = blkcnt;
> 			p_mpfcb->unused = 0U;
> 			p_mpfcb->freelist = INDEX_NULL;
> 			ercd = MPFID(p_mpfcb);
> 		}
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_ACRE_MPF_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_acre_mpf */
> 
> /*
>  *  固定長メモリプールのアクセス許可ベクタの設定
>  */
> #ifdef TOPPERS_sac_mpf
> 
> ER
> sac_mpf(ID mpfid, const ACVCT *p_acvct)
> {
> 	MPFCB	*p_mpfcb;
> 	MPFINIB	*p_mpfinib;
> 	ER		ercd;
> 
> 	LOG_SAC_MPF_ENTER(mpfid, p_acvct);
> 	CHECK_TSKCTX_UNL();
> 	CHECK_ID(VALID_MPFID(mpfid));
> 	CHECK_MACV_READ(p_acvct, ACVCT);
> 	p_mpfcb = get_mpfcb(mpfid);
> 
> 	lock_cpu();
> 	if (p_mpfcb->p_mpfinib->mpfatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_mpfcb->p_mpfinib->acvct.acptn3)) {
> 		ercd = E_OACV;
> 	}
> 	else if (MPFID(p_mpfcb) <= tmax_smpfid) {
> 		ercd = E_OBJ;
> 	}
> 	else {
> 		p_mpfinib = (MPFINIB *)(p_mpfcb->p_mpfinib);
> 		p_mpfinib->acvct = *p_acvct;
> 		ercd = E_OK;
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_SAC_MPF_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_sac_mpf */
> 
> /*
>  *  固定長メモリプールの削除
>  */
> #ifdef TOPPERS_del_mpf
> 
> ER
> del_mpf(ID mpfid)
> {
> 	MPFCB			*p_mpfcb;
> 	MPFINIB			*p_mpfinib;
> 	const DOMINIB	*p_dominib;
> 	ER				ercd;
> 
> 	LOG_DEL_MPF_ENTER(mpfid);
> 	CHECK_TSKCTX_UNL();
> 	CHECK_ID(VALID_MPFID(mpfid));
> 	p_mpfcb = get_mpfcb(mpfid);
> 
> 	lock_cpu();
> 	if (p_mpfcb->p_mpfinib->mpfatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_mpfcb->p_mpfinib->acvct.acptn3)) {
> 		ercd = E_OACV;
> 	}
> 	else if (MPFID(p_mpfcb) <= tmax_smpfid) {
> 		ercd = E_OBJ;
> 	}
> 	else {
> 		init_wait_queue(&(p_mpfcb->wait_queue));
> 		p_mpfinib = (MPFINIB *)(p_mpfcb->p_mpfinib);
> 		p_dominib = get_atrdominib(p_mpfinib->mpfatr);
> 		if ((p_mpfinib->mpfatr & TA_MBALLOC) != 0U) {
> 			free_mpk(p_mpfinib->p_mpfmb, p_dominib);
> 		}
> 		p_mpfinib->mpfatr = TA_NOEXS;
> 		queue_insert_prev(&(p_dominib->p_domcb->free_mpfcb),
> 										&(p_mpfcb->wait_queue));
> 		if (p_runtsk != p_schedtsk) {
> 			dispatch();
> 		}
> 		ercd = E_OK;
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_DEL_MPF_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_del_mpf */
> 
> /*
188d443
< 	CHECK_ACPTN(p_mpfcb->p_mpfinib->acvct.acptn1);
191c446,452
< 	if (p_runtsk->raster) {
---
> 	if (p_mpfcb->p_mpfinib->mpfatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_mpfcb->p_mpfinib->acvct.acptn1)) {
> 		ercd = E_OACV;
> 	}
> 	else if (p_runtsk->raster) {
232d492
< 	CHECK_ACPTN(p_mpfcb->p_mpfinib->acvct.acptn1);
235c495,501
< 	if (p_mpfcb->fblkcnt > 0) {
---
> 	if (p_mpfcb->p_mpfinib->mpfatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_mpfcb->p_mpfinib->acvct.acptn1)) {
> 		ercd = E_OACV;
> 	}
> 	else if (p_mpfcb->fblkcnt > 0) {
270d535
< 	CHECK_ACPTN(p_mpfcb->p_mpfinib->acvct.acptn1);
273c538,544
< 	if (p_runtsk->raster) {
---
> 	if (p_mpfcb->p_mpfinib->mpfatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_mpfcb->p_mpfinib->acvct.acptn1)) {
> 		ercd = E_OACV;
> 	}
> 	else if (p_runtsk->raster) {
319,325d589
< 	CHECK_ACPTN(p_mpfcb->p_mpfinib->acvct.acptn2);
< 	CHECK_PAR(p_mpfcb->p_mpfinib->mpf <= blk);
< 	blkoffset = ((char *) blk) - (char *)(p_mpfcb->p_mpfinib->mpf);
< 	CHECK_PAR(blkoffset % p_mpfcb->p_mpfinib->blksz == 0U);
< 	CHECK_PAR(blkoffset / p_mpfcb->p_mpfinib->blksz < p_mpfcb->unused);
< 	blkidx = (uint_t)(blkoffset / p_mpfcb->p_mpfinib->blksz);
< 	CHECK_PAR((p_mpfcb->p_mpfinib->p_mpfmb + blkidx)->next == INDEX_ALLOC);
328,335c592,596
< 	if (!queue_empty(&(p_mpfcb->wait_queue))) {
< 		p_tcb = (TCB *) queue_delete_next(&(p_mpfcb->wait_queue));
< 		((WINFO_MPF *)(p_tcb->p_winfo))->blk = blk;
< 		wait_complete(p_tcb);
< 		if (p_runtsk != p_schedtsk) {
< 			dispatch();
< 		}
< 		ercd = E_OK;
---
> 	if (p_mpfcb->p_mpfinib->mpfatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_mpfcb->p_mpfinib->acvct.acptn2)) {
> 		ercd = E_OACV;
338,341c599,622
< 		p_mpfcb->fblkcnt++;
< 		(p_mpfcb->p_mpfinib->p_mpfmb + blkidx)->next = p_mpfcb->freelist;
< 		p_mpfcb->freelist = blkidx;
< 		ercd = E_OK;
---
> 		blkoffset = ((char *) blk) - (char *)(p_mpfcb->p_mpfinib->mpf);
> 		blkidx = (uint_t)(blkoffset / p_mpfcb->p_mpfinib->blksz);
> 		if (!(p_mpfcb->p_mpfinib->mpf <= blk)
> 				|| !(blkoffset % p_mpfcb->p_mpfinib->blksz == 0U)
> 				|| !(blkoffset / p_mpfcb->p_mpfinib->blksz < p_mpfcb->unused)
> 				|| !((p_mpfcb->p_mpfinib->p_mpfmb + blkidx)->next
> 															== INDEX_ALLOC)) {
> 			ercd = E_PAR;
> 		}
> 		else if (!queue_empty(&(p_mpfcb->wait_queue))) {
> 			p_tcb = (TCB *) queue_delete_next(&(p_mpfcb->wait_queue));
> 			((WINFO_MPF *)(p_tcb->p_winfo))->blk = blk;
> 			wait_complete(p_tcb);
> 			if (p_runtsk != p_schedtsk) {
> 				dispatch();
> 			}
> 			ercd = E_OK;
> 		}
> 		else {
> 			p_mpfcb->fblkcnt++;
> 			(p_mpfcb->p_mpfinib->p_mpfmb + blkidx)->next = p_mpfcb->freelist;
> 			p_mpfcb->freelist = blkidx;
> 			ercd = E_OK;
> 		}
367d647
< 	CHECK_ACPTN(p_mpfcb->p_mpfinib->acvct.acptn3);
370,375c650,664
< 	init_wait_queue(&(p_mpfcb->wait_queue));
< 	p_mpfcb->fblkcnt = p_mpfcb->p_mpfinib->blkcnt;
< 	p_mpfcb->unused = 0U;
< 	p_mpfcb->freelist = INDEX_NULL;
< 	if (p_runtsk != p_schedtsk) {
< 		dispatch();
---
> 	if (p_mpfcb->p_mpfinib->mpfatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_mpfcb->p_mpfinib->acvct.acptn3)) {
> 		ercd = E_OACV;
> 	}
> 	else {
> 		init_wait_queue(&(p_mpfcb->wait_queue));
> 		p_mpfcb->fblkcnt = p_mpfcb->p_mpfinib->blkcnt;
> 		p_mpfcb->unused = 0U;
> 		p_mpfcb->freelist = INDEX_NULL;
> 		if (p_runtsk != p_schedtsk) {
> 			dispatch();
> 		}
> 		ercd = E_OK;
377d665
< 	ercd = E_OK;
403d690
< 	CHECK_ACPTN(p_mpfcb->p_mpfinib->acvct.acptn4);
406,408c693,703
< 	pk_rmpf->wtskid = wait_tskid(&(p_mpfcb->wait_queue));
< 	pk_rmpf->fblkcnt = p_mpfcb->fblkcnt;
< 	ercd = E_OK;
---
> 	if (p_mpfcb->p_mpfinib->mpfatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_mpfcb->p_mpfinib->acvct.acptn4)) {
> 		ercd = E_OACV;
> 	}
> 	else {
> 		pk_rmpf->wtskid = wait_tskid(&(p_mpfcb->wait_queue));
> 		pk_rmpf->fblkcnt = p_mpfcb->fblkcnt;
> 		ercd = E_OK;
> 	}
diff -r ./kernel/mempfix.h extension/dcre/kernel/mempfix.h
8c8
<  *  Copyright (C) 2005-2015 by Embedded and Real-Time Systems Laboratory
---
>  *  Copyright (C) 2005-2018 by Embedded and Real-Time Systems Laboratory
40c40
<  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
---
>  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
112a113
> extern const ID	tmax_smpfid;
117a119
> extern MPFINIB			ampfinib_table[];
Only in ./kernel: mempfix.trb
diff -r ./kernel/messagebuf.c extension/dcre/kernel/messagebuf.c
40c40
<  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
---
>  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
48a49
> #include "domain.h"
57a59,82
> #ifndef LOG_ACRE_MBF_ENTER
> #define LOG_ACRE_MBF_ENTER(pk_cmbf)
> #endif /* LOG_ACRE_MBF_ENTER */
> 
> #ifndef LOG_ACRE_MBF_LEAVE
> #define LOG_ACRE_MBF_LEAVE(ercd)
> #endif /* LOG_ACRE_MBF_LEAVE */
> 
> #ifndef LOG_SAC_MBF_ENTER
> #define LOG_SAC_MBF_ENTER(mbfid, p_acvct)
> #endif /* LOG_SAC_MBF_ENTER */
> 
> #ifndef LOG_SAC_MBF_LEAVE
> #define LOG_SAC_MBF_LEAVE(ercd)
> #endif /* LOG_SAC_MBF_LEAVE */
> 
> #ifndef LOG_DEL_MBF_ENTER
> #define LOG_DEL_MBF_ENTER(mbfid)
> #endif /* LOG_DEL_MBF_ENTER */
> 
> #ifndef LOG_DEL_MBF_LEAVE
> #define LOG_DEL_MBF_LEAVE(ercd)
> #endif /* LOG_DEL_MBF_LEAVE */
> 
125a151
> #define tnum_smbf	((uint_t)(tmax_smbfid - TMIN_MBFID + 1))
138a165,173
> static void
> initialize_mbfcb(MBFCB *p_mbfcb, MBFINIB *p_mbfinib, const DOMINIB *p_dominib)
> {
> 	p_mbfinib->mbfatr = TA_NOEXS;
> 	p_mbfcb->p_mbfinib = (const MBFINIB *) p_mbfinib;
> 	queue_insert_prev(&(p_dominib->p_domcb->free_mbfcb),
> 										&(p_mbfcb->swait_queue));
> }
> 
142,143c177,180
< 	uint_t	i;
< 	MBFCB	*p_mbfcb;
---
> 	uint_t			i, j, k;
> 	ID				domid;
> 	MBFCB			*p_mbfcb;
> 	const DOMINIB	*p_dominib;
147c184
< 	for (i = 0; i < tnum_mbf; i++) {
---
> 	for (i = 0; i < tnum_smbf; i++) {
156a194,211
> 
> 	queue_initialize(&(dominib_kernel.p_domcb->free_mbfcb));
> 	for (j = 0; j < dominib_kernel.tnum_ambfid; i++, j++) {
> 		initialize_mbfcb(&(mbfcb_table[i]), &(ambfinib_table[j]),
> 													&dominib_kernel);
> 	}
> 	for (domid = TMIN_DOMID; domid <= tmax_domid; domid++) {
> 		p_dominib = get_dominib(domid);
> 		queue_initialize(&(p_dominib->p_domcb->free_mbfcb));
> 		for (k = 0; k < p_dominib->tnum_ambfid; i++, j++, k++) {
> 			initialize_mbfcb(&(mbfcb_table[i]), &(ambfinib_table[j]),
> 															p_dominib);
> 		}
> 	}
> 	for (k = 0; k < dominib_none.tnum_ambfid; i++, j++, k++) {
> 		initialize_mbfcb(&(mbfcb_table[i]), &(ambfinib_table[j]),
> 													&dominib_none);
> 	}
346a402,598
>  *  メッセージバッファの生成
>  */
> #ifdef TOPPERS_acre_mbf
> 
> ER_UINT
> acre_mbf(const T_CMBF *pk_cmbf)
> {
> 	MBFCB			*p_mbfcb;
> 	MBFINIB			*p_mbfinib;
> 	ATR				mbfatr;
> 	uint_t			maxmsz;
> 	size_t			mbfsz;
> 	void			*mbfmb;
> 	ID				domid;
> 	const DOMINIB	*p_dominib;
> 	ACPTN			acptn;
> 	ER				ercd;
> 
> 	LOG_ACRE_MBF_ENTER(pk_cmbf);
> 	CHECK_TSKCTX_UNL();
> 	CHECK_MACV_READ(pk_cmbf, T_CMBF);
> 
> 	mbfatr = pk_cmbf->mbfatr;
> 	maxmsz = pk_cmbf->maxmsz;
> 	mbfsz = pk_cmbf->mbfsz;
> 	mbfmb = pk_cmbf->mbfmb;
> 
> 	CHECK_VALIDATR(mbfatr, TA_TPRI|TA_DOMMASK);
> 	if (mbfmb != NULL) {
> 		CHECK_PAR(MB_ALIGN(mbfmb));
> 		CHECK_OBJ(valid_memobj_kernel(mbfmb, mbfsz));
> 	}
> 	domid = get_atrdomid(mbfatr);
> 	if (domid == TDOM_SELF) {
> 		if (rundom == TACP_KERNEL) {
> 			domid = TDOM_KERNEL;
> 		}
> 		else {
> 			domid = p_runtsk->p_tinib->domid;
> 		}
> 		mbfatr = set_atrdomid(mbfatr, domid);
> 	}
> 	switch (domid) {
> 	case TDOM_KERNEL:
> 		p_dominib = &dominib_kernel;
> 		break;
> 	case TDOM_NONE:
> 		p_dominib = &dominib_none;
> 		break;
> 	default:
> 		CHECK_RSATR(VALID_DOMID(domid));
> 		p_dominib = get_dominib(domid);
> 		break;
> 	}
> 	CHECK_ACPTN(p_dominib->acvct.acptn1);
> 
> 	lock_cpu();
> 	if (tnum_mbf == 0 || queue_empty(&(p_dominib->p_domcb->free_mbfcb))) {
> 		ercd = E_NOID;
> 	}
> 	else {
> 		if (mbfsz != 0 && mbfmb == NULL) {
> 			mbfmb = malloc_mpk(mbfsz, p_dominib);
> 			mbfatr |= TA_MBALLOC;
> 		}
> 		if (mbfsz != 0 && mbfmb == NULL) {
> 			ercd = E_NOMEM;
> 		}
> 		else {
> 			p_mbfcb = (MBFCB *)
> 						queue_delete_next(&(p_dominib->p_domcb->free_mbfcb));
> 			p_mbfinib = (MBFINIB *)(p_mbfcb->p_mbfinib);
> 			p_mbfinib->mbfatr = mbfatr;
> 			p_mbfinib->maxmsz = maxmsz;
> 			p_mbfinib->mbfsz = mbfsz;
> 			p_mbfinib->mbfmb = mbfmb;
> 
> 			acptn = default_acptn(domid);
> 			p_mbfinib->acvct.acptn1 = acptn;
> 			p_mbfinib->acvct.acptn2 = acptn;
> 			p_mbfinib->acvct.acptn3 = p_dominib->acvct.acptn1;
> 			p_mbfinib->acvct.acptn4 = acptn;
> 
> 			queue_initialize(&(p_mbfcb->swait_queue));
> 			queue_initialize(&(p_mbfcb->rwait_queue));
> 			p_mbfcb->fmbfsz = mbfsz;
> 			p_mbfcb->head = 0U;
> 			p_mbfcb->tail = 0U;
> 			p_mbfcb->smbfcnt = 0U;
> 			ercd = MBFID(p_mbfcb);
> 		}
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_ACRE_MBF_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_acre_mbf */
> 
> /*
>  *  メッセージバッファのアクセス許可ベクタの設定
>  */
> #ifdef TOPPERS_sac_mbf
> 
> ER
> sac_mbf(ID mbfid, const ACVCT *p_acvct)
> {
> 	MBFCB	*p_mbfcb;
> 	MBFINIB	*p_mbfinib;
> 	ER		ercd;
> 
> 	LOG_SAC_MBF_ENTER(mbfid, p_acvct);
> 	CHECK_TSKCTX_UNL();
> 	CHECK_ID(VALID_MBFID(mbfid));
> 	CHECK_MACV_READ(p_acvct, ACVCT);
> 	p_mbfcb = get_mbfcb(mbfid);
> 
> 	lock_cpu();
> 	if (p_mbfcb->p_mbfinib->mbfatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_mbfcb->p_mbfinib->acvct.acptn3)) {
> 		ercd = E_OACV;
> 	}
> 	else if (MBFID(p_mbfcb) <= tmax_smbfid) {
> 		ercd = E_OBJ;
> 	}
> 	else {
> 		p_mbfinib = (MBFINIB *)(p_mbfcb->p_mbfinib);
> 		p_mbfinib->acvct = *p_acvct;
> 		ercd = E_OK;
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_SAC_MBF_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_sac_mbf */
> 
> /*
>  *  メッセージバッファの削除
>  */
> #ifdef TOPPERS_del_mbf
> 
> ER
> del_mbf(ID mbfid)
> {
> 	MBFCB			*p_mbfcb;
> 	MBFINIB			*p_mbfinib;
> 	const DOMINIB	*p_dominib;
> 	ER				ercd;
> 
> 	LOG_DEL_MBF_ENTER(mbfid);
> 	CHECK_TSKCTX_UNL();
> 	CHECK_ID(VALID_MBFID(mbfid));
> 	p_mbfcb = get_mbfcb(mbfid);
> 
> 	lock_cpu();
> 	if (p_mbfcb->p_mbfinib->mbfatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_mbfcb->p_mbfinib->acvct.acptn3)) {
> 		ercd = E_OACV;
> 	}
> 	else if (MBFID(p_mbfcb) <= tmax_smbfid) {
> 		ercd = E_OBJ;
> 	}
> 	else {
> 		init_wait_queue(&(p_mbfcb->swait_queue));
> 		init_wait_queue(&(p_mbfcb->rwait_queue));
> 		p_mbfinib = (MBFINIB *)(p_mbfcb->p_mbfinib);
> 		p_dominib = get_atrdominib(p_mbfinib->mbfatr);
> 		if ((p_mbfinib->mbfatr & TA_MBALLOC) != 0U) {
> 			free_mpk(p_mbfinib->mbfmb, p_dominib);
> 		}
> 		p_mbfinib->mbfatr = TA_NOEXS;
> 		queue_insert_prev(&(p_dominib->p_domcb->free_mbfcb),
> 										&(p_mbfcb->swait_queue));
> 		if (p_runtsk != p_schedtsk) {
> 			dispatch();
> 		}
> 		ercd = E_OK;
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_DEL_MBF_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_del_mbf */
> 
> /*
361a614
> 	CHECK_PAR(0 < msgsz);
363,364d615
< 	CHECK_ACPTN(p_mbfcb->p_mbfinib->acvct.acptn1);
< 	CHECK_PAR(0 < msgsz && msgsz <= p_mbfcb->p_mbfinib->maxmsz);
367c618,627
< 	if (p_runtsk->raster) {
---
> 	if (p_mbfcb->p_mbfinib->mbfatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_mbfcb->p_mbfinib->acvct.acptn1)) {
> 		ercd = E_OACV;
> 	}
> 	else if (!(msgsz <= p_mbfcb->p_mbfinib->maxmsz)) {
> 		ercd = E_PAR;
> 	}
> 	else if (p_runtsk->raster) {
407a668
> 	CHECK_PAR(0 < msgsz);
409,410d669
< 	CHECK_ACPTN(p_mbfcb->p_mbfinib->acvct.acptn1);
< 	CHECK_PAR(0 < msgsz && msgsz <= p_mbfcb->p_mbfinib->maxmsz);
413c672,681
< 	if (send_message(p_mbfcb, msg, msgsz)) {
---
> 	if (p_mbfcb->p_mbfinib->mbfatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_mbfcb->p_mbfinib->acvct.acptn1)) {
> 		ercd = E_OACV;
> 	}
> 	else if (!(msgsz <= p_mbfcb->p_mbfinib->maxmsz)) {
> 		ercd = E_PAR;
> 	}
> 	else if (send_message(p_mbfcb, msg, msgsz)) {
448a717
> 	CHECK_PAR(0 < msgsz);
450,451d718
< 	CHECK_ACPTN(p_mbfcb->p_mbfinib->acvct.acptn1);
< 	CHECK_PAR(0 < msgsz && msgsz <= p_mbfcb->p_mbfinib->maxmsz);
454c721,730
< 	if (p_runtsk->raster) {
---
> 	if (p_mbfcb->p_mbfinib->mbfatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_mbfcb->p_mbfinib->acvct.acptn1)) {
> 		ercd = E_OACV;
> 	}
> 	else if (!(msgsz <= p_mbfcb->p_mbfinib->maxmsz)) {
> 		ercd = E_PAR;
> 	}
> 	else if (p_runtsk->raster) {
500,501d775
< 	CHECK_ACPTN(p_mbfcb->p_mbfinib->acvct.acptn2);
< 	CHECK_MACV_BUF_WRITE(msg, p_mbfcb->p_mbfinib->maxmsz);
504c778,787
< 	if (p_runtsk->raster) {
---
> 	if (p_mbfcb->p_mbfinib->mbfatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_mbfcb->p_mbfinib->acvct.acptn2)) {
> 		ercd = E_OACV;
> 	}
> 	else if (!KERNEL_PROBE_BUF_WRITE(msg, p_mbfcb->p_mbfinib->maxmsz)) {
> 		ercd = E_MACV;
> 	}
> 	else if (p_runtsk->raster) {
547,548d829
< 	CHECK_ACPTN(p_mbfcb->p_mbfinib->acvct.acptn2);
< 	CHECK_MACV_BUF_WRITE(msg, p_mbfcb->p_mbfinib->maxmsz);
551c832,841
< 	if ((msgsz = receive_message(p_mbfcb, msg)) > 0U) {
---
> 	if (p_mbfcb->p_mbfinib->mbfatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_mbfcb->p_mbfinib->acvct.acptn2)) {
> 		ercd = E_OACV;
> 	}
> 	else if (!KERNEL_PROBE_BUF_WRITE(msg, p_mbfcb->p_mbfinib->maxmsz)) {
> 		ercd = E_MACV;
> 	}
> 	else if ((msgsz = receive_message(p_mbfcb, msg)) > 0U) {
588,589d877
< 	CHECK_ACPTN(p_mbfcb->p_mbfinib->acvct.acptn2);
< 	CHECK_MACV_BUF_WRITE(msg, p_mbfcb->p_mbfinib->maxmsz);
592c880,889
< 	if (p_runtsk->raster) {
---
> 	if (p_mbfcb->p_mbfinib->mbfatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_mbfcb->p_mbfinib->acvct.acptn2)) {
> 		ercd = E_OACV;
> 	}
> 	else if (!KERNEL_PROBE_BUF_WRITE(msg, p_mbfcb->p_mbfinib->maxmsz)) {
> 		ercd = E_MACV;
> 	}
> 	else if (p_runtsk->raster) {
637d933
< 	CHECK_ACPTN(p_mbfcb->p_mbfinib->acvct.acptn3);
640,647c936,952
< 	init_wait_queue(&(p_mbfcb->swait_queue));
< 	init_wait_queue(&(p_mbfcb->rwait_queue));
< 	p_mbfcb->fmbfsz = p_mbfcb->p_mbfinib->mbfsz;
< 	p_mbfcb->head = 0U;
< 	p_mbfcb->tail = 0U;
< 	p_mbfcb->smbfcnt = 0U;
< 	if (p_runtsk != p_schedtsk) {
< 		dispatch();
---
> 	if (p_mbfcb->p_mbfinib->mbfatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_mbfcb->p_mbfinib->acvct.acptn3)) {
> 		ercd = E_OACV;
> 	}
> 	else {
> 		init_wait_queue(&(p_mbfcb->swait_queue));
> 		init_wait_queue(&(p_mbfcb->rwait_queue));
> 		p_mbfcb->fmbfsz = p_mbfcb->p_mbfinib->mbfsz;
> 		p_mbfcb->head = 0U;
> 		p_mbfcb->tail = 0U;
> 		p_mbfcb->smbfcnt = 0U;
> 		if (p_runtsk != p_schedtsk) {
> 			dispatch();
> 		}
> 		ercd = E_OK;
649d953
< 	ercd = E_OK;
675d978
< 	CHECK_ACPTN(p_mbfcb->p_mbfinib->acvct.acptn4);
678,682c981,993
< 	pk_rmbf->stskid = wait_tskid(&(p_mbfcb->swait_queue));
< 	pk_rmbf->rtskid = wait_tskid(&(p_mbfcb->rwait_queue));
< 	pk_rmbf->smbfcnt = p_mbfcb->smbfcnt;
< 	pk_rmbf->fmbfsz = p_mbfcb->fmbfsz;
< 	ercd = E_OK;
---
> 	if (p_mbfcb->p_mbfinib->mbfatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_mbfcb->p_mbfinib->acvct.acptn4)) {
> 		ercd = E_OACV;
> 	}
> 	else {
> 		pk_rmbf->stskid = wait_tskid(&(p_mbfcb->swait_queue));
> 		pk_rmbf->rtskid = wait_tskid(&(p_mbfcb->rwait_queue));
> 		pk_rmbf->smbfcnt = p_mbfcb->smbfcnt;
> 		pk_rmbf->fmbfsz = p_mbfcb->fmbfsz;
> 		ercd = E_OK;
> 	}
diff -r ./kernel/messagebuf.h extension/dcre/kernel/messagebuf.h
8c8
<  *  Copyright (C) 2005-2016 by Embedded and Real-Time Systems Laboratory
---
>  *  Copyright (C) 2005-2018 by Embedded and Real-Time Systems Laboratory
109a110
> extern const ID	tmax_smbfid;
114a116
> extern MBFINIB			ambfinib_table[];
Only in ./kernel: messagebuf.trb
diff -r ./kernel/mutex.c extension/dcre/kernel/mutex.c
46a47
> #include "domain.h"
54a56,79
> #ifndef LOG_ACRE_MTX_ENTER
> #define LOG_ACRE_MTX_ENTER(pk_cmtx)
> #endif /* LOG_ACRE_MTX_ENTER */
> 
> #ifndef LOG_ACRE_MTX_LEAVE
> #define LOG_ACRE_MTX_LEAVE(ercd)
> #endif /* LOG_ACRE_MTX_LEAVE */
> 
> #ifndef LOG_SAC_MTX_ENTER
> #define LOG_SAC_MTX_ENTER(mtxid, p_acvct)
> #endif /* LOG_SAC_MTX_ENTER */
> 
> #ifndef LOG_SAC_MTX_LEAVE
> #define LOG_SAC_MTX_LEAVE(ercd)
> #endif /* LOG_SAC_MTX_LEAVE */
> 
> #ifndef LOG_DEL_MTX_ENTER
> #define LOG_DEL_MTX_ENTER(mtxid)
> #endif /* LOG_DEL_MTX_ENTER */
> 
> #ifndef LOG_DEL_MTX_LEAVE
> #define LOG_DEL_MTX_LEAVE(ercd)
> #endif /* LOG_DEL_MTX_LEAVE */
> 
106a132
> #define tnum_smtx	((uint_t)(tmax_smtxid - TMIN_MTXID + 1))
125a152,160
> static void
> initialize_mtxcb(MTXCB *p_mtxcb, MTXINIB *p_mtxinib, const DOMINIB *p_dominib)
> {
> 	p_mtxinib->mtxatr = TA_NOEXS;
> 	p_mtxcb->p_mtxinib = (const MTXINIB *) p_mtxinib;
> 	queue_insert_prev(&(p_dominib->p_domcb->free_mtxcb),
> 										&(p_mtxcb->wait_queue));
> }
> 
129,130c164,167
< 	uint_t	i;
< 	MTXCB	*p_mtxcb;
---
> 	uint_t			i, j, k;
> 	ID				domid;
> 	MTXCB			*p_mtxcb;
> 	const DOMINIB	*p_dominib;
136c173
< 	for (i = 0; i < tnum_mtx; i++) {
---
> 	for (i = 0; i < tnum_smtx; i++) {
141a179,196
> 
> 	queue_initialize(&(dominib_kernel.p_domcb->free_mtxcb));
> 	for (j = 0; j < dominib_kernel.tnum_amtxid; i++, j++) {
> 		initialize_mtxcb(&(mtxcb_table[i]), &(amtxinib_table[j]),
> 													&dominib_kernel);
> 	}
> 	for (domid = TMIN_DOMID; domid <= tmax_domid; domid++) {
> 		p_dominib = get_dominib(domid);
> 		queue_initialize(&(p_dominib->p_domcb->free_mtxcb));
> 		for (k = 0; k < p_dominib->tnum_amtxid; i++, j++, k++) {
> 			initialize_mtxcb(&(mtxcb_table[i]), &(amtxinib_table[j]),
> 															p_dominib);
> 		}
> 	}
> 	for (k = 0; k < dominib_none.tnum_amtxid; i++, j++, k++) {
> 		initialize_mtxcb(&(mtxcb_table[i]), &(amtxinib_table[j]),
> 													&dominib_none);
> 	}
325a381,556
>  *  ミューテックスの生成
>  */
> #ifdef TOPPERS_acre_mtx
> 
> ER_UINT
> acre_mtx(const T_CMTX *pk_cmtx)
> {
> 	MTXCB			*p_mtxcb;
> 	MTXINIB			*p_mtxinib;
> 	ATR				mtxatr;
> 	PRI				ceilpri;
> 	ID				domid;
> 	const DOMINIB	*p_dominib;
> 	ACPTN			acptn;
> 	ER				ercd;
> 
> 	LOG_ACRE_MTX_ENTER(pk_cmtx);
> 	CHECK_TSKCTX_UNL();
> 	CHECK_MACV_READ(pk_cmtx, T_CMTX);
> 
> 	mtxatr = pk_cmtx->mtxatr;
> 	ceilpri = pk_cmtx->ceilpri;
> 
> 	if ((mtxatr & MTXPROTO_MASK) == TA_CEILING) {
> 		CHECK_VALIDATR(mtxatr, TA_CEILING|TA_DOMMASK);
> 		CHECK_PAR(VALID_TPRI(ceilpri));
> 	}
> 	else {
> 		CHECK_VALIDATR(pk_cmtx->mtxatr, TA_TPRI|TA_DOMMASK);
> 	}
> 	domid = get_atrdomid(mtxatr);
> 	if (domid == TDOM_SELF) {
> 		if (rundom == TACP_KERNEL) {
> 			domid = TDOM_KERNEL;
> 		}
> 		else {
> 			domid = p_runtsk->p_tinib->domid;
> 		}
> 		mtxatr = set_atrdomid(mtxatr, domid);
> 	}
> 	switch (domid) {
> 	case TDOM_KERNEL:
> 		p_dominib = &dominib_kernel;
> 		break;
> 	case TDOM_NONE:
> 		p_dominib = &dominib_none;
> 		break;
> 	default:
> 		CHECK_RSATR(VALID_DOMID(domid));
> 		p_dominib = get_dominib(domid);
> 		break;
> 	}
> 	CHECK_ACPTN(p_dominib->acvct.acptn1);
> 
> 	lock_cpu();
> 	if (tnum_mtx == 0 || queue_empty(&(p_dominib->p_domcb->free_mtxcb))) {
> 		ercd = E_NOID;
> 	}
> 	else {
> 		p_mtxcb = (MTXCB *)
> 					queue_delete_next(&(p_dominib->p_domcb->free_mtxcb));
> 		p_mtxinib = (MTXINIB *)(p_mtxcb->p_mtxinib);
> 		p_mtxinib->mtxatr = mtxatr;
> 		p_mtxinib->ceilpri = INT_PRIORITY(ceilpri);
> 
> 		acptn = default_acptn(domid);
> 		p_mtxinib->acvct.acptn1 = acptn;
> 		p_mtxinib->acvct.acptn2 = acptn;
> 		p_mtxinib->acvct.acptn3 = p_dominib->acvct.acptn1;
> 		p_mtxinib->acvct.acptn4 = acptn;
> 
> 		queue_initialize(&(p_mtxcb->wait_queue));
> 		p_mtxcb->p_loctsk = NULL;
> 		ercd = MTXID(p_mtxcb);
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_ACRE_MTX_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_acre_mtx */
> 
> /*
>  *  ミューテックスのアクセス許可ベクタの設定
>  */
> #ifdef TOPPERS_sac_mtx
> 
> ER
> sac_mtx(ID mtxid, const ACVCT *p_acvct)
> {
> 	MTXCB	*p_mtxcb;
> 	MTXINIB	*p_mtxinib;
> 	ER		ercd;
> 
> 	LOG_SAC_MTX_ENTER(mtxid, p_acvct);
> 	CHECK_TSKCTX_UNL();
> 	CHECK_ID(VALID_MTXID(mtxid));
> 	CHECK_MACV_READ(p_acvct, ACVCT);
> 	p_mtxcb = get_mtxcb(mtxid);
> 
> 	lock_cpu();
> 	if (p_mtxcb->p_mtxinib->mtxatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_mtxcb->p_mtxinib->acvct.acptn3)) {
> 		ercd = E_OACV;
> 	}
> 	else if (MTXID(p_mtxcb) <= tmax_smtxid) {
> 		ercd = E_OBJ;
> 	}
> 	else {
> 		p_mtxinib = (MTXINIB *)(p_mtxcb->p_mtxinib);
> 		p_mtxinib->acvct = *p_acvct;
> 		ercd = E_OK;
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_SAC_MTX_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_sac_mtx */
> 
> /*
>  *  ミューテックスの削除
>  */
> #ifdef TOPPERS_del_mtx
> 
> ER
> del_mtx(ID mtxid)
> {
> 	MTXCB			*p_mtxcb;
> 	MTXINIB			*p_mtxinib;
> 	const DOMINIB	*p_dominib;
> 	ER				ercd;
> 
> 	LOG_DEL_MTX_ENTER(mtxid);
> 	CHECK_TSKCTX_UNL();
> 	CHECK_ID(VALID_MTXID(mtxid));
> 	p_mtxcb = get_mtxcb(mtxid);
> 
> 	lock_cpu();
> 	if (p_mtxcb->p_mtxinib->mtxatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_mtxcb->p_mtxinib->acvct.acptn3)) {
> 		ercd = E_OACV;
> 	}
> 	else if (MTXID(p_mtxcb) <= tmax_smtxid) {
> 		ercd = E_OBJ;
> 	}
> 	else {
> 		init_wait_queue(&(p_mtxcb->wait_queue));
> 		p_mtxinib = (MTXINIB *)(p_mtxcb->p_mtxinib);
> 		p_dominib = get_atrdominib(p_mtxinib->mtxatr);
> 		p_mtxinib->mtxatr = TA_NOEXS;
> 		queue_insert_prev(&(p_dominib->p_domcb->free_mtxcb),
> 										&(p_mtxcb->wait_queue));
> 		if (p_runtsk != p_schedtsk) {
> 			dispatch();
> 		}
> 		ercd = E_OK;
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_DEL_MTX_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_del_mtx */
> 
> /*
341d571
< 	CHECK_ACPTN(p_mtxcb->p_mtxinib->acvct.acptn1);
344c574,580
< 	if (p_runtsk->raster) {
---
> 	if (p_mtxcb->p_mtxinib->mtxatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_mtxcb->p_mtxinib->acvct.acptn1)) {
> 		ercd = E_OACV;
> 	}
> 	else if (p_runtsk->raster) {
393d628
< 	CHECK_ACPTN(p_mtxcb->p_mtxinib->acvct.acptn1);
396c631,637
< 	if (MTX_CEILING(p_mtxcb)
---
> 	if (p_mtxcb->p_mtxinib->mtxatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_mtxcb->p_mtxinib->acvct.acptn1)) {
> 		ercd = E_OACV;
> 	}
> 	else if (MTX_CEILING(p_mtxcb)
442d682
< 	CHECK_ACPTN(p_mtxcb->p_mtxinib->acvct.acptn1);
445c685,691
< 	if (p_runtsk->raster) {
---
> 	if (p_mtxcb->p_mtxinib->mtxatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_mtxcb->p_mtxinib->acvct.acptn1)) {
> 		ercd = E_OACV;
> 	}
> 	else if (p_runtsk->raster) {
497d742
< 	CHECK_ACPTN(p_mtxcb->p_mtxinib->acvct.acptn1);
500c745,751
< 	if (p_mtxcb != p_runtsk->p_lastmtx) {
---
> 	if (p_mtxcb->p_mtxinib->mtxatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_mtxcb->p_mtxinib->acvct.acptn1)) {
> 		ercd = E_OACV;
> 	}
> 	else if (p_mtxcb != p_runtsk->p_lastmtx) {
537d787
< 	CHECK_ACPTN(p_mtxcb->p_mtxinib->acvct.acptn3);
540,548c790,807
< 	init_wait_queue(&(p_mtxcb->wait_queue));
< 	p_loctsk = p_mtxcb->p_loctsk;
< 	if (p_loctsk != NULL) {
< 		p_mtxcb->p_loctsk = NULL;
< 		pp_prevmtx = &(p_loctsk->p_lastmtx);
< 		while (*pp_prevmtx != NULL) {
< 			if (*pp_prevmtx == p_mtxcb) {
< 				*pp_prevmtx = p_mtxcb->p_prevmtx;
< 				break;
---
> 	if (p_mtxcb->p_mtxinib->mtxatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_mtxcb->p_mtxinib->acvct.acptn3)) {
> 		ercd = E_OACV;
> 	}
> 	else {
> 		init_wait_queue(&(p_mtxcb->wait_queue));
> 		p_loctsk = p_mtxcb->p_loctsk;
> 		if (p_loctsk != NULL) {
> 			p_mtxcb->p_loctsk = NULL;
> 			pp_prevmtx = &(p_loctsk->p_lastmtx);
> 			while (*pp_prevmtx != NULL) {
> 				if (*pp_prevmtx == p_mtxcb) {
> 					*pp_prevmtx = p_mtxcb->p_prevmtx;
> 					break;
> 				}
> 				pp_prevmtx = &((*pp_prevmtx)->p_prevmtx);
550c809
< 			pp_prevmtx = &((*pp_prevmtx)->p_prevmtx);
---
> 			mutex_drop_priority(p_loctsk, p_mtxcb);
552,555c811,814
< 		mutex_drop_priority(p_loctsk, p_mtxcb);
< 	}
< 	if (p_runtsk != p_schedtsk) {
< 		dispatch();
---
> 		if (p_runtsk != p_schedtsk) {
> 			dispatch();
> 		}
> 		ercd = E_OK;
557d815
< 	ercd = E_OK;
583d840
< 	CHECK_ACPTN(p_mtxcb->p_mtxinib->acvct.acptn4);
586,589c843,855
< 	pk_rmtx->htskid = (p_mtxcb->p_loctsk != NULL) ? TSKID(p_mtxcb->p_loctsk)
< 													: TSK_NONE;
< 	pk_rmtx->wtskid = wait_tskid(&(p_mtxcb->wait_queue));
< 	ercd = E_OK;
---
> 	if (p_mtxcb->p_mtxinib->mtxatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_mtxcb->p_mtxinib->acvct.acptn4)) {
> 		ercd = E_OACV;
> 	}
> 	else {
> 		pk_rmtx->htskid = (p_mtxcb->p_loctsk != NULL) ?
> 								TSKID(p_mtxcb->p_loctsk) : TSK_NONE;
> 														
> 		pk_rmtx->wtskid = wait_tskid(&(p_mtxcb->wait_queue));
> 		ercd = E_OK;
> 	}
diff -r ./kernel/mutex.h extension/dcre/kernel/mutex.h
6c6
<  *  Copyright (C) 2005-2015 by Embedded and Real-Time Systems Laboratory
---
>  *  Copyright (C) 2005-2018 by Embedded and Real-Time Systems Laboratory
38c38
<  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
---
>  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
94a95
> extern const ID	tmax_smtxid;
99a101
> extern MTXINIB			amtxinib_table[];
Only in ./kernel: mutex.trb
diff -r ./kernel/pridataq.c extension/dcre/kernel/pridataq.c
8c8
<  *  Copyright (C) 2005-2018 by Embedded and Real-Time Systems Laboratory
---
>  *  Copyright (C) 2005-2019 by Embedded and Real-Time Systems Laboratory
40c40
<  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
---
>  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
48a49
> #include "domain.h"
55a57,80
> #ifndef LOG_ACRE_PDQ_ENTER
> #define LOG_ACRE_PDQ_ENTER(pk_cpdq)
> #endif /* LOG_ACRE_PDQ_ENTER */
> 
> #ifndef LOG_ACRE_PDQ_LEAVE
> #define LOG_ACRE_PDQ_LEAVE(ercd)
> #endif /* LOG_ACRE_PDQ_LEAVE */
> 
> #ifndef LOG_SAC_PDQ_ENTER
> #define LOG_SAC_PDQ_ENTER(pdqid, p_acvct)
> #endif /* LOG_SAC_PDQ_ENTER */
> 
> #ifndef LOG_SAC_PDQ_LEAVE
> #define LOG_SAC_PDQ_LEAVE(ercd)
> #endif /* LOG_SAC_PDQ_LEAVE */
> 
> #ifndef LOG_DEL_PDQ_ENTER
> #define LOG_DEL_PDQ_ENTER(pdqid)
> #endif /* LOG_DEL_PDQ_ENTER */
> 
> #ifndef LOG_DEL_PDQ_LEAVE
> #define LOG_DEL_PDQ_LEAVE(ercd)
> #endif /* LOG_DEL_PDQ_LEAVE */
> 
123a149
> #define tnum_spdq	((uint_t)(tmax_spdqid - TMIN_PDQID + 1))
136a163,171
> static void
> initialize_pdqcb(PDQCB *p_pdqcb, PDQINIB *p_pdqinib, const DOMINIB *p_dominib)
> {
> 	p_pdqinib->pdqatr = TA_NOEXS;
> 	p_pdqcb->p_pdqinib = (const PDQINIB *) p_pdqinib;
> 	queue_insert_prev(&(p_dominib->p_domcb->free_pdqcb),
> 										&(p_pdqcb->swait_queue));
> }
> 
140,141c175,178
< 	uint_t	i;
< 	PDQCB	*p_pdqcb;
---
> 	uint_t			i, j, k;
> 	ID				domid;
> 	PDQCB			*p_pdqcb;
> 	const DOMINIB	*p_dominib;
143c180
< 	for (i = 0; i < tnum_pdq; i++) {
---
> 	for (i = 0; i < tnum_spdq; i++) {
152a190,207
> 
> 	queue_initialize(&(dominib_kernel.p_domcb->free_pdqcb));
> 	for (j = 0; j < dominib_kernel.tnum_apdqid; i++, j++) {
> 		initialize_pdqcb(&(pdqcb_table[i]), &(apdqinib_table[j]),
> 													&dominib_kernel);
> 	}
> 	for (domid = TMIN_DOMID; domid <= tmax_domid; domid++) {
> 		p_dominib = get_dominib(domid);
> 		queue_initialize(&(p_dominib->p_domcb->free_pdqcb));
> 		for (k = 0; k < p_dominib->tnum_apdqid; i++, j++, k++) {
> 			initialize_pdqcb(&(pdqcb_table[i]), &(apdqinib_table[j]),
> 															p_dominib);
> 		}
> 	}
> 	for (k = 0; k < dominib_none.tnum_apdqid; i++, j++, k++) {
> 		initialize_pdqcb(&(pdqcb_table[i]), &(apdqinib_table[j]),
> 													&dominib_none);
> 	}
282a338,532
>  *  優先度データキューの生成
>  */
> #ifdef TOPPERS_acre_pdq
> 
> ER_UINT
> acre_pdq(const T_CPDQ *pk_cpdq)
> {
> 	PDQCB			*p_pdqcb;
> 	PDQINIB			*p_pdqinib;
> 	ATR				pdqatr;
> 	uint_t			pdqcnt;
> 	PRI				maxdpri;
> 	PDQMB			*p_pdqmb;
> 	ID				domid;
> 	const DOMINIB	*p_dominib;
> 	ACPTN			acptn;
> 	ER				ercd;
> 
> 	LOG_ACRE_PDQ_ENTER(pk_cpdq);
> 	CHECK_TSKCTX_UNL();
> 	CHECK_MACV_READ(pk_cpdq, T_CPDQ);
> 
> 	pdqatr = pk_cpdq->pdqatr;
> 	pdqcnt = pk_cpdq->pdqcnt;
> 	maxdpri = pk_cpdq->maxdpri;
> 	p_pdqmb = pk_cpdq->pdqmb;
> 
> 	CHECK_VALIDATR(pdqatr, TA_TPRI|TA_DOMMASK);
> 	CHECK_PAR(VALID_DPRI(maxdpri));
> 	if (p_pdqmb != NULL) {
> 		CHECK_PAR(MB_ALIGN(p_pdqmb));
> 		CHECK_OBJ(valid_memobj_kernel(p_pdqmb, sizeof(PDQMB) * pdqcnt));
> 	}
> 	domid = get_atrdomid(pdqatr);
> 	if (domid == TDOM_SELF) {
> 		if (rundom == TACP_KERNEL) {
> 			domid = TDOM_KERNEL;
> 		}
> 		else {
> 			domid = p_runtsk->p_tinib->domid;
> 		}
> 		pdqatr = set_atrdomid(pdqatr, domid);
> 	}
> 	switch (domid) {
> 	case TDOM_KERNEL:
> 		p_dominib = &dominib_kernel;
> 		break;
> 	case TDOM_NONE:
> 		p_dominib = &dominib_none;
> 		break;
> 	default:
> 		CHECK_RSATR(VALID_DOMID(domid));
> 		p_dominib = get_dominib(domid);
> 		break;
> 	}
> 	CHECK_ACPTN(p_dominib->acvct.acptn1);
> 
> 	lock_cpu();
> 	if (tnum_pdq == 0 || queue_empty(&(p_dominib->p_domcb->free_pdqcb))) {
> 		ercd = E_NOID;
> 	}
> 	else {
> 		if (pdqcnt != 0 && p_pdqmb == NULL) {
> 			p_pdqmb = malloc_mpk(sizeof(PDQMB) * pdqcnt, p_dominib);
> 			pdqatr |= TA_MBALLOC;
> 		}
> 		if (pdqcnt != 0 && p_pdqmb == NULL) {
> 			ercd = E_NOMEM;
> 		}
> 		else {
> 			p_pdqcb = (PDQCB *)
> 						queue_delete_next(&(p_dominib->p_domcb->free_pdqcb));
> 			p_pdqinib = (PDQINIB *)(p_pdqcb->p_pdqinib);
> 			p_pdqinib->pdqatr = pdqatr;
> 			p_pdqinib->pdqcnt = pdqcnt;
> 			p_pdqinib->maxdpri = maxdpri;
> 			p_pdqinib->p_pdqmb = p_pdqmb;
> 
> 			acptn = default_acptn(domid);
> 			p_pdqinib->acvct.acptn1 = acptn;
> 			p_pdqinib->acvct.acptn2 = acptn;
> 			p_pdqinib->acvct.acptn3 = p_dominib->acvct.acptn1;
> 			p_pdqinib->acvct.acptn4 = acptn;
> 
> 			queue_initialize(&(p_pdqcb->swait_queue));
> 			queue_initialize(&(p_pdqcb->rwait_queue));
> 			p_pdqcb->count = 0U;
> 			p_pdqcb->p_head = NULL;
> 			p_pdqcb->unused = 0U;
> 			p_pdqcb->p_freelist = NULL;
> 			ercd = PDQID(p_pdqcb);
> 		}
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_ACRE_PDQ_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_acre_pdq */
> 
> /*
>  *  優先度データキューのアクセス許可ベクタの設定
>  */
> #ifdef TOPPERS_sac_pdq
> 
> ER
> sac_pdq(ID pdqid, const ACVCT *p_acvct)
> {
> 	PDQCB	*p_pdqcb;
> 	PDQINIB	*p_pdqinib;
> 	ER		ercd;
> 
> 	LOG_SAC_PDQ_ENTER(pdqid, p_acvct);
> 	CHECK_TSKCTX_UNL();
> 	CHECK_ID(VALID_PDQID(pdqid));
> 	CHECK_MACV_READ(p_acvct, ACVCT);
> 	p_pdqcb = get_pdqcb(pdqid);
> 
> 	lock_cpu();
> 	if (p_pdqcb->p_pdqinib->pdqatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_pdqcb->p_pdqinib->acvct.acptn3)) {
> 		ercd = E_OACV;
> 	}
> 	else if (PDQID(p_pdqcb) <= tmax_spdqid) {
> 		ercd = E_OBJ;
> 	}
> 	else {
> 		p_pdqinib = (PDQINIB *)(p_pdqcb->p_pdqinib);
> 		p_pdqinib->acvct = *p_acvct;
> 		ercd = E_OK;
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_SAC_PDQ_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_sac_pdq */
> 
> /*
>  *  優先度データキューの削除
>  */
> #ifdef TOPPERS_del_pdq
> 
> ER
> del_pdq(ID pdqid)
> {
> 	PDQCB			*p_pdqcb;
> 	PDQINIB			*p_pdqinib;
> 	const DOMINIB	*p_dominib;
> 	ER				ercd;
> 
> 	LOG_DEL_PDQ_ENTER(pdqid);
> 	CHECK_TSKCTX_UNL();
> 	CHECK_ID(VALID_PDQID(pdqid));
> 	p_pdqcb = get_pdqcb(pdqid);
> 
> 	lock_cpu();
> 	if (p_pdqcb->p_pdqinib->pdqatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_pdqcb->p_pdqinib->acvct.acptn3)) {
> 		ercd = E_OACV;
> 	}
> 	else if (PDQID(p_pdqcb) <= tmax_spdqid) {
> 		ercd = E_OBJ;
> 	}
> 	else {
> 		init_wait_queue(&(p_pdqcb->swait_queue));
> 		init_wait_queue(&(p_pdqcb->rwait_queue));
> 		p_pdqinib = (PDQINIB *)(p_pdqcb->p_pdqinib);
> 		p_dominib = get_atrdominib(p_pdqinib->pdqatr);
> 		p_pdqinib->pdqatr = TA_NOEXS;
> 		queue_insert_prev(&(p_dominib->p_domcb->free_pdqcb),
> 										&(p_pdqcb->swait_queue));
> 		if (p_runtsk != p_schedtsk) {
> 			dispatch();
> 		}
> 		ercd = E_OK;
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_DEL_PDQ_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_del_pdq */
> 
> /*
296a547
> 	CHECK_PAR(TMIN_DPRI <= datapri);
298,299d548
< 	CHECK_ACPTN(p_pdqcb->p_pdqinib->acvct.acptn1);
< 	CHECK_PAR(TMIN_DPRI <= datapri && datapri <= p_pdqcb->p_pdqinib->maxdpri);
302c551,560
< 	if (p_runtsk->raster) {
---
> 	if (p_pdqcb->p_pdqinib->pdqatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_pdqcb->p_pdqinib->acvct.acptn1)) {
> 		ercd = E_OACV;
> 	}
> 	else if (!(datapri <= p_pdqcb->p_pdqinib->maxdpri)) {
> 		ercd = E_PAR;
> 	}
> 	else if (p_runtsk->raster) {
341a600
> 	CHECK_PAR(TMIN_DPRI <= datapri);
343,344d601
< 	CHECK_ACPTN(p_pdqcb->p_pdqinib->acvct.acptn1);
< 	CHECK_PAR(TMIN_DPRI <= datapri && datapri <= p_pdqcb->p_pdqinib->maxdpri);
347c604,613
< 	if (send_pridata(p_pdqcb, data, datapri)) {
---
> 	if (p_pdqcb->p_pdqinib->pdqatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_pdqcb->p_pdqinib->acvct.acptn1)) {
> 		ercd = E_OACV;
> 	}
> 	else if (!(datapri <= p_pdqcb->p_pdqinib->maxdpri)) {
> 		ercd = E_PAR;
> 	}
> 	else if (send_pridata(p_pdqcb, data, datapri)) {
385a652
> 	CHECK_PAR(TMIN_DPRI <= datapri);
388,389d654
< 	CHECK_ACPTN(p_pdqcb->p_pdqinib->acvct.acptn1);
< 	CHECK_PAR(TMIN_DPRI <= datapri && datapri <= p_pdqcb->p_pdqinib->maxdpri);
392c657,666
< 	if (p_runtsk->raster) {
---
> 	if (p_pdqcb->p_pdqinib->pdqatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_pdqcb->p_pdqinib->acvct.acptn1)) {
> 		ercd = E_OACV;
> 	}
> 	else if (!(datapri <= p_pdqcb->p_pdqinib->maxdpri)) {
> 		ercd = E_PAR;
> 	}
> 	else if (p_runtsk->raster) {
439d712
< 	CHECK_ACPTN(p_pdqcb->p_pdqinib->acvct.acptn2);
442c715,721
< 	if (p_runtsk->raster) {
---
> 	if (p_pdqcb->p_pdqinib->pdqatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_pdqcb->p_pdqinib->acvct.acptn2)) {
> 		ercd = E_OACV;
> 	}
> 	else if (p_runtsk->raster) {
489d767
< 	CHECK_ACPTN(p_pdqcb->p_pdqinib->acvct.acptn2);
492c770,776
< 	if (receive_pridata(p_pdqcb, p_data, p_datapri)) {
---
> 	if (p_pdqcb->p_pdqinib->pdqatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_pdqcb->p_pdqinib->acvct.acptn2)) {
> 		ercd = E_OACV;
> 	}
> 	else if (receive_pridata(p_pdqcb, p_data, p_datapri)) {
530d813
< 	CHECK_ACPTN(p_pdqcb->p_pdqinib->acvct.acptn2);
533c816,822
< 	if (p_runtsk->raster) {
---
> 	if (p_pdqcb->p_pdqinib->pdqatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_pdqcb->p_pdqinib->acvct.acptn2)) {
> 		ercd = E_OACV;
> 	}
> 	else if (p_runtsk->raster) {
581d869
< 	CHECK_ACPTN(p_pdqcb->p_pdqinib->acvct.acptn3);
584,591c872,888
< 	init_wait_queue(&(p_pdqcb->swait_queue));
< 	init_wait_queue(&(p_pdqcb->rwait_queue));
< 	p_pdqcb->count = 0U;
< 	p_pdqcb->p_head = NULL;
< 	p_pdqcb->unused = 0U;
< 	p_pdqcb->p_freelist = NULL;
< 	if (p_runtsk != p_schedtsk) {
< 		dispatch();
---
> 	if (p_pdqcb->p_pdqinib->pdqatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_pdqcb->p_pdqinib->acvct.acptn3)) {
> 		ercd = E_OACV;
> 	}
> 	else {
> 		init_wait_queue(&(p_pdqcb->swait_queue));
> 		init_wait_queue(&(p_pdqcb->rwait_queue));
> 		p_pdqcb->count = 0U;
> 		p_pdqcb->p_head = NULL;
> 		p_pdqcb->unused = 0U;
> 		p_pdqcb->p_freelist = NULL;
> 		if (p_runtsk != p_schedtsk) {
> 			dispatch();
> 		}
> 		ercd = E_OK;
593d889
< 	ercd = E_OK;
619d914
< 	CHECK_ACPTN(p_pdqcb->p_pdqinib->acvct.acptn4);
622,625c917,928
< 	pk_rpdq->stskid = wait_tskid(&(p_pdqcb->swait_queue));
< 	pk_rpdq->rtskid = wait_tskid(&(p_pdqcb->rwait_queue));
< 	pk_rpdq->spdqcnt = p_pdqcb->count;
< 	ercd = E_OK;
---
> 	if (p_pdqcb->p_pdqinib->pdqatr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_pdqcb->p_pdqinib->acvct.acptn4)) {
> 		ercd = E_OACV;
> 	}
> 	else {
> 		pk_rpdq->stskid = wait_tskid(&(p_pdqcb->swait_queue));
> 		pk_rpdq->rtskid = wait_tskid(&(p_pdqcb->rwait_queue));
> 		pk_rpdq->spdqcnt = p_pdqcb->count;
> 		ercd = E_OK;
> 	}
diff -r ./kernel/pridataq.h extension/dcre/kernel/pridataq.h
8c8
<  *  Copyright (C) 2005-2015 by Embedded and Real-Time Systems Laboratory
---
>  *  Copyright (C) 2005-2018 by Embedded and Real-Time Systems Laboratory
40c40
<  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
---
>  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
121a122
> extern const ID	tmax_spdqid;
126a128
> extern PDQINIB			apdqinib_table[];
Only in ./kernel: pridataq.trb
diff -r ./kernel/semaphore.c extension/dcre/kernel/semaphore.c
8c8
<  *  Copyright (C) 2005-2018 by Embedded and Real-Time Systems Laboratory
---
>  *  Copyright (C) 2005-2019 by Embedded and Real-Time Systems Laboratory
40c40
<  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
---
>  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
48a49
> #include "domain.h"
55a57,80
> #ifndef LOG_ACRE_SEM_ENTER
> #define LOG_ACRE_SEM_ENTER(pk_csem)
> #endif /* LOG_ACRE_SEM_ENTER */
> 
> #ifndef LOG_ACRE_SEM_LEAVE
> #define LOG_ACRE_SEM_LEAVE(ercd)
> #endif /* LOG_ACRE_SEM_LEAVE */
> 
> #ifndef LOG_SAC_SEM_ENTER
> #define LOG_SAC_SEM_ENTER(semid, p_acvct)
> #endif /* LOG_SAC_SEM_ENTER */
> 
> #ifndef LOG_SAC_SEM_LEAVE
> #define LOG_SAC_SEM_LEAVE(ercd)
> #endif /* LOG_SAC_SEM_LEAVE */
> 
> #ifndef LOG_DEL_SEM_ENTER
> #define LOG_DEL_SEM_ENTER(semid)
> #endif /* LOG_DEL_SEM_ENTER */
> 
> #ifndef LOG_DEL_SEM_LEAVE
> #define LOG_DEL_SEM_LEAVE(ercd)
> #endif /* LOG_DEL_SEM_LEAVE */
> 
104,114d128
< /*
<  *  セマフォの数
<  */
< #define tnum_sem	((uint_t)(tmax_semid - TMIN_SEMID + 1))
< 
< /*
<  *  セマフォIDからセマフォ管理ブロックを取り出すためのマクロ
<  */
< #define INDEX_SEM(semid)	((uint_t)((semid) - TMIN_SEMID))
< #define get_semcb(semid)	(&(semcb_table[INDEX_SEM(semid)]))
< 
119a134,142
> static void
> initialize_semcb(SEMCB *p_semcb, SEMINIB *p_seminib, const DOMINIB *p_dominib)
> {
> 	p_seminib->sematr = TA_NOEXS;
> 	p_semcb->p_seminib = (const SEMINIB *) p_seminib;
> 	queue_insert_prev(&(p_dominib->p_domcb->free_semcb),
> 										&(p_semcb->wait_queue));
> }
> 
123,124c146,149
< 	uint_t	i;
< 	SEMCB	*p_semcb;
---
> 	uint_t			i, j, k;
> 	ID				domid;
> 	SEMCB			*p_semcb;
> 	const DOMINIB	*p_dominib;
126c151
< 	for (i = 0; i < tnum_sem; i++) {
---
> 	for (i = 0; i < tnum_ssem; i++) {
131a157,174
> 
> 	queue_initialize(&(dominib_kernel.p_domcb->free_semcb));
> 	for (j = 0; j < dominib_kernel.tnum_asemid; i++, j++) {
> 		initialize_semcb(&(semcb_table[i]), &(aseminib_table[j]),
> 													&dominib_kernel);
> 	}
> 	for (domid = TMIN_DOMID; domid <= tmax_domid; domid++) {
> 		p_dominib = get_dominib(domid);
> 		queue_initialize(&(p_dominib->p_domcb->free_semcb));
> 		for (k = 0; k < p_dominib->tnum_asemid; i++, j++, k++) {
> 			initialize_semcb(&(semcb_table[i]), &(aseminib_table[j]),
> 															p_dominib);
> 		}
> 	}
> 	for (k = 0; k < dominib_none.tnum_asemid; i++, j++, k++) {
> 		initialize_semcb(&(semcb_table[i]), &(aseminib_table[j]),
> 													&dominib_none);
> 	}
136a180,353
>  *  セマフォの生成
>  */
> #ifdef TOPPERS_acre_sem
> 
> ER_UINT
> acre_sem(const T_CSEM *pk_csem)
> {
> 	SEMCB			*p_semcb;
> 	SEMINIB			*p_seminib;
> 	ATR				sematr;
> 	uint_t			isemcnt, maxsem;
> 	ID				domid;
> 	const DOMINIB	*p_dominib;
> 	ACPTN			acptn;
> 	ER				ercd;
> 
> 	LOG_ACRE_SEM_ENTER(pk_csem);
> 	CHECK_TSKCTX_UNL();
> 	CHECK_MACV_READ(pk_csem, T_CSEM);
> 
> 	sematr = pk_csem->sematr;
> 	isemcnt = pk_csem->isemcnt;
> 	maxsem = pk_csem->maxsem;
> 
> 	CHECK_VALIDATR(sematr, TA_TPRI|TA_DOMMASK);
> 	CHECK_PAR(0 <= isemcnt && isemcnt <= maxsem);
> 	CHECK_PAR(1 <= maxsem && maxsem <= TMAX_MAXSEM);
> 	domid = get_atrdomid(sematr);
> 	if (domid == TDOM_SELF) {
> 		if (rundom == TACP_KERNEL) {
> 			domid = TDOM_KERNEL;
> 		}
> 		else {
> 			domid = p_runtsk->p_tinib->domid;
> 		}
> 		sematr = set_atrdomid(sematr, domid);
> 	}
> 	switch (domid) {
> 	case TDOM_KERNEL:
> 		p_dominib = &dominib_kernel;
> 		break;
> 	case TDOM_NONE:
> 		p_dominib = &dominib_none;
> 		break;
> 	default:
> 		CHECK_RSATR(VALID_DOMID(domid));
> 		p_dominib = get_dominib(domid);
> 		break;
> 	}
> 	CHECK_ACPTN(p_dominib->acvct.acptn1);
> 
> 	lock_cpu();
> 	if (tnum_sem == 0 || queue_empty(&(p_dominib->p_domcb->free_semcb))) {
> 		ercd = E_NOID;
> 	}
> 	else {
> 		p_semcb = (SEMCB *)
> 					queue_delete_next(&(p_dominib->p_domcb->free_semcb));
> 		p_seminib = (SEMINIB *)(p_semcb->p_seminib);
> 		p_seminib->sematr = sematr;
> 		p_seminib->isemcnt = isemcnt;
> 		p_seminib->maxsem = maxsem;
> 
> 		acptn = default_acptn(domid);
> 		p_seminib->acvct.acptn1 = acptn;
> 		p_seminib->acvct.acptn2 = acptn;
> 		p_seminib->acvct.acptn3 = p_dominib->acvct.acptn1;
> 		p_seminib->acvct.acptn4 = acptn;
> 
> 		queue_initialize(&(p_semcb->wait_queue));
> 		p_semcb->semcnt = isemcnt;
> 		ercd = SEMID(p_semcb);
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_ACRE_SEM_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_acre_sem */
> 
> /*
>  *  セマフォのアクセス許可ベクタの設定
>  */
> #ifdef TOPPERS_sac_sem
> 
> ER
> sac_sem(ID semid, const ACVCT *p_acvct)
> {
> 	SEMCB	*p_semcb;
> 	SEMINIB	*p_seminib;
> 	ER		ercd;
> 
> 	LOG_SAC_SEM_ENTER(semid, p_acvct);
> 	CHECK_TSKCTX_UNL();
> 	CHECK_ID(VALID_SEMID(semid));
> 	CHECK_MACV_READ(p_acvct, ACVCT);
> 	p_semcb = get_semcb(semid);
> 
> 	lock_cpu();
> 	if (p_semcb->p_seminib->sematr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_semcb->p_seminib->acvct.acptn3)) {
> 		ercd = E_OACV;
> 	}
> 	else if (SEMID(p_semcb) <= tmax_ssemid) {
> 		ercd = E_OBJ;
> 	}
> 	else {
> 		p_seminib = (SEMINIB *)(p_semcb->p_seminib);
> 		p_seminib->acvct = *p_acvct;
> 		ercd = E_OK;
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_SAC_SEM_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_sac_sem */
> 
> /*
>  *  セマフォの削除
>  */
> #ifdef TOPPERS_del_sem
> 
> ER
> del_sem(ID semid)
> {
> 	SEMCB			*p_semcb;
> 	SEMINIB			*p_seminib;
> 	const DOMINIB	*p_dominib;
> 	ER				ercd;
> 
> 	LOG_DEL_SEM_ENTER(semid);
> 	CHECK_TSKCTX_UNL();
> 	CHECK_ID(VALID_SEMID(semid));
> 	p_semcb = get_semcb(semid);
> 
> 	lock_cpu();
> 	if (p_semcb->p_seminib->sematr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_semcb->p_seminib->acvct.acptn3)) {
> 		ercd = E_OACV;
> 	}
> 	else if (SEMID(p_semcb) <= tmax_ssemid) {
> 		ercd = E_OBJ;
> 	}
> 	else {
> 		init_wait_queue(&(p_semcb->wait_queue));
> 		p_seminib = (SEMINIB *)(p_semcb->p_seminib);
> 		p_dominib = get_atrdominib(p_seminib->sematr);
> 		p_seminib->sematr = TA_NOEXS;
> 		queue_insert_prev(&(p_dominib->p_domcb->free_semcb),
> 										&(p_semcb->wait_queue));
> 		if (p_runtsk != p_schedtsk) {
> 			dispatch();
> 		}
> 		ercd = E_OK;
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_DEL_SEM_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_del_sem */
> 
> /*
152d368
< 	CHECK_ACPTN(p_semcb->p_seminib->acvct.acptn1);
155c371,377
< 	if (!queue_empty(&(p_semcb->wait_queue))) {
---
> 	if (p_semcb->p_seminib->sematr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_semcb->p_seminib->acvct.acptn1)) {
> 		ercd = E_OACV;
> 	}
> 	else if (!queue_empty(&(p_semcb->wait_queue))) {
200d421
< 	CHECK_ACPTN(p_semcb->p_seminib->acvct.acptn2);
203c424,430
< 	if (p_runtsk->raster) {
---
> 	if (p_semcb->p_seminib->sematr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_semcb->p_seminib->acvct.acptn2)) {
> 		ercd = E_OACV;
> 	}
> 	else if (p_runtsk->raster) {
240d466
< 	CHECK_ACPTN(p_semcb->p_seminib->acvct.acptn2);
243c469,475
< 	if (p_semcb->semcnt >= 1) {
---
> 	if (p_semcb->p_seminib->sematr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_semcb->p_seminib->acvct.acptn2)) {
> 		ercd = E_OACV;
> 	}
> 	else if (p_semcb->semcnt >= 1) {
277d508
< 	CHECK_ACPTN(p_semcb->p_seminib->acvct.acptn2);
280c511,517
< 	if (p_runtsk->raster) {
---
> 	if (p_semcb->p_seminib->sematr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_semcb->p_seminib->acvct.acptn2)) {
> 		ercd = E_OACV;
> 	}
> 	else if (p_runtsk->raster) {
320d556
< 	CHECK_ACPTN(p_semcb->p_seminib->acvct.acptn3);
323,326c559,571
< 	init_wait_queue(&(p_semcb->wait_queue));
< 	p_semcb->semcnt = p_semcb->p_seminib->isemcnt;
< 	if (p_runtsk != p_schedtsk) {
< 		dispatch();
---
> 	if (p_semcb->p_seminib->sematr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_semcb->p_seminib->acvct.acptn3)) {
> 		ercd = E_OACV;
> 	}
> 	else {
> 		init_wait_queue(&(p_semcb->wait_queue));
> 		p_semcb->semcnt = p_semcb->p_seminib->isemcnt;
> 		if (p_runtsk != p_schedtsk) {
> 			dispatch();
> 		}
> 		ercd = E_OK;
328d572
< 	ercd = E_OK;
354d597
< 	CHECK_ACPTN(p_semcb->p_seminib->acvct.acptn4);
357,359c600,610
< 	pk_rsem->wtskid = wait_tskid(&(p_semcb->wait_queue));
< 	pk_rsem->semcnt = p_semcb->semcnt;
< 	ercd = E_OK;
---
> 	if (p_semcb->p_seminib->sematr == TA_NOEXS) {
> 		ercd = E_NOEXS;
> 	}
> 	else if (VIOLATE_ACPTN(p_semcb->p_seminib->acvct.acptn4)) {
> 		ercd = E_OACV;
> 	}
> 	else {
> 		pk_rsem->wtskid = wait_tskid(&(p_semcb->wait_queue));
> 		pk_rsem->semcnt = p_semcb->semcnt;
> 		ercd = E_OK;
> 	}
diff -r ./kernel/semaphore.h extension/dcre/kernel/semaphore.h
8c8
<  *  Copyright (C) 2005-2015 by Embedded and Real-Time Systems Laboratory
---
>  *  Copyright (C) 2005-2018 by Embedded and Real-Time Systems Laboratory
40c40
<  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
---
>  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
96a97
> extern const ID	tmax_ssemid;
101a103
> extern SEMINIB			aseminib_table[];
108a111,122
>  *  セマフォの数
>  */
> #define tnum_sem	((uint_t)(tmax_semid - TMIN_SEMID + 1))
> #define tnum_ssem	((uint_t)(tmax_ssemid - TMIN_SEMID + 1))
> 
> /*
>  *  セマフォIDからセマフォ管理ブロックを取り出すためのマクロ
>  */
> #define INDEX_SEM(semid)	((uint_t)((semid) - TMIN_SEMID))
> #define get_semcb(semid)	(&(semcb_table[INDEX_SEM(semid)]))
> 
> /*
Only in ./kernel: semaphore.trb
diff -r ./kernel/startup.c extension/dcre/kernel/startup.c
48a49
> #include "domain.h"
87a89
> 	ID		domid;
107a110,114
> 	initialize_mpk(&dominib_kernel);
> 	for (domid = TMIN_DOMID; domid <= tmax_domid; domid++) {
> 		initialize_mpk(get_dominib(domid));
> 	}
> 	initialize_mpk(&dominib_none);
202a210,314
> 
> /*
>  *  カーネルメモリプール領域の管理
>  */
> #ifdef TOPPERS_kermem
> 
> /*
>  *  デフォルトのメモリプール管理機能
>  *
>  *  メモリプール領域の先頭から順に割り当てを行い，すべてのメモリ領域が
>  *  解放されるまで解放されたメモリ領域を再利用しないメモリプール管理機
>  *  能．
>  */
> #ifndef OMIT_MEMPOOL_DEFAULT
> 
> typedef struct {
> 	void	*brk;		/* メモリプール領域の未使用領域の先頭番地 */
> 	void	*limit;		/* メモリプール領域の上限 */
> 	uint_t	count;		/* 割り当てたメモリ領域の数 */
> } MEMPOOLCB;
> 
> bool_t
> initialize_mempool(MB_T *mempool, size_t size)
> {
> 	MEMPOOLCB	*p_mempoolcb = ((MEMPOOLCB *) mempool);
> 
> 	if (size >= sizeof(MEMPOOLCB)) {
> 		p_mempoolcb->brk = ((char *) mempool) + sizeof(MEMPOOLCB);
> 		p_mempoolcb->limit = ((char *) mempool) + size;
> 		p_mempoolcb->count = 0;
> 		return(true);
> 	}
> 	else {
> 		return(false);
> 	}
> }
> 
> void *
> malloc_mempool(MB_T *mempool, size_t size)
> {
> 	MEMPOOLCB	*p_mempoolcb = ((MEMPOOLCB *) mempool);
> 	void		*brk;
> 
> 	brk = ((MEMPOOLCB *) mempool)->brk;
> 	if (((char *)(p_mempoolcb->limit)) - ((char *) brk) >= size) {
> 		p_mempoolcb->brk = ((char *) brk) + size;
> 		p_mempoolcb->count += 1;
> 		return(brk);
> 	}
> 	else {
> 		return(NULL);
> 	}
> }
> 
> void
> free_mempool(MB_T *mempool, void *ptr)
> {
> 	MEMPOOLCB	*p_mempoolcb = ((MEMPOOLCB *) mempool);
> 
> 	p_mempoolcb->count -= 1;
> 	if (p_mempoolcb->count == 0) {
> 		p_mempoolcb->brk = ((char *) mempool) + sizeof(MEMPOOLCB);
> 	}
> }
> 
> #endif /* OMIT_MEMPOOL_DEFAULT */
> 
> /*
>  *  カーネルメモリプール領域の初期化
>  */
> void
> initialize_mpk(const DOMINIB *p_dominib)
> {
> 	if (p_dominib->mpk != NULL) {
> 		p_dominib->p_domcb->mpk_valid
> 				= initialize_mempool(p_dominib->mpk, p_dominib->mpksz);
> 	}
> 	else {
> 		p_dominib->p_domcb->mpk_valid = false;
> 	}
> }
> 
> /*
>  *  カーネルメモリプール領域からのメモリ獲得／解放
>  */
> void *
> malloc_mpk(size_t size, const DOMINIB *p_dominib)
> {
> 	if (p_dominib->p_domcb->mpk_valid) {
> 		return(malloc_mempool(p_dominib->mpk, size));
> 	}
> 	else {
> 		return(NULL);
> 	}
> }
> 
> void
> free_mpk(void *ptr, const DOMINIB *p_dominib)
> {
> 	if (p_dominib->p_domcb->mpk_valid) {
> 		free_mempool(p_dominib->mpk, ptr);
> 	}
> }
> 
> #endif /* TOPPERS_kermem */
diff -r ./kernel/svc.def extension/dcre/kernel/svc.def
40c40
< #  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
---
> #  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
269,281c269,281
< -193	-				ER_ID	acre_tsk(const T_CTSK *pk_ctsk)
< 		-				ER_ID	acre_sem(const T_CSEM *pk_csem)
< 		-				ER_ID	acre_flg(const T_CFLG *pk_cflg)
< 		-				ER_ID	acre_dtq(const T_CDTQ *pk_cdtq)
< -197	-				ER_ID	acre_pdq(const T_CPDQ *pk_cpdq)
< 		-
< 		-				ER_ID	acre_mtx(const T_CMTX *pk_cmtx)
< 		-				ER_ID	acre_mbf(const T_CMBF *pk_cmbf)
< -201	-				ER_ID	acre_mpf(const T_CMPF *pk_cmpf)
< 		-				ER_ID	acre_cyc(const T_CCYC *pk_ccyc)
< 		-				ER_ID	acre_alm(const T_CALM *pk_calm)
< 		-				ER_ID	acre_isr(const T_CISR *pk_cisr)
< -205	-				ER_ID	acre_spn(const T_CSPN *pk_cspn)
---
> -193	S[DYNAMIC_CRE]	ER_ID	acre_tsk(const T_CTSK *pk_ctsk)
> 		S[DYNAMIC_CRE]	ER_ID	acre_sem(const T_CSEM *pk_csem)
> 		S[DYNAMIC_CRE]	ER_ID	acre_flg(const T_CFLG *pk_cflg)
> 		S[DYNAMIC_CRE]	ER_ID	acre_dtq(const T_CDTQ *pk_cdtq)
> -197	S[DYNAMIC_CRE]	ER_ID	acre_pdq(const T_CPDQ *pk_cpdq)
> 		-
> 		S[DYNAMIC_CRE]	ER_ID	acre_mtx(const T_CMTX *pk_cmtx)
> 		S[DYNAMIC_CRE]	ER_ID	acre_mbf(const T_CMBF *pk_cmbf)
> -201	S[DYNAMIC_CRE]	ER_ID	acre_mpf(const T_CMPF *pk_cmpf)
> 		S[DYNAMIC_CRE]	ER_ID	acre_cyc(const T_CCYC *pk_ccyc)
> 		S[DYNAMIC_CRE]	ER_ID	acre_alm(const T_CALM *pk_calm)
> 		S[DYNAMIC_CRE]	ER_ID	acre_isr(const T_CISR *pk_cisr)
> -205	M[DYNAMIC_CRE]	ER_ID	acre_spn(const T_CSPN *pk_cspn)
285,297c285,297
< -209	-				ER		del_tsk(ID tskid)
< 		-				ER		del_sem(ID semid)
< 		-				ER		del_flg(ID flgid)
< 		-				ER		del_dtq(ID dtqid)
< -213	-				ER		del_pdq(ID pdqid)
< 		-
< 		-				ER		del_mtx(ID mtxid)
< 		-				ER		del_mbf(ID mbfid)
< -217	-				ER		del_mpf(ID mpfid)
< 		-				ER		del_cyc(ID cycid)
< 		-				ER		del_alm(ID almid)
< 		-				ER		del_isr(ID isrid)
< -221	-				ER		del_spn(ID spnid)
---
> -209	S[DYNAMIC_CRE]	ER		del_tsk(ID tskid)
> 		S[DYNAMIC_CRE]	ER		del_sem(ID semid)
> 		S[DYNAMIC_CRE]	ER		del_flg(ID flgid)
> 		S[DYNAMIC_CRE]	ER		del_dtq(ID dtqid)
> -213	S[DYNAMIC_CRE]	ER		del_pdq(ID pdqid)
> 		-
> 		S[DYNAMIC_CRE]	ER		del_mtx(ID mtxid)
> 		S[DYNAMIC_CRE]	ER		del_mbf(ID mbfid)
> -217	S[DYNAMIC_CRE]	ER		del_mpf(ID mpfid)
> 		S[DYNAMIC_CRE]	ER		del_cyc(ID cycid)
> 		S[DYNAMIC_CRE]	ER		del_alm(ID almid)
> 		S[DYNAMIC_CRE]	ER		del_isr(ID isrid)
> -221	M[DYNAMIC_CRE]	ER		del_spn(ID spnid)
301,313c301,313
< -225	-				ER		sac_tsk(ID tskid, const ACVCT *p_acvct)
< 		-				ER		sac_sem(ID semid, const ACVCT *p_acvct)
< 		-				ER		sac_flg(ID flgid, const ACVCT *p_acvct)
< 		-				ER		sac_dtq(ID dtqid, const ACVCT *p_acvct)
< -229	-				ER		sac_pdq(ID pdqid, const ACVCT *p_acvct)
< 		-
< 		-				ER		sac_mtx(ID mtxid, const ACVCT *p_acvct)
< 		-				ER		sac_mbf(ID mbfid, const ACVCT *p_acvct)
< -233	-				ER		sac_mpf(ID mpfid, const ACVCT *p_acvct)
< 		-				ER		sac_cyc(ID cycid, const ACVCT *p_acvct)
< 		-				ER		sac_alm(ID almid, const ACVCT *p_acvct)
< 		-				ER		sac_isr(ID isrid, const ACVCT *p_acvct)
< -237	-				ER		sac_spn(ID spnid, const ACVCT *p_acvct)
---
> -225	S[DYNAMIC_CRE]	ER		sac_tsk(ID tskid, const ACVCT *p_acvct)
> 		S[DYNAMIC_CRE]	ER		sac_sem(ID semid, const ACVCT *p_acvct)
> 		S[DYNAMIC_CRE]	ER		sac_flg(ID flgid, const ACVCT *p_acvct)
> 		S[DYNAMIC_CRE]	ER		sac_dtq(ID dtqid, const ACVCT *p_acvct)
> -229	S[DYNAMIC_CRE]	ER		sac_pdq(ID pdqid, const ACVCT *p_acvct)
> 		-
> 		S[DYNAMIC_CRE]	ER		sac_mtx(ID mtxid, const ACVCT *p_acvct)
> 		S[DYNAMIC_CRE]	ER		sac_mbf(ID mbfid, const ACVCT *p_acvct)
> -233	S[DYNAMIC_CRE]	ER		sac_mpf(ID mpfid, const ACVCT *p_acvct)
> 		S[DYNAMIC_CRE]	ER		sac_cyc(ID cycid, const ACVCT *p_acvct)
> 		S[DYNAMIC_CRE]	ER		sac_alm(ID almid, const ACVCT *p_acvct)
> 		S[DYNAMIC_CRE]	ER		sac_isr(ID isrid, const ACVCT *p_acvct)
> -237	M[DYNAMIC_CRE]	ER		sac_spn(ID spnid, const ACVCT *p_acvct)
Only in ./kernel: svc_manage.h
Only in ./kernel: svc_manage.trb
diff -r ./kernel/svc_table.c extension/dcre/kernel/svc_table.c
45a46,84
> #ifndef TOPPERS_SUPPORT_DYNAMIC_CRE
> #define acre_tsk no_support
> #define acre_sem no_support
> #define acre_flg no_support
> #define acre_dtq no_support
> #define acre_pdq no_support
> #define acre_mtx no_support
> #define acre_mbf no_support
> #define acre_mpf no_support
> #define acre_cyc no_support
> #define acre_alm no_support
> #define acre_isr no_support
> #define acre_spn no_support
> #define del_tsk no_support
> #define del_sem no_support
> #define del_flg no_support
> #define del_dtq no_support
> #define del_pdq no_support
> #define del_mtx no_support
> #define del_mbf no_support
> #define del_mpf no_support
> #define del_cyc no_support
> #define del_alm no_support
> #define del_isr no_support
> #define del_spn no_support
> #define sac_tsk no_support
> #define sac_sem no_support
> #define sac_flg no_support
> #define sac_dtq no_support
> #define sac_pdq no_support
> #define sac_mtx no_support
> #define sac_mbf no_support
> #define sac_mpf no_support
> #define sac_cyc no_support
> #define sac_alm no_support
> #define sac_isr no_support
> #define sac_spn no_support
> #endif /* TOPPERS_SUPPORT_DYNAMIC_CRE */
> 
245a285,296
> 	(SVC)(acre_tsk),
> 	(SVC)(acre_sem),
> 	(SVC)(acre_flg),
> 	(SVC)(acre_dtq),
> 	(SVC)(acre_pdq),
> 	(SVC)(no_support),
> 	(SVC)(acre_mtx),
> 	(SVC)(acre_mbf),
> 	(SVC)(acre_mpf),
> 	(SVC)(acre_cyc),
> 	(SVC)(acre_alm),
> 	(SVC)(acre_isr),
249a301,312
> 	(SVC)(del_tsk),
> 	(SVC)(del_sem),
> 	(SVC)(del_flg),
> 	(SVC)(del_dtq),
> 	(SVC)(del_pdq),
> 	(SVC)(no_support),
> 	(SVC)(del_mtx),
> 	(SVC)(del_mbf),
> 	(SVC)(del_mpf),
> 	(SVC)(del_cyc),
> 	(SVC)(del_alm),
> 	(SVC)(del_isr),
254,289c317,328
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
< 	(SVC)(no_support),
---
> 	(SVC)(sac_tsk),
> 	(SVC)(sac_sem),
> 	(SVC)(sac_flg),
> 	(SVC)(sac_dtq),
> 	(SVC)(sac_pdq),
> 	(SVC)(no_support),
> 	(SVC)(sac_mtx),
> 	(SVC)(sac_mbf),
> 	(SVC)(sac_mpf),
> 	(SVC)(sac_cyc),
> 	(SVC)(sac_alm),
> 	(SVC)(sac_isr),
Only in ./kernel: sys_manage.c
diff -r ./kernel/task.c extension/dcre/kernel/task.c
47a48
> #include "domain.h"
76a78,88
> static void
> initialize_tcb(TCB *p_tcb, TINIB *p_tinib, const DOMINIB *p_dominib, ID domid)
> {
> 	p_tinib->domid = domid;
> 	p_tinib->tskatr = TA_NOEXS;
> 	p_tcb->p_tinib = (const TINIB *) p_tinib;
> 	p_tcb->p_dominib = p_dominib;
> 	p_tcb->p_schedcb = p_dominib->p_schedcb;
> 	queue_insert_prev(&(p_dominib->p_domcb->free_tcb), &(p_tcb->task_queue));
> }
> 
80,81c92,95
< 	uint_t	i, j;
< 	TCB		*p_tcb;
---
> 	uint_t			i, j, k;
> 	ID				domid;
> 	TCB				*p_tcb;
> 	const DOMINIB	*p_dominib;
88c102
< 	for (i = 0; i < tnum_tsk; i++) {
---
> 	for (i = 0; i < tnum_stsk; i++) {
100d113
< 		make_dormant(p_tcb);
101a115
> 		make_dormant(p_tcb);
105a120,133
> 
> 	queue_initialize(&(dominib_kernel.p_domcb->free_tcb));
> 	for (j = 0; j < dominib_kernel.tnum_atskid; i++, j++) {
> 		initialize_tcb(&(tcb_table[i]), &(atinib_table[j]),
> 										&dominib_kernel, TDOM_KERNEL);
> 	}
> 	for (domid = TMIN_DOMID; domid <= tmax_domid; domid++) {
> 		p_dominib = get_dominib(domid);
> 		queue_initialize(&(p_dominib->p_domcb->free_tcb));
> 		for (k = 0; k < p_dominib->tnum_atskid; i++, j++, k++) {
> 			initialize_tcb(&(tcb_table[i]), &(atinib_table[j]),
> 													p_dominib, domid);
> 		}
> 	}
diff -r ./kernel/task.h extension/dcre/kernel/task.h
191a192,194
>  *
>  *  動的生成するタスクについては，domid，tskatrはシステム初期化時に初
>  *  期化し，他のフィールドはタスクの生成時に初期化する．
234a238,241
>  *
>  *  動的生成するタスクについては，p_tinib，p_dominib，p_schedcbはシス
>  *  テム初期化時に初期化し，他のフィールドはタスクの生成時または起動時
>  *  に初期化する．
308a316
> extern const ID	tmax_stskid;
313a322
> extern TINIB		atinib_table[];
328a338
> #define tnum_stsk	((uint_t)(tmax_stskid - TMIN_TSKID + 1))
diff -r ./kernel/task.trb extension/dcre/kernel/task.trb
309c309
< $kernelCfgC.add("const ID _kernel_torder_table[TNUM_TSKID] = { ")
---
> $kernelCfgC.add("const ID _kernel_torder_table[TNUM_STSKID] = { ")
diff -r ./kernel/task_manage.c extension/dcre/kernel/task_manage.c
51a52
> #include "memory.h"
55a57,80
> #ifndef LOG_ACRE_TSK_ENTER
> #define LOG_ACRE_TSK_ENTER(pk_ctsk)
> #endif /* LOG_ACRE_TSK_ENTER */
> 
> #ifndef LOG_ACRE_TSK_LEAVE
> #define LOG_ACRE_TSK_LEAVE(ercd)
> #endif /* LOG_ACRE_TSK_LEAVE */
> 
> #ifndef LOG_SAC_TSK_ENTER
> #define LOG_SAC_TSK_ENTER(tskid, p_acvct)
> #endif /* LOG_SAC_TSK_ENTER */
> 
> #ifndef LOG_SAC_TSK_LEAVE
> #define LOG_SAC_TSK_LEAVE(ercd)
> #endif /* LOG_SAC_TSK_LEAVE */
> 
> #ifndef LOG_DEL_TSK_ENTER
> #define LOG_DEL_TSK_ENTER(tskid)
> #endif /* LOG_DEL_TSK_ENTER */
> 
> #ifndef LOG_DEL_TSK_LEAVE
> #define LOG_DEL_TSK_LEAVE(ercd)
> #endif /* LOG_DEL_TSK_LEAVE */
> 
104a130,383
>  *  ユーザスタック領域のチェックのデフォルトの定義
>  */
> #ifndef CHECK_TARGET_USTACK
> 
> #define CHECK_TARGET_USTACK(ustksz, ustk, p_dominib) do {			\
> 	CHECK_PAR(USTKSZ_ALIGN(ustksz));			/*［NGKI1056］*/	\
> 	CHECK_PAR(USTACK_ALIGN(ustk));				/*［NGKI1056］*/	\
> 	CHECK_OBJ(valid_ustack(ustk, ustksz));		/*［NGKI1060］*/	\
> } while (false)
> 
> #endif /* CHECK_TARGET_USTACK */
> 
> /*
>  *  タスクの生成［NGKI1024］
>  *
>  *  pk_ctsk->exinfは，エラーチェックをせず，一度しか参照しないため，ロー
>  *  カル変数にコピーする必要がない（途中で書き換わっても支障がない）．
>  */
> #ifdef TOPPERS_acre_tsk
> 
> ER_UINT
> acre_tsk(const T_CTSK *pk_ctsk)
> {
> 	TCB				*p_tcb;
> 	TINIB			*p_tinib;
> 	ATR				tskatr;
> 	TASK			task;
> 	PRI				itskpri;
> 	size_t			stksz, sstksz, ustksz;
> 	STK_T			*stk, *sstk, *ustk;
> 	ID				domid;
> 	const DOMINIB	*p_dominib;
> 	ACPTN			acptn;
> 	ER				ercd;
> 
> 	LOG_ACRE_TSK_ENTER(pk_ctsk);
> 	CHECK_TSKCTX_UNL();							/*［NGKI1026］［NGKI1027］*/
> 	CHECK_MACV_READ(pk_ctsk, T_CTSK);			/*［NGKI1036］*/
> 
> 	tskatr = pk_ctsk->tskatr;
> 	task = pk_ctsk->task;
> 	itskpri = pk_ctsk->itskpri;
> 	stksz = pk_ctsk->stksz;
> 	stk = pk_ctsk->stk;
> 	sstksz = pk_ctsk->sstksz;
> 	sstk = pk_ctsk->sstk;
> 
> 	CHECK_VALIDATR(tskatr, TA_ACT|TA_NOACTQUE|TARGET_TSKATR|TA_DOMMASK);
> 												/*［NGKI1028］*/
> 	CHECK_PAR(FUNC_ALIGN(task));				/*［NGKI1033］*/
> 	CHECK_PAR(FUNC_NONNULL(task));				/*［NGKI1033］*/
> 	CHECK_PAR(VALID_TPRI(itskpri));				/*［NGKI1034］*/
> 	domid = get_atrdomid(tskatr);
> 	if (domid == TDOM_SELF) {
> 		if (rundom == TACP_KERNEL) {
> 			domid = TDOM_KERNEL;
> 		}
> 		else {
> 			domid = p_runtsk->p_tinib->domid;
> 		}
> 		tskatr = set_atrdomid(tskatr, domid);
> 	}
> 	if (domid == TDOM_KERNEL) {
> 		p_dominib = &dominib_kernel;
> 	}
> 	else {
> 		CHECK_RSATR(VALID_DOMID(domid));		/*［NGKI1029］*/
> 		p_dominib = get_dominib(domid);
> 	}
> 	if (p_dominib == &dominib_kernel) {
> 		/*
> 		 *  システムタスクの場合
> 		 */
> 		CHECK_PAR(sstk == NULL);				/*［NGKI1068］*/
> 		if (stk == NULL) {
> 			stksz += sstksz;					/*［NGKI1069］［NGKI1072］*/
> 		}
> 		else {
> 			CHECK_PAR(sstksz == 0);				/*［NGKI1071］*/
> 		}
> 		sstksz = stksz;
> 		sstk = stk;
> 		ustksz = 0U;
> 		ustk = NULL;
> 	}
> 	else {
> 		/*
> 		 *  ユーザタスクの場合
> 		 */
> 		CHECK_NOSPT(stk != NULL);				/*［HRPS0176］*/
> 		CHECK_PAR(stksz >= TARGET_MIN_USTKSZ);	/*［NGKI1042］*/
> 		CHECK_TARGET_USTACK(stksz, stk, p_dominib);
> 		ustksz = stksz;
> 		ustk = stk;
> 	}
> 	CHECK_PAR(sstksz >= TARGET_MIN_SSTKSZ);		/*［NGKI1042］［NGKI1044］*/
> 	if (sstk != NULL) {
> 		CHECK_PAR(SSTKSZ_ALIGN(sstksz));		/*［NGKI1056］［NGKI1065］*/
> 		CHECK_PAR(SSTACK_ALIGN(sstk));			/*［NGKI1056］［NGKI1065］*/
> 		CHECK_OBJ(valid_memobj_kernel(sstk, sstksz));
> 												/*［NGKI1057］［NGKI1066］*/
> 	}
> 	CHECK_ACPTN(p_dominib->acvct.acptn1);		/*［NGKI3966］*/
> 
> 	lock_cpu();
> 	if (queue_empty(&(p_dominib->p_domcb->free_tcb))) {
> 		ercd = E_NOID;							/*［NGKI1037］*/
> 	}
> 	else {
> 		if (sstk == NULL) {
> 			sstksz = ROUND_STK_T(sstksz);
> 			sstk = malloc_mpk(sstksz, p_dominib);
> 			tskatr |= TA_MEMALLOC;
> 		}
> 		if (sstk == NULL) {
> 			ercd = E_NOMEM;						/*［NGKI1038］［NGKI1039］*/
> 		}
> 		else {
> 			p_tcb = (TCB *) queue_delete_next(&(p_dominib->p_domcb->free_tcb));
> 			p_tinib = (TINIB *)(p_tcb->p_tinib);
> 			p_tinib->tskatr = tskatr;
> 			p_tinib->exinf = pk_ctsk->exinf;
> 			p_tinib->task = task;
> 			p_tinib->ipriority = INT_PRIORITY(itskpri);
> #ifdef USE_TSKINICTXB
> 			init_tskinictxb(&(p_tinib->tskinictxb), p_dominib,
> 									sstksz, sstk, ustksz, ustk, pk_ctsk);
> #else /* USE_TSKINICTXB */
> 			p_tinib->sstksz = sstksz;
> 			p_tinib->sstk = sstk;
> 			p_tinib->ustksz = ustksz;
> 			p_tinib->ustk = ustk;
> #endif /* USE_TSKINICTXB */
> 
> 			acptn = default_acptn(domid);
> 			p_tinib->acvct.acptn1 = acptn;
> 			p_tinib->acvct.acptn2 = acptn;
> 			p_tinib->acvct.acptn3 = p_dominib->acvct.acptn1;
> 			p_tinib->acvct.acptn4 = acptn;
> 
> 			p_tcb->actque = false;
> 			p_tcb->p_lastmtx = NULL;
> 			make_dormant(p_tcb);
> 			if ((tskatr & TA_ACT) != 0U) {
> 				make_active(p_tcb);
> 				if (p_runtsk != p_schedtsk) {
> 					dispatch();
> 				}
> 			}
> 			ercd = TSKID(p_tcb);
> 		}
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_ACRE_TSK_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_acre_tsk */
> 
> /*
>  *  タスクのアクセス許可ベクタの設定［NGKI1078］
>  */
> #ifdef TOPPERS_sac_tsk
> 
> ER
> sac_tsk(ID tskid, const ACVCT *p_acvct)
> {
> 	TCB		*p_tcb;
> 	TINIB	*p_tinib;
> 	ER		ercd;
> 
> 	LOG_SAC_TSK_ENTER(tskid, p_acvct);
> 	CHECK_TSKCTX_UNL();							/*［NGKI1080］［NGKI1081］*/
> 	CHECK_ID(VALID_TSKID(tskid));				/*［NGKI1082］*/
> 	CHECK_MACV_READ(p_acvct, ACVCT);			/*［NGKI1087］*/
> 	p_tcb = get_tcb(tskid);
> 
> 	lock_cpu();
> 	if (p_tcb->p_tinib->tskatr == TA_NOEXS) {
> 		ercd = E_NOEXS;							/*［NGKI1085］*/
> 	}
> 	else if (VIOLATE_ACPTN(p_tcb->p_tinib->acvct.acptn3)) {
> 		ercd = E_OACV;							/*［NGKI1086］*/
> 	}
> 	else if (TSKID(p_tcb) > tmax_stskid) {
> 		p_tinib = (TINIB *)(p_tcb->p_tinib);
> 		p_tinib->acvct = *p_acvct;
> 		ercd = E_OK;
> 	}
> 	else {
> 		ercd = E_OBJ;							/*［NGKI1088］*/
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_SAC_TSK_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_sac_tsk */
> 
> /*
>  *  タスクの削除［NGKI1100］
>  */
> #ifdef TOPPERS_del_tsk
> 
> ER
> del_tsk(ID tskid)
> {
> 	TCB		*p_tcb;
> 	TINIB	*p_tinib;
> 	ER		ercd;
> 
> 	LOG_DEL_TSK_ENTER(tskid);
> 	CHECK_TSKCTX_UNL();							/*［NGKI1101］［NGKI1102］*/
> 	CHECK_ID(VALID_TSKID(tskid));				/*［NGKI1103］*/
> 	p_tcb = get_tcb(tskid);
> 
> 	lock_cpu();
> 	if (p_tcb->p_tinib->tskatr == TA_NOEXS) {
> 		ercd = E_NOEXS;							/*［NGKI1104］*/
> 	}
> 	else if (VIOLATE_ACPTN(p_tcb->p_tinib->acvct.acptn3)) {
> 		ercd = E_OACV;							/*［NGKI1105］*/
> 	}
> 	else if (TSKID(p_tcb) <= tmax_stskid || !TSTAT_DORMANT(p_tcb->tstat)) {
> 		ercd = E_OBJ;							/*［NGKI1106］［NGKI1107］*/
> 	}
> 	else {
> 		p_tinib = (TINIB *)(p_tcb->p_tinib);
> #ifdef USE_TSKINICTXB
> 		term_tskinictxb(&(p_tinib->tskinictxb));
> #else /* USE_TSKINICTXB */
> 		if ((p_tinib->tskatr & TA_MEMALLOC) != 0U) {
> 			free_mpk(p_tinib->sstk, p_tcb->p_dominib);
> 		}
> #endif /* USE_TSKINICTXB */
> 		p_tinib->tskatr = TA_NOEXS;
> 		queue_insert_prev(&(p_tcb->p_dominib->p_domcb->free_tcb),
> 												&(p_tcb->task_queue));
> 		ercd = E_OK;
> 	}
> 	unlock_cpu();
> 
>   error_exit:
> 	LOG_DEL_TSK_LEAVE(ercd);
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_del_tsk */
> 
> /*
124d402
< 	CHECK_ACPTN(p_tcb->p_tinib->acvct.acptn1);	/*［NGKI1117］*/
127c405,411
< 	if (TSTAT_DORMANT(p_tcb->tstat)) {
---
> 	if (p_tcb->p_tinib->tskatr == TA_NOEXS) {
> 		ercd = E_NOEXS;							/*［NGKI1116］*/
> 	}
> 	else if (VIOLATE_ACPTN(p_tcb->p_tinib->acvct.acptn1)) {
> 		ercd = E_OACV;							/*［NGKI1117］*/
> 	}
> 	else if (TSTAT_DORMANT(p_tcb->tstat)) {
175d458
< 	CHECK_ACPTN(p_tcb->p_tinib->acvct.acptn1);	/*［NGKI1143］*/
178,179c461,470
< 	ercd = p_tcb->actque ? 1 : 0;				/*［NGKI1144］*/
< 	p_tcb->actque = false;						/*［NGKI1144］*/
---
> 	if (p_tcb->p_tinib->tskatr == TA_NOEXS) {
> 		ercd = E_NOEXS;							/*［NGKI1142］*/
> 	}
> 	else if (VIOLATE_ACPTN(p_tcb->p_tinib->acvct.acptn1)) {
> 		ercd = E_OACV;							/*［NGKI1143］*/
> 	}
> 	else {
> 		ercd = p_tcb->actque ? 1 : 0;			/*［NGKI1144］*/
> 		p_tcb->actque = false;					/*［NGKI1144］*/
> 	}
211d501
< 	CHECK_ACPTN(p_tcb->p_tinib->acvct.acptn4);	/*［NGKI3618］*/
214,227c504,505
< 	tstat = p_tcb->tstat;
< 	if (TSTAT_DORMANT(tstat)) {					/*［NGKI3620］*/
< 		*p_tskstat = TTS_DMT;
< 	}
< 	else if (TSTAT_SUSPENDED(tstat)) {
< 		if (TSTAT_WAITING(tstat)) {
< 			*p_tskstat = TTS_WAS;
< 		}
< 		else {
< 			*p_tskstat = TTS_SUS;
< 		}
< 	}
< 	else if (TSTAT_WAITING(tstat)) {
< 		*p_tskstat = TTS_WAI;
---
> 	if (p_tcb->p_tinib->tskatr == TA_NOEXS) {
> 		ercd = E_NOEXS;							/*［NGKI3617］*/
229,230c507,508
< 	else if (p_tcb == p_runtsk) {
< 		*p_tskstat = TTS_RUN;
---
> 	else if (VIOLATE_ACPTN(p_tcb->p_tinib->acvct.acptn4)) {
> 		ercd = E_OACV;							/*［NGKI3618］*/
233c511,532
< 		*p_tskstat = TTS_RDY;
---
> 		tstat = p_tcb->tstat;
> 		if (TSTAT_DORMANT(tstat)) {				/*［NGKI3620］*/
> 			*p_tskstat = TTS_DMT;
> 		}
> 		else if (TSTAT_SUSPENDED(tstat)) {
> 			if (TSTAT_WAITING(tstat)) {
> 				*p_tskstat = TTS_WAS;
> 			}
> 			else {
> 				*p_tskstat = TTS_SUS;
> 			}
> 		}
> 		else if (TSTAT_WAITING(tstat)) {
> 			*p_tskstat = TTS_WAI;
> 		}
> 		else if (p_tcb == p_runtsk) {
> 			*p_tskstat = TTS_RUN;
> 		}
> 		else {
> 			*p_tskstat = TTS_RDY;
> 		}
> 		ercd = E_OK;
235d533
< 	ercd = E_OK;
266d563
< 	CHECK_ACPTN(p_tcb->p_tinib->acvct.acptn2);	/*［NGKI1190］*/
267a565,569
> 		/*
> 		 *  以下の代入文は，対象タスクが未登録の場合に無効なフィールド
> 		 *  を参照するが，その場合はnewbpriの値を使わないので，問題な
> 		 *  い．
> 		 */
276c578,584
< 	if (TSTAT_DORMANT(p_tcb->tstat)) {
---
> 	if (p_tcb->p_tinib->tskatr == TA_NOEXS) {
> 		ercd = E_NOEXS;							/*［NGKI1189］*/
> 	}
> 	else if (VIOLATE_ACPTN(p_tcb->p_tinib->acvct.acptn2)) {
> 		ercd = E_OACV;							/*［NGKI1190］*/
> 	}
> 	else if (TSTAT_DORMANT(p_tcb->tstat)) {
323d630
< 	CHECK_ACPTN(p_tcb->p_tinib->acvct.acptn4);	/*［NGKI1207］*/
326c633,639
< 	if (TSTAT_DORMANT(p_tcb->tstat)) {
---
> 	if (p_tcb->p_tinib->tskatr == TA_NOEXS) {
> 		ercd = E_NOEXS;							/*［NGKI1206］*/
> 	}
> 	else if (VIOLATE_ACPTN(p_tcb->p_tinib->acvct.acptn4)) {
> 		ercd = E_OACV;							/*［NGKI1207］*/
> 	}
> 	else if (TSTAT_DORMANT(p_tcb->tstat)) {
diff -r ./kernel/task_refer.c extension/dcre/kernel/task_refer.c
91d90
< 	CHECK_ACPTN(p_tcb->p_tinib->acvct.acptn4);	/*［NGKI1222］*/
94,99c93,97
< 	tstat = p_tcb->tstat;
< 	if (TSTAT_DORMANT(tstat)) {
< 		/*
<  		 *  対象タスクが休止状態の場合［NGKI1225］
< 		 */
< 		pk_rtsk->tskstat = TTS_DMT;
---
> 	if (p_tcb->p_tinib->tskatr == TA_NOEXS) {
> 		ercd = E_NOEXS;							/*［NGKI1221］*/
> 	}
> 	else if (VIOLATE_ACPTN(p_tcb->p_tinib->acvct.acptn4)) {
> 		ercd = E_OACV;							/*［NGKI1222］*/
102,107c100,123
< 		/*
<  		 *  タスク状態の取出し［NGKI1225］
< 		 */
< 		if (TSTAT_SUSPENDED(tstat)) {
< 			if (TSTAT_WAITING(tstat)) {
< 				pk_rtsk->tskstat = TTS_WAS;
---
> 		tstat = p_tcb->tstat;
> 		if (TSTAT_DORMANT(tstat)) {
> 			/*
> 	 		 *  対象タスクが休止状態の場合［NGKI1225］
> 			 */
> 			pk_rtsk->tskstat = TTS_DMT;
> 		}
> 		else {
> 			/*
> 	 		 *  タスク状態の取出し［NGKI1225］
> 			 */
> 			if (TSTAT_SUSPENDED(tstat)) {
> 				if (TSTAT_WAITING(tstat)) {
> 					pk_rtsk->tskstat = TTS_WAS;
> 				}
> 				else {
> 					pk_rtsk->tskstat = TTS_SUS;
> 				}
> 			}
> 			else if (TSTAT_WAITING(tstat)) {
> 				pk_rtsk->tskstat = TTS_WAI;
> 			}
> 			else if (p_tcb == p_runtsk) {
> 				pk_rtsk->tskstat = TTS_RUN;
110c126
< 				pk_rtsk->tskstat = TTS_SUS;
---
> 				pk_rtsk->tskstat = TTS_RDY;
112,121d127
< 		}
< 		else if (TSTAT_WAITING(tstat)) {
< 			pk_rtsk->tskstat = TTS_WAI;
< 		}
< 		else if (p_tcb == p_runtsk) {
< 			pk_rtsk->tskstat = TTS_RUN;
< 		}
< 		else {
< 			pk_rtsk->tskstat = TTS_RDY;
< 		}
123,129d128
< 		/*
<  		 *  現在優先度とベース優先度の取出し［NGKI1227］
< 		 */
< 		pk_rtsk->tskpri = EXT_TSKPRI(p_tcb->priority);
< 		pk_rtsk->tskbpri = EXT_TSKPRI(p_tcb->bpriority);
< 
< 		if (TSTAT_WAITING(tstat)) {
131,132c130
< 	 		 *  待ち要因と待ち対象のオブジェクトのIDの取出し［NGKI1229］
< 	 		 *  ［NGKI1231］
---
> 	 		 *  現在優先度とベース優先度の取出し［NGKI1227］
134,143c132,149
< 			switch (tstat & TS_WAITING_MASK) {
< 			case TS_WAITING_SLP:
< 				pk_rtsk->tskwait = TTW_SLP;
< 				break;
< 			case TS_WAITING_DLY:
< 				pk_rtsk->tskwait = TTW_DLY;
< 				break;
< 			case TS_WAITING_SEM:
< 				pk_rtsk->tskwait = TTW_SEM;
< 				pk_rtsk->wobjid = SEMID(((WINFO_SEM *)(p_tcb->p_winfo))
---
> 			pk_rtsk->tskpri = EXT_TSKPRI(p_tcb->priority);
> 			pk_rtsk->tskbpri = EXT_TSKPRI(p_tcb->bpriority);
> 
> 			if (TSTAT_WAITING(tstat)) {
> 				/*
> 		 		 *  待ち要因と待ち対象のオブジェクトのIDの取出し［NGKI1229］
> 				 *  ［NGKI1231］
> 				 */
> 				switch (tstat & TS_WAITING_MASK) {
> 				case TS_WAITING_SLP:
> 					pk_rtsk->tskwait = TTW_SLP;
> 					break;
> 				case TS_WAITING_DLY:
> 					pk_rtsk->tskwait = TTW_DLY;
> 					break;
> 				case TS_WAITING_SEM:
> 					pk_rtsk->tskwait = TTW_SEM;
> 					pk_rtsk->wobjid = SEMID(((WINFO_SEM *)(p_tcb->p_winfo))
145,148c151,154
< 				break;
< 			case TS_WAITING_FLG:
< 				pk_rtsk->tskwait = TTW_FLG;
< 				pk_rtsk->wobjid = FLGID(((WINFO_FLG *)(p_tcb->p_winfo))
---
> 					break;
> 				case TS_WAITING_FLG:
> 					pk_rtsk->tskwait = TTW_FLG;
> 					pk_rtsk->wobjid = FLGID(((WINFO_FLG *)(p_tcb->p_winfo))
150,153c156,159
< 				break;
< 			case TS_WAITING_SDTQ:
< 				pk_rtsk->tskwait = TTW_SDTQ;
< 				pk_rtsk->wobjid = DTQID(((WINFO_SDTQ *)(p_tcb->p_winfo))
---
> 					break;
> 				case TS_WAITING_SDTQ:
> 					pk_rtsk->tskwait = TTW_SDTQ;
> 					pk_rtsk->wobjid = DTQID(((WINFO_SDTQ *)(p_tcb->p_winfo))
155,158c161,164
< 				break;
< 			case TS_WAITING_RDTQ:
< 				pk_rtsk->tskwait = TTW_RDTQ;
< 				pk_rtsk->wobjid = DTQID(((WINFO_RDTQ *)(p_tcb->p_winfo))
---
> 					break;
> 				case TS_WAITING_RDTQ:
> 					pk_rtsk->tskwait = TTW_RDTQ;
> 					pk_rtsk->wobjid = DTQID(((WINFO_RDTQ *)(p_tcb->p_winfo))
160,163c166,169
< 				break;
< 			case TS_WAITING_SPDQ:
< 				pk_rtsk->tskwait = TTW_SPDQ;
< 				pk_rtsk->wobjid = PDQID(((WINFO_SPDQ *)(p_tcb->p_winfo))
---
> 					break;
> 				case TS_WAITING_SPDQ:
> 					pk_rtsk->tskwait = TTW_SPDQ;
> 					pk_rtsk->wobjid = PDQID(((WINFO_SPDQ *)(p_tcb->p_winfo))
165,168c171,174
< 				break;
< 			case TS_WAITING_RPDQ:
< 				pk_rtsk->tskwait = TTW_RPDQ;
< 				pk_rtsk->wobjid = PDQID(((WINFO_RPDQ *)(p_tcb->p_winfo))
---
> 					break;
> 				case TS_WAITING_RPDQ:
> 					pk_rtsk->tskwait = TTW_RPDQ;
> 					pk_rtsk->wobjid = PDQID(((WINFO_RPDQ *)(p_tcb->p_winfo))
170,173c176,179
< 				break;
< 			case TS_WAITING_MTX:
< 				pk_rtsk->tskwait = TTW_MTX;
< 				pk_rtsk->wobjid = MTXID(((WINFO_MTX *)(p_tcb->p_winfo))
---
> 					break;
> 				case TS_WAITING_MTX:
> 					pk_rtsk->tskwait = TTW_MTX;
> 					pk_rtsk->wobjid = MTXID(((WINFO_MTX *)(p_tcb->p_winfo))
175,178c181,184
< 				break;
< 			case TS_WAITING_SMBF:
< 				pk_rtsk->tskwait = TTW_SMBF;
< 				pk_rtsk->wobjid = MBFID(((WINFO_SMBF *)(p_tcb->p_winfo))
---
> 					break;
> 				case TS_WAITING_SMBF:
> 					pk_rtsk->tskwait = TTW_SMBF;
> 					pk_rtsk->wobjid = MBFID(((WINFO_SMBF *)(p_tcb->p_winfo))
181,183c187,189
< 			case TS_WAITING_RMBF:
< 				pk_rtsk->tskwait = TTW_RMBF;
< 				pk_rtsk->wobjid = MBFID(((WINFO_RMBF *)(p_tcb->p_winfo))
---
> 				case TS_WAITING_RMBF:
> 					pk_rtsk->tskwait = TTW_RMBF;
> 					pk_rtsk->wobjid = MBFID(((WINFO_RMBF *)(p_tcb->p_winfo))
185,188c191,194
< 				break;
< 			case TS_WAITING_MPF:
< 				pk_rtsk->tskwait = TTW_MPF;
< 				pk_rtsk->wobjid = MPFID(((WINFO_MPF *)(p_tcb->p_winfo))
---
> 					break;
> 				case TS_WAITING_MPF:
> 					pk_rtsk->tskwait = TTW_MPF;
> 					pk_rtsk->wobjid = MPFID(((WINFO_MPF *)(p_tcb->p_winfo))
190c196,208
< 				break;
---
> 					break;
> 				}
> 
> 				/*
> 		 		 *  タイムアウトするまでの時間の取出し
> 				 */
> 				if (p_tcb->p_winfo->p_tmevtb != NULL) {
> 					pk_rtsk->lefttmo			/*［NGKI1233］［NGKI1235］*/
> 							= (TMO) tmevt_lefttim(p_tcb->p_winfo->p_tmevtb);
> 				}
> 				else {
> 					pk_rtsk->lefttmo = TMO_FEVR;	/*［NGKI1234］*/
> 				}
194c212
< 	 		 *  タイムアウトするまでの時間の取出し
---
> 	 		 *  起床要求キューイング数の取出し［NGKI1239］
196,203c214
< 			if (p_tcb->p_winfo->p_tmevtb != NULL) {
< 				pk_rtsk->lefttmo				/*［NGKI1233］［NGKI1235］*/
< 						= (TMO) tmevt_lefttim(p_tcb->p_winfo->p_tmevtb);
< 			}
< 			else {
< 				pk_rtsk->lefttmo = TMO_FEVR;	/*［NGKI1234］*/
< 			}
< 		}
---
> 			pk_rtsk->wupcnt = p_tcb->wupque ? 1U : 0U;
205,208c216,219
< 		/*
<  		 *  起床要求キューイング数の取出し［NGKI1239］
< 		 */
< 		pk_rtsk->wupcnt = p_tcb->wupque ? 1U : 0U;
---
> 			/*
> 			 *  タスク終了要求状態の取出し［NGKI3467］
> 			 */
> 			pk_rtsk->raster = p_tcb->raster;
210,213c221,224
< 		/*
< 		 *  タスク終了要求状態の取出し［NGKI3467］
< 		 */
< 		pk_rtsk->raster = p_tcb->raster;
---
> 			/*
> 			 *  タスク終了禁止状態の取出し［NGKI3468］
> 			 */
> 			pk_rtsk->dister = !(p_tcb->enater);
215,218c226,230
< 		/*
< 		 *  タスク終了禁止状態の取出し［NGKI3468］
< 		 */
< 		pk_rtsk->dister = !(p_tcb->enater);
---
> 			/*
> 			 *  拡張サービスコールのネストレベルの取出し［NGKI1243］
> 			 */
> 			pk_rtsk->svclevel = p_tcb->svclevel;
> 		}
221c233
< 		 *  拡張サービスコールのネストレベルの取出し［NGKI1243］
---
> 		 *  起動要求キューイング数の取出し［NGKI1238］
223c235,236
< 		pk_rtsk->svclevel = p_tcb->svclevel;
---
> 		pk_rtsk->actcnt = p_tcb->actque ? 1U : 0U;
> 		ercd = E_OK;
225,230d237
< 
< 	/*
< 	 *  起動要求キューイング数の取出し［NGKI1238］
< 	 */
< 	pk_rtsk->actcnt = p_tcb->actque ? 1U : 0U;
< 	ercd = E_OK;
diff -r ./kernel/task_sync.c extension/dcre/kernel/task_sync.c
218d217
< 	CHECK_ACPTN(p_tcb->p_tinib->acvct.acptn1);	/*［NGKI1269］*/
221c220,226
< 	if (TSTAT_DORMANT(p_tcb->tstat)) {
---
> 	if (p_tcb->p_tinib->tskatr == TA_NOEXS) {
> 		ercd = E_NOEXS;							/*［NGKI1268］*/
> 	}
> 	else if (VIOLATE_ACPTN(p_tcb->p_tinib->acvct.acptn1)) {
> 		ercd = E_OACV;							/*［NGKI1269］*/
> 	}
> 	else if (TSTAT_DORMANT(p_tcb->tstat)) {
272d276
< 	CHECK_ACPTN(p_tcb->p_tinib->acvct.acptn1);	/*［NGKI1282］*/
275c279,285
< 	if (TSTAT_DORMANT(p_tcb->tstat)) {
---
> 	if (p_tcb->p_tinib->tskatr == TA_NOEXS) {
> 		ercd = E_NOEXS;							/*［NGKI1281］*/
> 	}
> 	else if (VIOLATE_ACPTN(p_tcb->p_tinib->acvct.acptn1)) {
> 		ercd = E_OACV;							/*［NGKI1282］*/
> 	}
> 	else if (TSTAT_DORMANT(p_tcb->tstat)) {
306d315
< 	CHECK_ACPTN(p_tcb->p_tinib->acvct.acptn2);	/*［NGKI1294］*/
309c318,324
< 	if (!TSTAT_WAITING(p_tcb->tstat)) {
---
> 	if (p_tcb->p_tinib->tskatr == TA_NOEXS) {
> 		ercd = E_NOEXS;							/*［NGKI1293］*/
> 	}
> 	else if (VIOLATE_ACPTN(p_tcb->p_tinib->acvct.acptn2)) {
> 		ercd = E_OACV;							/*［NGKI1294］*/
> 	}
> 	else if (!TSTAT_WAITING(p_tcb->tstat)) {
356d370
< 	CHECK_ACPTN(p_tcb->p_tinib->acvct.acptn2);	/*［NGKI1304］*/
361a376,381
> 	else if (p_tcb->p_tinib->tskatr == TA_NOEXS) {
> 		ercd = E_NOEXS;							/*［NGKI1303］*/
> 	}
> 	else if (VIOLATE_ACPTN(p_tcb->p_tinib->acvct.acptn2)) {
> 		ercd = E_OACV;							/*［NGKI1304］*/
> 	}
415d434
< 	CHECK_ACPTN(p_tcb->p_tinib->acvct.acptn2);	/*［NGKI1318］*/
418c437,443
< 	if (!TSTAT_SUSPENDED(p_tcb->tstat)) {
---
> 	if (p_tcb->p_tinib->tskatr == TA_NOEXS) {
> 		ercd = E_NOEXS;							/*［NGKI1317］*/
> 	}
> 	else if (VIOLATE_ACPTN(p_tcb->p_tinib->acvct.acptn2)) {
> 		ercd = E_OACV;							/*［NGKI1318］*/
> 	}
> 	else if (!TSTAT_SUSPENDED(p_tcb->tstat)) {
diff -r ./kernel/task_term.c extension/dcre/kernel/task_term.c
40c40
<  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
---
>  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
173d172
< 	CHECK_ACPTN(p_tcb->p_tinib->acvct.acptn2);	/*［NGKI3474］*/
176c175,181
< 	if (TSTAT_DORMANT(p_tcb->tstat)) {
---
> 	if (p_tcb->p_tinib->tskatr == TA_NOEXS) {
> 		ercd = E_NOEXS;							/*［NGKI3473］*/
> 	}
> 	else if (VIOLATE_ACPTN(p_tcb->p_tinib->acvct.acptn2)) {
> 		ercd = E_OACV;							/*［NGKI3474］*/
> 	}
> 	else if (TSTAT_DORMANT(p_tcb->tstat)) {
309d313
< 	CHECK_ACPTN(p_tcb->p_tinib->acvct.acptn3);	/*［NGKI3508］*/
313c317,323
< 	if (TSTAT_DORMANT(p_tcb->tstat)) {
---
> 	if (p_tcb->p_tinib->tskatr == TA_NOEXS) {
> 		ercd = E_NOEXS;							/*［NGKI1174］*/
> 	}
> 	else if (VIOLATE_ACPTN(p_tcb->p_tinib->acvct.acptn3)) {
> 		ercd = E_OACV;							/*［NGKI3508］*/
> 	}
> 	else if (TSTAT_DORMANT(p_tcb->tstat)) {
Only in ./kernel: taskhook.c
Only in ./kernel: taskhook.h
Only in ./kernel: time_event.c
Only in ./kernel: time_event.h
diff -r ./kernel/time_manage.c extension/dcre/kernel/time_manage.c
8c8
<  *  Copyright (C) 2005-2015 by Embedded and Real-Time Systems Laboratory
---
>  *  Copyright (C) 2005-2019 by Embedded and Real-Time Systems Laboratory
40c40
<  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
---
>  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
48a49,52
> #include "task.h"
> #include "semaphore.h"
> #include "eventflag.h"
> #include "dataqueue.h"
218a223,427
> 
> /*
>  *  通知方法のエラーチェック
>  */
> #ifdef TOPPERS_chknfy
> 
> ER
> check_nfyinfo(const T_NFYINFO *p_nfyinfo, ACPTN domptn)
> {
> 	ER		ercd;
> 
> 	if (p_nfyinfo->nfymode == TNFY_HANDLER) {
> 		CHECK_OACV(domptn == TACP_KERNEL);					/*［NGKI3695］*/
> 		CHECK_PAR(FUNC_ALIGN(p_nfyinfo->nfy.handler.tmehdr));
> 		CHECK_PAR(FUNC_NONNULL(p_nfyinfo->nfy.handler.tmehdr));
> 	}
> 	else {
> 		switch (p_nfyinfo->nfymode & 0x0fU) {
> 		case TNFY_SETVAR:
> 			CHECK_PAR((p_nfyinfo->nfymode & ~0x0fU) == 0);
> 			CHECK_PAR(INTPTR_ALIGN(p_nfyinfo->nfy.setvar.p_var));
> 			CHECK_PAR(INTPTR_NONNULL(p_nfyinfo->nfy.setvar.p_var));
> 			CHECK_MACV(domptn == TACP_KERNEL
> 				|| probe_mem_write_domptn((void *)
> 					(p_nfyinfo->nfy.setvar.p_var), sizeof(intptr_t), domptn));
> 			break;
> 		case TNFY_INCVAR:
> 			CHECK_PAR((p_nfyinfo->nfymode & ~0x0fU) == 0);
> 			CHECK_PAR(INTPTR_ALIGN(p_nfyinfo->nfy.incvar.p_var));
> 			CHECK_PAR(INTPTR_NONNULL(p_nfyinfo->nfy.incvar.p_var));
> 			CHECK_MACV(domptn == TACP_KERNEL
> 				|| probe_mem_rw_domptn((void *)
> 					(p_nfyinfo->nfy.incvar.p_var), sizeof(intptr_t), domptn));
> 			break;
> 		case TNFY_ACTTSK:
> 			CHECK_ID(VALID_TSKID(p_nfyinfo->nfy.acttsk.tskid));
> 			CHECK_OACV(domptn == TACP_KERNEL
> 						|| (domptn & (get_tcb(p_nfyinfo->nfy.acttsk.tskid)
> 											->p_tinib->acvct.acptn1)) != 0U);
> 			break;
> 		case TNFY_WUPTSK:
> 			CHECK_ID(VALID_TSKID(p_nfyinfo->nfy.wuptsk.tskid));
> 			CHECK_OACV(domptn == TACP_KERNEL
> 						|| (domptn & (get_tcb(p_nfyinfo->nfy.wuptsk.tskid)
> 											->p_tinib->acvct.acptn1)) != 0U);
> 			break;
> 		case TNFY_SIGSEM:
> 			CHECK_ID(VALID_SEMID(p_nfyinfo->nfy.sigsem.semid));
> 			CHECK_OACV(domptn == TACP_KERNEL
> 						|| (domptn & (get_semcb(p_nfyinfo->nfy.sigsem.semid)
> 											->p_seminib->acvct.acptn1)) != 0U);
> 			break;
> 		case TNFY_SETFLG:
> 			CHECK_ID(VALID_FLGID(p_nfyinfo->nfy.setflg.flgid));
> 			CHECK_OACV(domptn == TACP_KERNEL
> 						|| (domptn & (get_flgcb(p_nfyinfo->nfy.setflg.flgid)
> 											->p_flginib->acvct.acptn1)) != 0U);
> 			break;
> 		case TNFY_SNDDTQ:
> 			CHECK_ID(VALID_DTQID(p_nfyinfo->nfy.snddtq.dtqid));
> 			CHECK_OACV(domptn == TACP_KERNEL
> 						|| (domptn & (get_dtqcb(p_nfyinfo->nfy.snddtq.dtqid)
> 											->p_dtqinib->acvct.acptn1)) != 0U);
> 			break;
> 		default:
> 			CHECK_PAR(false);
> 			break;
> 		}
> 		switch (p_nfyinfo->nfymode & ~0x0fU) {
> 		case 0:
> 			break;
> 		case TENFY_SETVAR:
> 			CHECK_PAR(INTPTR_ALIGN(p_nfyinfo->enfy.setvar.p_var));
> 			CHECK_PAR(INTPTR_NONNULL(p_nfyinfo->enfy.setvar.p_var));
> 			CHECK_MACV(domptn == TACP_KERNEL
> 				|| probe_mem_write_domptn((void *)
> 					(p_nfyinfo->enfy.setvar.p_var), sizeof(intptr_t), domptn));
> 			break;
> 		case TENFY_INCVAR:
> 			CHECK_PAR(INTPTR_ALIGN(p_nfyinfo->enfy.incvar.p_var));
> 			CHECK_PAR(INTPTR_NONNULL(p_nfyinfo->enfy.incvar.p_var));
> 			CHECK_MACV(domptn == TACP_KERNEL
> 				|| probe_mem_rw_domptn((void *)
> 					(p_nfyinfo->enfy.incvar.p_var), sizeof(intptr_t), domptn));
> 			break;
> 		case TENFY_ACTTSK:
> 			CHECK_ID(VALID_TSKID(p_nfyinfo->enfy.acttsk.tskid));
> 			CHECK_OACV(domptn == TACP_KERNEL
> 						|| (domptn & (get_tcb(p_nfyinfo->enfy.acttsk.tskid)
> 											->p_tinib->acvct.acptn1)) != 0U);
> 			break;
> 		case TENFY_WUPTSK:
> 			CHECK_ID(VALID_TSKID(p_nfyinfo->enfy.wuptsk.tskid));
> 			CHECK_OACV(domptn == TACP_KERNEL
> 						|| (domptn & (get_tcb(p_nfyinfo->enfy.wuptsk.tskid)
> 											->p_tinib->acvct.acptn1)) != 0U);
> 			break;
> 		case TENFY_SIGSEM:
> 			CHECK_ID(VALID_SEMID(p_nfyinfo->enfy.sigsem.semid));
> 			CHECK_OACV(domptn == TACP_KERNEL
> 						|| (domptn & (get_semcb(p_nfyinfo->enfy.sigsem.semid)
> 											->p_seminib->acvct.acptn1)) != 0U);
> 			break;
> 		case TENFY_SETFLG:
> 			CHECK_ID(VALID_FLGID(p_nfyinfo->enfy.setflg.flgid));
> 			CHECK_OACV(domptn == TACP_KERNEL
> 						|| (domptn & (get_flgcb(p_nfyinfo->enfy.setflg.flgid)
> 											->p_flginib->acvct.acptn1)) != 0U);
> 			break;
> 		case TENFY_SNDDTQ:
> 			CHECK_ID(VALID_DTQID(p_nfyinfo->enfy.snddtq.dtqid));
> 			CHECK_OACV(domptn == TACP_KERNEL
> 						|| (domptn & (get_dtqcb(p_nfyinfo->enfy.snddtq.dtqid)
> 											->p_dtqinib->acvct.acptn1)) != 0U);
> 			break;
> 		default:
> 			CHECK_PAR(false);
> 			break;
> 		}
> 	}
> 	ercd = E_OK;
> 
>   error_exit:
> 	return(ercd);
> }
> 
> #endif /* TOPPERS_chknfy */
> 
> /*
>  *  通知ハンドラ
>  */
> #ifdef TOPPERS_nfyhdr
> 
> void
> notify_handler(intptr_t exinf)
> {
> 	T_NFYINFO	*p_nfyinfo = (T_NFYINFO *) exinf;
> 	ER			ercd;
> 
> 	switch (p_nfyinfo->nfymode & 0x0fU) {
> 	case TNFY_SETVAR:
> 		*(p_nfyinfo->nfy.setvar.p_var) = p_nfyinfo->nfy.setvar.value;
> 		ercd = E_OK;
> 		break;
> 	case TNFY_INCVAR:
> 		(void) loc_cpu();
> 		*(p_nfyinfo->nfy.incvar.p_var) += 1;
> 		(void) unl_cpu();
> 		ercd = E_OK;
> 		break;
> 	case TNFY_ACTTSK:
> 		ercd = act_tsk(p_nfyinfo->nfy.acttsk.tskid);
> 		break;
> 	case TNFY_WUPTSK:
> 		ercd = wup_tsk(p_nfyinfo->nfy.wuptsk.tskid);
> 		break;
> 	case TNFY_SIGSEM:
> 		ercd = sig_sem(p_nfyinfo->nfy.sigsem.semid);
> 		break;
> 	case TNFY_SETFLG:
> 		ercd = set_flg(p_nfyinfo->nfy.setflg.flgid,
> 							p_nfyinfo->nfy.setflg.flgptn);
> 		break;
> 	case TNFY_SNDDTQ:
> 		ercd = psnd_dtq(p_nfyinfo->nfy.snddtq.dtqid,
> 							p_nfyinfo->nfy.snddtq.data);
> 		break;
> 	default:
> 		ercd = E_SYS;
> 		break;
> 	}
> 
> 	if (ercd != E_OK) {
> 		switch (p_nfyinfo->nfymode & ~0x0fU) {
> 		case TENFY_SETVAR:
> 			*(p_nfyinfo->enfy.setvar.p_var) = (intptr_t) ercd;
> 			break;
> 		case TENFY_INCVAR:
> 			(void) loc_cpu();
> 			*(p_nfyinfo->enfy.incvar.p_var) += 1;
> 			(void) unl_cpu();
> 			break;
> 		case TENFY_ACTTSK:
> 			(void) act_tsk(p_nfyinfo->enfy.acttsk.tskid);
> 			break;
> 		case TENFY_WUPTSK:
> 			(void) wup_tsk(p_nfyinfo->enfy.wuptsk.tskid);
> 			break;
> 		case TENFY_SIGSEM:
> 			(void) sig_sem(p_nfyinfo->enfy.sigsem.semid);
> 			break;
> 		case TENFY_SETFLG:
> 			(void) set_flg(p_nfyinfo->enfy.setflg.flgid,
> 							p_nfyinfo->enfy.setflg.flgptn);
> 			break;
> 		case TENFY_SNDDTQ:
> 			(void) psnd_dtq(p_nfyinfo->enfy.snddtq.dtqid, (intptr_t) ercd);
> 			break;
> 		default:
> 			break;
> 		}
> 	}
> }
> 
> #endif /* TOPPERS_nfyhdr */
Only in ./kernel: wait.c
Only in ./kernel: wait.h
Only in .: library
Only in ./sample: Makefile
Only in ./sample: Makefile_mml
diff -r ./sample/sample1.c extension/dcre/sample/sample1.c
40c40
<  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
---
>  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
112a113,116
>  *  '@' : タスク3をacre_tskにより生成する．
>  *  '!' : 対象タスクをdel_tskにより削除する．
>  *  '$' : アラームハンドラをacre_almにより生成する．
>  *  '#' : アラームハンドラをdel_almにより削除する．
167a172,183
>  *  動的生成するオブジェクトのID
>  */
> ID		TASK3 = -1;
> ID		ALMHDR1 = -1;
> 
> /*
>  *  TASK3のユーザスタック領域（ターゲット依存，GCC依存）
>  */
> char user_stack_TASK3[STACK_SIZE]
> 		__attribute__((section(".noinit_DOM2"),nocommon,aligned(4096)));
> 
> /*
343a360,361
> 	T_CTSK	ctsk;
> 	T_CALM	calm;
411d428
< 	SVC_PERROR(act_tsk(TASK3));
535a553,587
> 		case '@':
> 			ctsk.tskatr = TA_DOM(DOM2);
> 			ctsk.exinf = 3;
> 			ctsk.task = task;
> 			ctsk.itskpri = MID_PRIORITY;
> 			ctsk.stksz = STACK_SIZE;
> 			ctsk.stk = (STK_T *) user_stack_TASK3;
> 			ctsk.sstksz = STACK_SIZE;
> 			ctsk.sstk = NULL;
> 			SVC_PERROR(ercd = acre_tsk(&ctsk));
> 			if (ercd >= 0) {
> 				TASK3 = ercd;
> 				syslog(LOG_NOTICE, "task3 is created with tskid = %d.",
> 														(int_t) TASK3);
> 			}
> 			break;
> 		case '!':
> 			syslog(LOG_INFO, "#del_tsk(%d)", tskno);
> 			SVC_PERROR(del_tsk(tskid));
> 			break;
> 		case '$':
> 			calm.almatr = TA_DOM(DOM1);
> 			calm.nfyinfo.nfymode = TNFY_ACTTSK;
> 			calm.nfyinfo.nfy.acttsk.tskid = ALM_TASK;
> 			SVC_PERROR(ercd = acre_alm(&calm));
> 			if (ercd >= 0) {
> 				ALMHDR1 = ercd;
> 				syslog(LOG_NOTICE, "alarm handler is created with almid = %d.",
> 														(int_t) ALMHDR1);
> 			}
> 			break;
> 		case '#':
> 			syslog(LOG_INFO, "#del_alm(ALMHDR1)");
> 			SVC_PERROR(del_alm(ALMHDR1));
> 			break;
Only in ./sample: sample1.cdl
diff -r ./sample/sample1.cfg extension/dcre/sample/sample1.cfg
4c4
<  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
---
>  *  $Id: DIFF 773 2019-10-02 09:01:03Z ertl-hiro $
27c27,28
< 	CRE_ALM(ALMHDR1, { TA_NULL, { TNFY_ACTTSK, ALM_TASK }});
---
> 	AID_ALM(1)
> 	DEF_MPK({ STACK_SIZE * 4 });
31c32,34
< 	CRE_TSK(TASK3, { TA_NULL, 3, task, MID_PRIORITY, STACK_SIZE, NULL });
---
> 	AID_TSK(3)
> 	DEF_MPK({ STACK_SIZE * 4 });
> 	ATT_SEC(".noinit_DOM2", { TA_NOINITSEC, "RAM" });
55a59
> DEF_MPK({ STACK_SIZE * 8 });
Only in ./sample: sample1.h
Only in ./sample: tSample2.c
Only in ./sample: tSample2.cdl
Only in ./sample: tSample2.cfg
Only in ./sample: tSample2.h
Only in .: syssvc
Only in .: target
Only in .: tecs_kernel
Only in .: tecsgen
Only in .: test
Only in .: utils
