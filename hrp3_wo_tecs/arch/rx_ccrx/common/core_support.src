;
;   TOPPERS/ASP Kernel
;       Toyohashi Open Platform for Embedded Real-Time Systems/
;       Advanced Standard Profile Kernel
;
;   Copyright (C) 2000-2003 by Embedded and Real-Time Systems Laboratory
;                               Toyohashi Univ. of Technology, JAPAN
;   Copyright (C) 2007      by Embedded and Real-Time Systems Laboratory
;               Graduate School of Information Science, Nagoya Univ., JAPAN
;   Copyright (C) 2010 by Witz Corporation, JAPAN
;   Copyright (C) 2013      by Mitsuhiro Matsuura
;
;   上記著作権者は，以下の(1)～(4)の条件を満たす場合に限り，本ソフトウェ
;   ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
;   変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
;   (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
;       権表示，この利用条件および下記の無保証規定が，そのままの形でソー
;       スコード中に含まれていること．
;   (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
;       用できる形で再配布する場合には，再配布に伴うドキュメント（利用
;       者マニュアルなど）に，上記の著作権表示，この利用条件および下記
;       の無保証規定を掲載すること．
;   (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
;       用できない形で再配布する場合には，次のいずれかの条件を満たすこ
;       と．
;     (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
;         作権表示，この利用条件および下記の無保証規定を掲載すること．
;     (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
;         報告すること．
;   (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
;       害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
;       また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
;       由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
;       免責すること．
;
;   本ソフトウェアは，無保証で提供されているものである．上記著作権者お
;   よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
;   に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
;   アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
;   の責任を負わない．
;
;

;
;  コア依存モジュール アセンブリ言語部（RX用）
;
;  References:
;  [1] RX Family RXv2 Instruction Set Architecture
;  [2] CC-RX User's Manual
;

;
;  構造体アクセスのオフセット定義
;
	.include	offset.h

;
;  各種EQU定義(Hファイルの#define定義)
;
	.glb	__kernel_exit_kernel
	.glb	__kernel_ext_tsk
	.glb	__kernel_intnest
	.glb	__kernel_istkpt
	.glb	__kernel_p_runtsk
	.glb	__kernel_p_schedtsk
	.glb	__kernel_rundom
	.glb	__kernel_svc_table
	.glb	__kernel_svcinib_table
	.glb	__kernel_tmax_fncd
	.glb	__kernel_twdtimer_enable
	.glb	__kernel_twdtimer_start
	.glb	__kernel_twdtimer_stop
	.glb	__kernel_twdtimer_control
.if	TIPM_LOCK != TIPM_LOCK_ALL
	.glb	__kernel_lock_flag
	.glb	__kernel_saved_ipl
.endif

	.glb	__kernel_dispatch
	.glb	__kernel_exit_and_dispatch
	.glb	__kernel_start_stask_r
	.glb	__kernel_start_utask_r
	.glb	_kernel_interrupt
	.glb	_kernel_exception
	.glb	_kernel_service_call
	.glb	__kernel_call_exit_kernel
	.glb	__kernel_start_dispatch

;
;  TCB_sp への書込みマクロ
;
st_TCB_sp	.macro	src, tcb, tmp
.if (TCB_sp % 4) == 0
	mov.l	src, TCB_sp[tcb]
.else
	add		#TCB_sp, tcb, tmp
	mov.l	src, [tmp]
.endif
.endm

;
;  TCB_sp からの読出しマクロ
;
ld_TCB_sp	.macro	dst, tcb, tmp
.if (TCB_sp % 4) == 0
	mov.l	TCB_sp[tcb], dst
.else
	add		#TCB_sp, tcb, tmp
	mov.l	[tmp], dst
.endif
.endm

;
;  TCB_pc への書込みマクロ
;
st_TCB_pc	.macro	src, tcb, tmp
.if (TCB_pc % 4) == 0
	mov.l	src, TCB_pc[tcb]
.else
	add		#TCB_pc, tcb, tmp
	mov.l	src, [tmp]
.endif
.endm

;
;  TCB_pc からの読出しマクロ
;
ld_TCB_pc	.macro	dst, tcb, tmp
.if (TCB_pc % 4) == 0
	mov.l	TCB_pc[tcb], dst
.else
	add		#TCB_pc, tcb, tmp
	mov.l	[tmp], dst
.endif
.endm

;
;  TCB_p_tinib からの読出しマクロ
;
ld_TCB_p_tinib	.macro	dst, tcb, tmp
.if (TCB_p_tinib % 4) == 0
	mov.l	TCB_p_tinib[tcb], dst
.else
	add		#TCB_p_tinib, tcb, tmp
	mov.l	[tmp], dst
.endif
.endm

;
;  TINIB_exinf からの読出しマクロ
;
ld_TINIB_exinf	.macro	dst, tinib, tmp
.if (TINIB_exinf % 4) == 0
	mov.l	TINIB_exinf[tinib], dst
.else
	add		#TINIB_exinf, tinib, tmp
	mov.l	[tmp], dst
.endif
.endm

;
;  TINIB_task からの読出しマクロ
;
ld_TINIB_task	.macro	dst, tinib, tmp
.if (TINIB_task % 4) == 0
	mov.l	TINIB_task[tinib], dst
.else
	add		#TINIB_task, tinib, tmp
	mov.l	[tmp], dst
.endif
.endm

	.section	P, CODE

;
;  APIからのタスクディスパッチャ入口
;
;  呼び出し条件:
;	・ディスパッチャモード(ファイルヘッダ参照)
;
;  ここでは, コンテキストの退避と, 実行再開番地の設定をする.
;
__kernel_dispatch:
	mov.l	#__kernel_rundom, r4		; rundomを取得
	mov.l	[r4], r4
	mvfc	usp, r5						; uspを取得
	pushm	r4-r13						; rundom、uspと非スクラッチレジスタ保存
	mov.l	#__kernel_p_runtsk, r15
	mov.l	[r15], r14
	st_TCB_sp	r0, r14, r5				; スタックポインタをTCBに保存
	st_TCB_pc	#dispatch_r, r14, r5	; 実行再開番地をTCBに保存
	bra		dispatcher

;
;  APIへのタスクディスパッチャ出口
;
;  呼び出し条件:
;	・ディスパッチャモード(ファイルヘッダ参照)
;
;  ここでは, タスク例外ハンドラ呼出しと, コンテキストの復帰をする.
;
dispatch_r:
	popm 	r4-r13							; rundom、uspと非スクラッチレジスタ復帰
	mov.l	#__kernel_rundom, r3
	mov.l	r4, [r3]
	mvtc	r5, usp
	mov.l	#__kernel_twdtimer_enable, r1	; twdtimer_enableがtrueの場合
	mov.l	[r1], r1
	cmp		#0, r1
	beq		dispatch_r_after_twd
	bsr		__kernel_twdtimer_control		; タイムウィンドウタイマの切換え
dispatch_r_after_twd:
	rts  	                        		; dispatch 呼び出し元へ戻る.

;
;  タスクの終了処理
;
call_ext_tsk:
	mov.l	#TFN_EXT_TSK, r5
	int		#SVC_SERVICE_CALL
	mov.l	#TFN_EXT_KER, r5
	int		#SVC_SERVICE_CALL
call_ext_tsk_loop:
	bra		call_ext_tsk_loop

;
;  システムタスクの実行開始時処理
;
;  呼び出し条件:
;	・ディスパッチャモード(ファイルヘッダ参照)
;   ・r6：p_runtskの値（タスク切換え後）
;
;  ここでは, CPUロック解除状態にし, タスクを起動する.
;
__kernel_start_stask_r:
	mov.l	#__kernel_rundom, r1
	mov.l	#0, [r1]						; TACP_KERNEL → rundom
	mov.l	#__kernel_twdtimer_enable, r1	; twdtimer_enableがtrueの場合
	mov.l	[r1], r1
	cmp		#0, r1
	beq		start_stask_r_1
	bsr		__kernel_twdtimer_stop			; タイムウィンドウタイマの停止
start_stask_r_1:
.if	TIPM_LOCK == TIPM_LOCK_ALL
	setpsw	i							; 割込み許可(CPUロック解除状態)
.else
	mov.l	#__kernel_lock_flag, r4		; CPUロック解除状態へ
	mov.l	#0, [r4]					; ここに来るときは必ず saved_ipl の
	mvtc	#00010000H, psw				; 値は 0 のため, 直値を設定する.
										; 全割込みロック解除状態( I = 1 )
										; 割込み優先度マスク全解除状態( IPL = 0 )
.endif
	mov.l 	#__kernel_ext_tsk, r5
	push.l	r5							; 戻り番地をスタックに積む
	ld_TCB_p_tinib	r5, r6, r4
	ld_TINIB_exinf	r1, r5, r4			; 拡張情報を第一引数に設定
	ld_TINIB_task	r5, r5, r4			; タスクの起動番地を取得
	jmp		r5

;
;  ユーザタスクの実行開始時処理
;
;  呼び出し条件:
;	・ディスパッチャモード(ファイルヘッダ参照)
;   ・r6：p_runtskの値（タスク切換え後）
;
;  ここでは, CPUロック解除状態にし, タスクを起動する.
;
__kernel_start_utask_r:
	mov.l	TCB_p_dominib[r6], r1			; p_runtsk->p_dominib → r1
	mov.l	DOMINIB_domptn[r1], r2			; p_dominib->domptn → r2
	mov.l	#__kernel_rundom, r1
	mov.l	r2, [r1]						; r2 → rundom
	mov.l	#__kernel_twdtimer_enable, r1	; twdtimer_enableがtrueの場合
	mov.l	[r1], r1
	cmp		#0, r1
	beq		start_utask_r_1
	bsr		__kernel_twdtimer_start			; タイムウィンドウタイマの動作開始
start_utask_r_1:
	mov.l	TCB_p_tinib[r6], r1				; p_runtsk->p_tinib → r1
	mov.l	TINIB_ustk[r1], r2				; p_tinib->ustk → r2
	mov.l	TINIB_ustksz[r1], r3			; p_tinib->ustksz → r3
	add		r3, r2							; ユーザスタックの初期値 → r2
	mvtc	r2, usp							; r2 → usp

	mov.l	TINIB_task[r1], r2				; タスク起動番地 → r2
	mov.l	#00130000H, r3					; PSWの初期値（U、I、PM） → r3
	mov.l	#call_ext_tsk, r4				; 戻り番地  → r4
	pushm	r2-r4							; r4、r3、r2の順でスタックに積む

.if	TIPM_LOCK != TIPM_LOCK_ALL
	mov.l	#__kernel_lock_flag, r4
	mov.l	#0, [r4]
.endif

	mov.l	TINIB_exinf[r1], r1				; exinfをパラメータに
	rte

;
;  カーネル起動からのタスクディスパッチャ入口
;
;  このルーチンは，カーネル起動時に，すべての割込みを禁止した状態
; （割込みロック状態と同等）で呼び出される．また，割込みモード（非
;  タスクコンテキストと同等）で呼び出されることを想定している．
;
;  呼び出し条件:
;	・割込み(CPU例外)処理モード(ファイルヘッダ参照)
;
;  ここでは, ディスパッチャモードに変更する.
;
__kernel_start_dispatch:
	mov.l	#__kernel_intnest, r5
	mov.w	#0, [r5]					; タスクコンテキストに切換え
.if	TIPM_LOCK != TIPM_LOCK_ALL
	mvtc	#(IPL_LOCK | 00010000H), psw	; 全割込みロック解除状態
										; 割込み優先度マスク全解除でない状態
.endif

;
; タスク終了(現在のコンテキストを捨てる)からのタスクディスパッチャ入口
;
;  呼び出し条件:
;	・ディスパッチャモード(ファイルヘッダ参照)
;
;  ここでは, 何もすることはない.
;  なお, p_runtsk のアドレス取得だけは行なう.
;
__kernel_exit_and_dispatch:
	mov.l	#__kernel_p_runtsk, r15

;
; ディスパッチャ本体
;
;  呼び出し条件:
;	・すべてのタスクのコンテキストは保存されている.
;	・r14:p_runtskの値（ディスパッチ元TCB）
;	・r15:p_runtskのアドレス
;
;  dispatcher 呼出時のスタック:
;	・__kernel_dispatch からきた場合			: タスクスタック
;	・exit_and_dispatch からきた場合:
;		exit_task からきた場合					: タスクスタック
;		カーネル起動時(__kernel_start_dispatch)	: 割込みスタック
;	・ret_int からきた場合						: タスクスタック
;	・dispatcher_idle_loop からきた場合			: 割込みスタック
;
dispatcher:
.if	LOG_DSP_ENTER == 1
	push.l	r15
	mov.l	r14, r1						; 引数(ディスパッチ元TCB)を設定
	bsr		_kernel_log_dsp_enter
	pop.l	r15
.endif
dispatcher_0:
	mov.l	#__kernel_p_schedtsk, r5
	mov.l	[r5], r6					; p_schedtsk を p_runtsk に
	mov.l	r6, [r15]
	cmp		#0, r6
	bz		dispatcher_pre_idle			; schedtsk がなければアイドルループへ
	ld_TCB_sp	r0, r6, r5				; タスクスタックポインタを復帰
.if	LOG_DSP_LEAVE == 1
	mov.l	r6, r1						; 引数(ディスパッチ先TCB)を設定
	bsr		_kernel_log_dsp_leave
.endif
	ld_TCB_pc	r5, r6, r4
	jmp		r5					; 実行再開番地へジャンプ

;
;  schdedtskがNULLの場合はアイドルループに入る
;  アイドルループは割込み処理モードで動作させる
;
dispatcher_pre_idle:
	mov.l	#__kernel_twdtimer_enable, r1	; twdtimer_enableがtrueの場合
	mov.l	[r1], r1
	cmp		#0, r1
	beq		dispatcher_pre_idle_after_twd
	bsr		__kernel_twdtimer_start			; タイムウィンドウタイマの動作開始
dispatcher_pre_idle_after_twd:

.if	TIPM_LOCK != TIPM_LOCK_ALL
	mov.l	#__kernel_lock_flag, r5		; CPUロック解除状態へ
	mov.l	#0, [r5]
	mvtc	#0, psw						; 優先度0の割込み処理中を偽装
.endif
dispatcher_idle_loop:
	setpsw	i							; 全割込み許可
	clrpsw	i							; 全割込み禁止
	bra   	dispatcher_idle_loop		; アイドルループを繰り返す

;
; カーネルの終了処理の呼出し
;
; モードとスタックを非タスクコンテキスト用に切り替え．
;
__kernel_call_exit_kernel:
.if	TIPM_LOCK != TIPM_LOCK_ALL
	clrpsw	i							; 全割込み禁止
	mov.l	#__kernel_lock_flag, r5		; CPUロック解除状態へ
	mov.l	#0, [r5]
.endif
	mov.l	#__kernel_istkpt, r5
	mov.l	[r5], r0					; 割込み用のスタックへ切替え
	mov.l	#__kernel_intnest, r5
	mov.w	#1, [r5]					; 非タスクコンテキストに切換え
	bsr		__kernel_exit_kernel
	bra		__kernel_call_exit_kernel

;
;  割込みの出入口処理(アセンブリ言語記述部分)
;
;  呼出し条件:
;  ・割込み発生時のH/W処理により, PSWレジスタのIビット=0, IPLは受付け
;    た割込みのIPL.
;  ・スタックは多重割り込みなら割込みスタック, そうでなければ
;    タスクスタック
;  ・割込み発生時のH/W処理により,スタックに割込みからの復帰PCとPSWが
;    保存されている.
;  ・ベクタテーブルに登録された個別の入り口処理により, スタックに
;    スクラッチレジスタ(R1-R5)が保存されている.
;
;  引数:
;  ・r1:割込み要因番号
;  ・r2:割込みハンドラのアドレス
;
;  レジスタがスタック上にどのように保存されているかを以下に示す.
;  この図では上が低位, 下が高位のアドレスで, スタックは下から
;  上方向に向かって積み上げられるものとする.
;
;	-------------------------
;	|       ACC-HI(4byte)   |
;	-------------------------(SP + 0)
;	|       ACC-LO(4byte)   |
;	-------------------------(SP + 4)
;	|       FPSW(4byte)     |
;	-------------------------(SP + 8)
;	|       R14(4byte)      |
;	-------------------------(SP + 12)
;	|       R15(4byte)      |
;	-------------------------(SP + 16)
;	|       R1(4byte)       |
;	-------------------------(SP + 20)
;	|       R2(4byte)       |
;	-------------------------(SP + 24)
;	|       R3(4byte)       |
;	-------------------------(SP + 28)
;	|       R4(4byte)       |
;	-------------------------(SP + 32)
;	|       R5(4byte)       |
;	-------------------------(SP + 36)
;	|       PC(4byte)       |
;	-------------------------(SP + 40)
;	|       PSW(4byte)      |
;	-------------------------(SP + 44)
;
;  ここでは, 割込み処理モードに変更してハンドラを実行する.
;
;  多重割込みかどうかは割込みネストカウンタの値で判定する.
;  intnest != 0 ならば多重割込みであると判定する.
;
;

;
;  ret_int先頭でスタックに積まれているPSWレジスタへのオフセット
;  ACC + FPSW + R14--R15 + R1--R5 + PC
;
	RET_INT_GET_PSW_OFFSET	.equ	(8+4+28+4)

_kernel_interrupt:
	pushm	r14-r15						; スクラッチレジスタを退避
	pushc	fpsw						; FPUステータスレジスタ退避
	mvfacmi	r5
	shll	#16, r5						; ACC最下位16bitは0とする
	mvfachi	r4
	pushm	r4-r5						; アキュムレータ退避
	mov.l	#__kernel_intnest, r5
	mov.w	[r5], r4
	add		#1, r4						; ネスト回数をインクリメント
	mov.w	r4, [r5]
	cmp		#1, r4						; 多重割り込みかどうか
	bnz		interrupt_from_int			; 加算前が0でなければ多重割込み

										; 初段の割込み

	mov.l	#__kernel_twdtimer_enable, r3	; twdtimer_enableがtrueの場合
	mov.l	[r3], r3
	cmp		#0, r3
	beq		_kernel_interrupt_1
	pushm	r1-r2
	bsr		__kernel_twdtimer_stop			; タイムウィンドウタイマの停止
	popm	r1-r2
_kernel_interrupt_1:

	;
	;  rundomをスタックに保存し，TACP_KERNELにする．
	;
	mov.l	#__kernel_rundom, r3
	mov.l	[r3], r4
	pushm	r3-r4							; rundomの番地と値をスタックに保存
	mov.l	#0, [r3]						; TACP_KERNEL → rundom

	;
	;  非タスクコンテキスト用のスタックに切り換える．
	;
	mov.l	r0, r3						; スタックポインタを取り出し
	mov.l	#__kernel_istkpt, r5		; 割込み用のスタックへ切替える
	mov.l	[r5], r0
	push.l	r3							; タスクスタックを保持

interrupt_from_int:						; 多重割込み
	setpsw	i							; 割込み許可(CPUロック解除状態)

.if	LOG_INH_LEAVE == 1
	push.l	r1							; ログトレースの引数を保持
.endif

.if	LOG_INH_ENTER == 1
	push.l	r2
	bsr		_kernel_log_inh_enter		; ログトレース関数の呼出し
							; 引数の割込み要因番号は既にr1に入っている
	pop		r2
.endif

	jsr  	r2							; Cルーチン呼び出し

.if	LOG_INH_LEAVE == 1
	pop		r1							; 引数に割込み要因番号を設定
	bsr		_kernel_log_inh_leave		; ログトレース関数の呼出し
.endif

	clrpsw	i							; 割込み禁止(CPUロック状態)
	mov.l	#__kernel_intnest, r5
	mov.w	[r5], r4
	sub		#1, r4						; ネスト回数をデクリメント
	mov.w	r4, [r5]
	cmp		#0, r4						; 多重割り込みかどうか
	bnz		interrupt_return			; 多重割り込みならリターン
	; 初段の割込み
	pop		r0							; タスクのスタックに戻す
task_return:
	mov.l	#__kernel_p_runtsk, r15		; &(p_runtsk) → r15
	mov.l	[r15], r14					; p_runtsk → r14
	cmp		#0, r14
	bz		idle_task_return			; p_runtsk が NULLなら idle_task_return へ
	mov.l	#__kernel_p_schedtsk, r4	; p_schedtsk → r4
	mov.l	[r4], r4
	cmp		r4, r14
	beq		interrupt_return			; p_runtsk == p_schedtskなら interrupt_return へ
.if	TIPM_LOCK == TIPM_LOCK_ALL
	mov.l	RET_INT_GET_PSW_OFFSET[r0], r5	; 割込み/CPU例外発生前のIPL値取得
	and		#PSW_IPL_MASK, r5
	mvtc	r5, psw						; 全割込みロック(CPUロック)状態
										; 割込み/CPU例外発生前の割込み優先度
.else
	mov.l	#__kernel_lock_flag, r5		; CPUロック状態へ
	mov.l	#1, [r5]
	mov.l	RET_INT_GET_PSW_OFFSET[r0], r5	; 割込み/CPU例外発生前のIPL値取得
	and		#PSW_IPL_MASK, r5
	mov.l	#__kernel_saved_ipl, r4
	mov.l	r5, [r4]
	mvtc	#(IPL_LOCK | PSW_I_MASK), psw	; 全割込みロック解除状態
										; 割込み優先度マスク全解除でない状態
.endif
	mvfc	usp, r5						; uspを取得
	pushm	r5-r13						; uspとスクラッチレジスタを除くすべてのレジスタをスタックに保存する
	st_TCB_sp	r0, r14, r5				; スタックポインタを自タスク（p_runtsk）のTCBに保存する
	st_TCB_pc	#ret_int_r, r14, r5		; ret_int_rを，実行再開番地として自タスクのTCBに保存する
	bra		dispatcher					; dispatcherに分岐する
ret_int_r:
	popm 	r5-r13						; uspとスクラッチレジスタを除くすべてのレジスタをスタックから復帰する
	mvtc	r5, usp
interrupt_return:
	;
	;  rundomをスタックから復帰する．
	;
	popm	r3-r4							; rundomの番地と値をスタックから復帰
	mov.l	r4, [r3]

	mov.l	#__kernel_twdtimer_enable, r3	; twdtimer_enableがtrueの場合
	mov.l	[r3], r3
	cmp		#0, r3
	beq		interrupt_return_1
	bsr		__kernel_twdtimer_control		; タイムウィンドウタイマの切換え
interrupt_return_1:

	popm	r4-r5						; アキュムレータ復帰
	mvtaclo	r5							; ACC最下位16bitは0で復帰
	mvtachi	r4
	popc	fpsw						; FPUステータスレジスタ復帰
	popm	r14-r15						; レジスタ復帰
	popm	r1-r5
	rte									; 割込み前の処理に戻る
idle_task_return:
	add		#(8+44), r0					; タスクのスタックに保存したスクラッチレジスタ等を捨てる （PSWを除いて、11*4=44Bytes + rundomの番地と値）
.if	TIPM_LOCK == TIPM_LOCK_ALL
	pop		r5							; 割込み/CPU例外発生前のIPL値取得
	and		#PSW_IPL_MASK, r5
	mvtc	r5, psw						; 全割込みロック(CPUロック)状態
										; 割込み/CPU例外発生前の割込み優先度
.else
	mov.l	#__kernel_lock_flag, r5		; CPUロック状態へ
	mov.l	#1, [r5]
	pop		r5							; 割込み/CPU例外発生前のIPL値取得
	and		#PSW_IPL_MASK, r5
	mov.l	#__kernel_saved_ipl, r4
	mov.l	r5, [r4]
	mvtc	#(IPL_LOCK | PSW_I_MASK), psw	; 全割込みロック解除状態
										; 割込み優先度マスク全解除でない状態
.endif
	bra		dispatcher_0				; dispatcher_0に分岐する

;
;  CPU例外の出入口処理(アセンブリ言語記述部分)
;
;  呼出し条件:
;  ・CPU例外発生時のH/W処理により, PSWレジスタのIビット=0, IPL=0.
;  ・スタックは多重割り込みなら割込みスタック, そうでなければ
;    タスクスタック
;  ・CPU例外発生時のH/W処理により,スタックにCPU例外からの復帰PCと
;    PSWが保存されている.
;  ・ベクタテーブルに登録された個別の入り口処理により, スタックに
;    スクラッチレジスタ(R1-R5)が保存されている.
;
;  引数:
;  ・r1:CPU例外要因番号
;  ・r2:CPU例外ハンドラのアドレス
;
;  レジスタがスタック上にどのように保存されているかを以下に示す.
;  この図では上が低位, 下が高位のアドレスで, スタックは下から
;  上方向に向かって積み上げられるものとする.
;  なお, CPU例外要因番号とR6-R13はCPU例外ハンドラ内で情報を取得
;  する目的で退避しており, 出口処理では保存内容を破棄すればよい.
;
;	-------------------------
;	|    CPU例外要因番号    | <----- p_excinf
;	------------------------- (intptr_t)(p_excinf + 0)
;	|       R6(4byte)       |
;	------------------------- (intptr_t)(p_excinf + 4)
;	|       R7(4byte)       |
;	------------------------- (intptr_t)(p_excinf + 8)
;	|       R8(4byte)       |
;	------------------------- (intptr_t)(p_excinf + 12)
;	|       R9(4byte)       |
;	------------------------- (intptr_t)(p_excinf + 16)
;	|       R10(4byte)      |
;	------------------------- (intptr_t)(p_excinf + 20)
;	|       R11(4byte)      |
;	------------------------- (intptr_t)(p_excinf + 24)
;	|       R12(4byte)      |
;	------------------------- (intptr_t)(p_excinf + 28)
;	|       R13(4byte)      |
;	------------------------- (intptr_t)(p_excinf + 32)
;	|       ACC-HI(4byte)   |
;	------------------------- (intptr_t)(p_excinf + 36)
;	|       ACC-LO(4byte)   |
;	------------------------- (intptr_t)(p_excinf + 40)
;	|       FPSW(4byte)     |
;	------------------------- (intptr_t)(p_excinf + 44)
;	|       R14(4byte)      |
;	------------------------- (intptr_t)(p_excinf + 48)
;	|       R15(4byte)      |
;	------------------------- (intptr_t)(p_excinf + 52)
;	|       R1(4byte)       |
;	------------------------- (intptr_t)(p_excinf + 56)
;	|       R2(4byte)       |
;	------------------------- (intptr_t)(p_excinf + 60)
;	|       R3(4byte)       |
;	------------------------- (intptr_t)(p_excinf + 64)
;	|       R4(4byte)       |
;	------------------------- (intptr_t)(p_excinf + 68)
;	|       R5(4byte)       |
;	------------------------- (intptr_t)(p_excinf + 72)
;	|       PC(4byte)       |
;	------------------------- (intptr_t)(p_excinf + 76)
;	|       PSW(4byte)      |
;	------------------------- (intptr_t)(p_excinf + 80)
;
;  ここでは, 割込み処理モードに変更してハンドラを実行する.
;  CPU例外ハンドラに渡すVP型の変数 p_excinf としてISPの値渡す．
;
;  多重割込みかどうかは割込みネストカウンタの値で判定する.
;  intnest != 0 ならば多重割込みであると判定する.
;
;  CPU例外入口処理
;  ここでは, 割込み処理モードに変更してハンドラを実行する.
;

;
;  CPU例外ハンドラ呼出し後に不要となるスタック情報のサイズ
;  EXCNO + R6--R13
;
	EXCINF_REG_SIZE	.equ	(4+32)

_kernel_exception:
	pushm	r14-r15						; スクラッチレジスタを退避
	pushc	fpsw
	mvfacmi	r5
	shll	#16, r5						; ACC最下位16bitは0とする
	mvfachi	r4
	pushm	r4-r5						; アキュムレータ退避
	pushm	r6-r13						; 非スクラッチレジスタ保存
	push.l	r1							; CPU例外要因番号を保持
	mov.l	r0, r3						; スタックポインタを取り出し
	mov.l	EXC_GET_PSW_OFFSET[r3], r5
	and		#PSW_I_MASK, r5
	bz		exception_nonkernel			; 全割込み禁止(CPUロック)状態なら管理外
.if	TIPM_LOCK != TIPM_LOCK_ALL
	mov.l	EXC_GET_PSW_OFFSET[r3], r5
	and		#PSW_IPL_MASK, r5
	cmp		#IPL_LOCK, r5
	bgt	exception_nonkernel			; IPLがCPUロックレベル以上なら管理外
.endif
	mov.l	#__kernel_intnest, r5
	mov.w	[r5], r4
	add		#1, r4						; ネスト回数をインクリメント
	mov.w	r4, [r5]
	cmp		#1, r4						; 多重割り込みかどうか
	bnz		exception_from_int			; 加算前が0でなければ多重割込み
						; 初段の割込み
	mov.l	#__kernel_istkpt, r5		; 割込み用のスタックへ切替える
	mov.l	[r5], r0
	push.l	r3							; タスクスタックを保持
exception_from_int:		; 多重割込み
	mov.l	EXC_GET_PSW_OFFSET[r3], r5
	mvtc	r5, psw						; CPU例外発生前の状態に戻す
.if	LOG_EXC_LEAVE == 1
	push.l	r1							; ログトレースの引数を保持
.endif

.if	LOG_EXC_ENTER == 1
	pushm	r2-r3
	bsr		_kernel_log_exc_enter		; ログトレース関数の呼出し
							; 引数の割込み要因番号は既にr1に入っている
	popm	r2-r3
.endif

	mov.l	r3, r1						; 引数のp_excinfを設定
	jsr  	r2							; Cルーチン呼び出し

.if	LOG_EXC_LEAVE == 1
	pop		r1							; 引数に割込み要因番号を設定
	bsr		_kernel_log_exc_leave		; ログトレース関数の呼出し
.endif

	clrpsw	i							; ここからは必ず割込み禁止
	mov.l	#__kernel_intnest, r5
	mov.w	[r5], r4
	sub		#1, r4						; ネスト回数をデクリメント
	mov.w	r4, [r5]
	cmp		#0, r4						; 多重割り込みかどうか
	bnz		exception_return			; 多重割り込みならリターン
	; 初段の割込み
	pop		r0							; タスクのスタックに戻す
	add		#EXCINF_REG_SIZE, r0		; CPU例外情報の破棄
	bra		task_return					; 割込みのtask_returnへ
exception_nonkernel:
	mov.l	#__kernel_intnest, r5
	mov.w	[r5], r4
	add		#1, r4						; ネスト回数をインクリメント
	mov.w	r4, [r5]
	cmp		#1, r4						; 多重割り込みかどうか
	bnz		exception_from_nonkernelint	; 加算前が0でなければ多重割込み
						; 初段の割込み
	mov.l	#__kernel_istkpt, r5		; 割込み用のスタックへ切替える
	mov.l	[r5], r0
	push.l	r3							; タスクスタックを保持
exception_from_nonkernelint:	; 多重割込み
	mov.l	EXC_GET_PSW_OFFSET[r3], r5
	mvtc	r5, psw						; CPU例外発生前の状態に戻す

	mov.l	r3, r1						; 引数のp_excinfを設定
	jsr  	r2							; Cルーチン呼び出し

	clrpsw	i							; ここからは必ず割込み禁止
	mov.l	#__kernel_intnest, r5
	mov.w	[r5], r4
	sub		#1, r4						; ネスト回数をデクリメント
	mov.w	r4, [r5]
	cmp		#0, r4						; 多重割り込みかどうか
	bnz		exception_return			; 多重割り込みならリターン
	; 初段の割込み
	pop		r0							; タスクのスタックに戻す

exception_return:
	add		#EXCINF_REG_SIZE, r0		; CPU例外情報の破棄
	bra		interrupt_return

;
;  サービスコールの出入口処理
;
;  呼出し条件:
;  ・割込み発生時のH/W処理により,スタックに割込みからの復帰PCとPSWが
;    保存されている.
;  ・r5は機能コード
;
_kernel_service_call:
	;
	;  機能コードの下限値チェック
	;
	cmp		#TMIN_FNCD, r5
ret_svc_rsfn: ; TODO: 処理
	blt		ret_svc_rsfn

	;
	;  第5パラメータを取得してr14に格納する
	;
	mov.l	4[sp], r15				; 元のPSWをr15に
	tst		#PSW_U_MASK, r15
	beq		service_call_1			; 呼び出し元は特権モードの場合は遷移
	mvfc	usp, r14
	mov.l	[r14], r14
	bra		service_call_2
service_call_1:
	mov.l	8[sp], r14				; sp状態はPC, PSW, 第五パラメータ // TODO: PC before 第五パラメータ?
service_call_2:

	;
	;  機能コードが0より大きければ，拡張サービスコール処理へ
	;
	cmp		#0, r5
	bgt		extsvc_entry

	;
	;  ソフトウェア割込み前のシステム状態に戻す
	;
	tst		#PSW_I_MASK, r15
	beq		service_call_3
	setpsw	i

service_call_3:
	;
	;  サービスコールを呼び出す
	;
	push.l	r14						; 第5パラメータをスタックに積む
	mov.l	#__kernel_svc_table, r14
	abs		r5
	rotl	#2, r5
	add		r5, r14
	mov.l	[r14], r14				; サービスコールの番地を算出
	jsr		r14						; サービスコールへ分岐

	;
	;  サービスコールからのリターン処理
	;
service_call_return:
	add		#4, sp					; 第5パラメータを捨てる

	;
	;  ソフトウェア割込みからのリターン後のシステム状態が，この時点での
	;  システム状態になるように準備する
	;
	mvfc	psw, r14				; psw → r14
	and		#PSW_I_MASK, r14
	mov.l	4[sp], r15
	and		#~PSW_I_MASK, r15
	or		r14, r15
	mov.l	r15, 4[sp]

	;
	;  サービスコールからのリターン
	;
ret_svc_1:
	rte

	;
	;  拡張サービスコールの出入口処理
	;
	;  呼び出し条件：
	;  ・r5は機能コード、r14は第5パラメータ、r15は元のPSW
	;
extsvc_entry:
	;
	;  第5パラメータをスタックに積む
	;
	;  第5パラメータを早めに積んで，使用できるレジスタを確保する．r15
	;  をスタックに積むのは，第6パラメータ（cdmid）を置く領域を確保す
	;  るためであり，積んでいる値には意味がない．
	;
	pushm	r14-r15					; r15はスペース確保のため

	;
	;  機能コードの上限値チェック
	;
	mov.l	#__kernel_tmax_fncd, r14
	mov.l	[r14], r14
	cmp		r14, r5
ret_extsvc_rsfn: ; TODO: impl
	bgt		ret_extsvc_rsfn

	;
	;  拡張サービスコールルーチンの先頭番地を取得．NULLでないかチェック
	;
	mov.l	#__kernel_svcinib_table-8, r14
	rotl	#3, r5
	add		r5, r14						; p_svcinibを取得
	mov.l	SVCINIB_svcrtn[r14], r15	; p_svcinib->svcrtnを取得
	cmp		#0, r15						; p_svcinib->svcrtnがNULLか？
	beq		ret_extsvc_rsfn

	;
	;  非タスクコンテキストからの呼出しなら，extsvc_entry_1へ分岐
	;
	mov.l	#__kernel_intnest, r5
	mov.w	[r5], r5
	cmp		#0, r5
	mov.l	#TDOM_KERNEL, r5
	bnz		extsvc_entry_1

    ;
    ;  システムスタックの残量チェック［NGKI3197］
    ;
   	mov.l	#__kernel_p_runtsk, r5
	mov.l	[r5], r5
	mov.l	TCB_p_tinib[r5], r5
	mov.l	TINIB_sstk[r5], r5		; スタックの先頭番地 → r5
	sub		r5, sp, r5				; スタック残量 → r5
ret_extsvc_nomem: ; TODO:
	blt		ret_extsvc_nomem		; スタック残量 < 0 ならエラー
	mov.l	SVCINIB_stksz[r14], r14	; p_svcinib->stksz → r14
	cmp		r14, r5					; スタックの残量 < r14 ならエラー
	blt		ret_extsvc_nomem

    ;
    ;  svclevelのチェックとインクリメント［NGKI3198］
    ;
   	mov.l	#__kernel_p_runtsk, r5
	mov.l	[r5], r5
	mov.b	TCB_svclevel[r5], r14
	cmp		#255, r14				; svclevel == UINT8_MAX ならエラー
ret_extsvc_sys: ; TODO:
	beq		ret_extsvc_sys
	add		#1, r14					; svclevelをインクリメント
	mov.b	r14, TCB_svclevel[r5]

	;
	;  cdmidを求め，rundomを更新する
	;
   	mov.l	#__kernel_rundom, r14
   	mov.l	[r14], r5					; rundom → r5
   	cmp		#0, r5
   	mov.l	#TDOM_KERNEL, r5			; rundomがTACP_KERNELであれば
   	beq		extsvc_entry_1				;			  extsvc_entry_1へ
   	mov.l	#0, [r14]					; rundomをTACP_KERNELに設定
   	mov.l	#__kernel_p_runtsk, r5		; ドメインID → r5
	mov.l	[r5], r5
	mov.l	TCB_p_tinib[r5], r5
	mov.l	TINIB_domid[r5], r5

extsvc_entry_1:
	;
	;  ソフトウェア割込み前のシステム状態に戻す
	;
	; 【この時点のレジスタ状態】
	;  r15:拡張サービスコールルーチンの先頭番地
	;  r5 :cdmid（呼出し元の保護ドメインID）
	;
	mov.l	12[sp], r14			; スタックに保存した元のPSWを取得
	tst		#PSW_I_MASK, r14
	beq		extsvc_entry_2
	setpsw	i
extsvc_entry_2:
	mov.l	r5, 4[sp]			; cdmidをスタック上に置く（r15の場所）

.if 0 ; TODO: support me!
#ifdef LOG_EXTSVC_ENTER
	push	{r0-r3,r4}				/* r4はアラインメントのため */
	push	{lr}					/* cdmidをスタックに積む */
	ldr		lr, [sp,#24]			/* 第5パラメータをスタックに積む */
	push	{lr}
	push	{r3}					/* 第4パラメータをスタックに積む */
	ldr		r3, [sp,#20]			/* 第3パラメータ → r3 */
	ldr		r2, [sp,#16]			/* 第2パラメータ → r2 */
	ldr		r1, [sp,#12]			/* 第1パラメータ → r1 */
	mov		r0, r5					/* 機能コード → r0 */
	bl		log_extsvc_enter
	add		sp, sp, #12				/* 3つのパラメータを捨てる */
	pop		{r0-r3,r4}
#endif /* LOG_EXTSVC_ENTER */
.endif

	;
	;  拡張サービスコールを呼び出す
	;
	jsr		r15

.if 0 ; TODO: support me
#ifdef LOG_EXTSVC_LEAVE
	push	{r0,r1}					/* r1はアラインメントのため */
	mov		r1, r0					/* 拡張サービスコールの返り値 → r1 */
	mov		r0, r5					/* 機能コード → r0 */
	bl		log_extsvc_leave
	pop		{r0,r1}
#endif /* LOG_EXTSVC_LEAVE */
.endif

ret_extsvc:
	add		#8, sp				; 第5〜6パラメータを捨てる

	;
	;  ソフトウェア割込みからのリターン後のシステム状態が，この時点での
	;  システム状態になるように準備する
	;
	mvfc	psw, r14				; psw → r14
	and		#PSW_I_MASK, r14
	mov.l	4[sp], r15
	and		#~PSW_I_MASK, r15
	or		r14, r15
	mov.l	r15, 4[sp]


	;
	;  カーネル管理の割込みを禁止する．
	;
; TODO: mask カーネル管理の割込み ONLY
	clrpsw	i

	;
	;  非タスクコンテキストからの呼出しなら，リターン
	;
	mov.l	#__kernel_intnest, r5
	mov.w	[r5], r5
	cmp		#0, r5
	bnz		ret_svc_1

    ;
    ;  svclevelのデクリメントし，0にならなければリターン
    ;
   	mov.l	#__kernel_p_runtsk, r5
	mov.l	[r5], r5
	mov.b	TCB_svclevel[r5], r14
	sub		#1, r14					; svclevelをデクリメント
	mov.b	r14, TCB_svclevel[r5]
	bne		ret_svc_1

	;
	;  rundomの設定
	;
	mov.l	TCB_p_dominib[r5], r14
	mov.l	#__kernel_rundom, r5
	mov.l	DOMINIB_domptn[r14], [r5]
	bra		ret_svc_1

	.end
